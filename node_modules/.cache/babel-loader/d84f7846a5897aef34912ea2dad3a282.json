{"ast":null,"code":"'use strict';\n\nconst MongoError = require('./core/error').MongoError;\nconst WriteConcern = require('./write_concern');\nvar shallowClone = function (obj) {\n  var copy = {};\n  for (var name in obj) copy[name] = obj[name];\n  return copy;\n};\n\n// Set simple property\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = new Map();\n  if (sortValue == null) return null;\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy.set(`${sortValue[i]}`, 1);\n      } else {\n        orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    if (sortValue instanceof Map) {\n      orderBy = sortValue;\n    } else {\n      var sortKeys = Object.keys(sortValue);\n      for (var k of sortKeys) {\n        orderBy.set(k, sortValue[k]);\n      }\n    }\n  } else if (typeof sortValue === 'string') {\n    orderBy.set(`${sortValue}`, 1);\n  } else {\n    throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n  return orderBy;\n};\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n  return true;\n};\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  });\n\n  // Get all object keys\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {\n      // continue\n    }\n  }\n  return e;\n};\n\n/**\n * @ignore\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n  return finalHint;\n};\n\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys;\n\n  // Get all the fields accordingly\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n};\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n  return command;\n};\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n  return target;\n};\n\n// Merge options with translation\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n  return target;\n};\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  }\n\n  // Filtered options\n  return filterOptions;\n};\n\n// Write concern keys\nconst WRITE_CONCERN_KEYS = ['w', 'j', 'wtimeout', 'fsync', 'writeConcern'];\n\n/**\n * If there is no WriteConcern related options defined on target then inherit from source.\n * Otherwise, do not inherit **any** options from source.\n * @internal\n * @param {object} target - options object conditionally receiving the writeConcern options\n * @param {object} source - options object containing the potentially inherited writeConcern options\n */\nfunction conditionallyMergeWriteConcern(target, source) {\n  let found = false;\n  for (const wcKey of WRITE_CONCERN_KEYS) {\n    if (wcKey in target) {\n      // Found a writeConcern option\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    for (const wcKey of WRITE_CONCERN_KEYS) {\n      if (source[wcKey]) {\n        if (!('writeConcern' in target)) {\n          target.writeConcern = {};\n        }\n        target.writeConcern[wcKey] = source[wcKey];\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1];\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session, opOptions, owner;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner && !options.returnsCursor) {\n      session.endSession(() => {\n        delete opOptions.session;\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  };\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n    args.push(handler);\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n  return target;\n}\n\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n    return target;\n  }\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n  return target;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  const topology = target.s && target.s.topology || target.topology;\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n  const capabilities = topology.capabilities();\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  let readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param {object} command - the command on which to apply the explain\n * @param {Explain} explain - the options containing the explain verbosity\n * @return the new command\n */\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\nconst nodejsMajorVersion = +process.version.split('.')[0].substring(1);\nconst emitProcessWarning = msg => nodejsMajorVersion <= 6 ? process.emitWarning(msg, 'DeprecationWarning', MONGODB_WARNING_CODE) : process.emitWarning(msg, {\n  type: 'DeprecationWarning',\n  code: MONGODB_WARNING_CODE\n});\n// eslint-disable-next-line no-console\nconst emitConsoleWarning = msg => console.error(msg);\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n  function deprecated() {\n    const options = arguments[config.optionsIndex];\n\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n    return fn.apply(this, arguments);\n  }\n\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n  return deprecated;\n}\nconst SUPPORTS = {};\n// Test asyncIterator support\ntry {\n  require('./async/async_iterator');\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n}\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;\n  let result;\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n  fn(function (err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n      return;\n    }\n    callback(err, res);\n  });\n  return result;\n}\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime;\n\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n  return {\n    wake,\n    stop\n  };\n}\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n  return Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON()).map(k => k[0]).indexOf('$') >= 0;\n}\n\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nconst MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n\n/**\n * @internal\n * @param {string} message - message to warn about\n */\nfunction emitWarning(message) {\n  if (process.emitWarning) {\n    return nodejsMajorVersion <= 6 ? process.emitWarning(message, undefined, MONGODB_WARNING_CODE) : process.emitWarning(message, {\n      code: MONGODB_WARNING_CODE\n    });\n  } else {\n    // Approximate the style of print out on node versions pre 8.x\n    // eslint-disable-next-line no-console\n    return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);\n  }\n}\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n * @param {string} message - message to warn about\n */\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isRecord(value, requiredKeys) {\n  const toString = Object.prototype.toString;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  const isObject = v => toString.call(v) === '[object Object]';\n  if (!isObject(value)) {\n    return false;\n  }\n  const ctor = value.constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n\n    // Check to see if some method exists from the Object exists\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n  return true;\n}\n\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n    return res;\n  }\n  const ctor = value.constructor;\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n      case 'map':\n        return new Map(value);\n      case 'set':\n        return new Set(value);\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n  return value;\n}\n/**\n * @param {{version: string}} pkg\n * @returns {{ major: number; minor: number; patch: number }}\n */\nfunction parsePackageVersion(pkg) {\n  const versionParts = pkg.version.split('.').map(n => Number.parseInt(n, 10));\n  return {\n    major: versionParts[0],\n    minor: versionParts[1],\n    patch: versionParts[2]\n  };\n}\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  conditionallyMergeWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  decorateWithExplain,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators,\n  MONGODB_WARNING_CODE,\n  emitWarning,\n  emitWarningOnce,\n  deepCopy,\n  parsePackageVersion\n};","map":{"version":3,"names":["MongoError","require","WriteConcern","shallowClone","obj","copy","name","getSingleProperty","value","Object","defineProperty","enumerable","get","formatSortValue","exports","sortDirection","toLowerCase","Error","formattedOrderClause","sortValue","orderBy","Map","Array","isArray","length","i","constructor","String","set","sortKeys","keys","k","checkCollectionName","collectionName","indexOf","match","handleCallback","callback","err","value1","value2","process","nextTick","toError","error","msg","errmsg","errMessage","e","create","message","driver","normalizeHintField","hint","finalHint","forEach","param","parseIndexOptions","fieldOrSpec","fieldHash","indexes","push","f","isObject","key","join","arg","prototype","toString","call","debugOptions","debugFields","options","finaloptions","n","decorateCommand","command","exclude","mergeOptions","target","source","translateOptions","translations","sslCA","sslCRL","sslValidate","sslKey","sslCert","sslPass","socketTimeoutMS","connectTimeoutMS","replicaSet","rs_name","secondaryAcceptableLatencyMS","connectWithNoPrimary","acceptableLatencyMS","filterOptions","names","WRITE_CONCERN_KEYS","conditionallyMergeWriteConcern","found","wcKey","writeConcern","executeLegacyOperation","topology","operation","args","TypeError","Promise","s","promiseLibrary","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","makeExecuteCallback","resolve","reject","executeCallback","result","returnsCursor","endSession","pop","handler","apply","applyRetryableWrites","db","retryWrites","applyWriteConcern","sources","coll","collection","inTransaction","fromOptions","isPromiseLike","maybePromise","then","decorateWithCollation","capabilities","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","decorateWithExplain","explain","verbosity","nodejsMajorVersion","version","split","substring","emitProcessWarning","emitWarning","MONGODB_WARNING_CODE","type","code","emitConsoleWarning","console","emitDeprecationWarning","defaultMsgHandler","option","deprecateOptions","config","fn","noDeprecation","msgHandler","optionsWarned","Set","deprecated","arguments","deprecatedOptions","deprecatedOption","hasOwnProperty","has","add","getLogger","logger","warn","setPrototypeOf","SUPPORTS","ASYNC_ITERATOR","MongoDBNamespace","withCollection","fromString","namespace","index","makeCounter","seed","count","newCount","parent","PromiseLibrary","res","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptableAsyncInterval","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","clock","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","reschedule","executeAndReschedule","stop","clearTimeout","ms","setTimeout","hasAtomicOperators","doc","reduce","u","toBSON","map","undefined","emittedWarnings","emitWarningOnce","isSuperset","subset","elem","isRecord","requiredKeys","v","ctor","deepCopy","item","Number","Buffer","from","parsePackageVersion","pkg","versionParts","parseInt","major","minor","patch","module","MAX_JS_INT","MAX_SAFE_INTEGER"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/utils.js"],"sourcesContent":["'use strict';\nconst MongoError = require('./core/error').MongoError;\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function(obj) {\n  var copy = {};\n  for (var name in obj) copy[name] = obj[name];\n  return copy;\n};\n\n// Set simple property\nvar getSingleProperty = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function() {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = (exports.formatSortValue = function(sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error(\n        'Illegal sort clause, must be of the form ' +\n          \"[['field1', '(ascending|descending)'], \" +\n          \"['field2', '(ascending|descending)']]\"\n      );\n  }\n});\n\nvar formattedOrderClause = (exports.formattedOrderClause = function(sortValue) {\n  var orderBy = new Map();\n  if (sortValue == null) return null;\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy.set(`${sortValue[i]}`, 1);\n      } else {\n        orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    if (sortValue instanceof Map) {\n      orderBy = sortValue;\n    } else {\n      var sortKeys = Object.keys(sortValue);\n      for (var k of sortKeys) {\n        orderBy.set(k, sortValue[k]);\n      }\n    }\n  } else if (typeof sortValue === 'string') {\n    orderBy.set(`${sortValue}`, 1);\n  } else {\n    throw new Error(\n      'Illegal sort clause, must be of the form ' +\n        \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\"\n    );\n  }\n\n  return orderBy;\n});\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (\n    collectionName.indexOf('$') !== -1 &&\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\n  ) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function(callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function() {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nvar toError = function(error) {\n  if (error instanceof Error) return error;\n\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({ message: msg, driver: true });\n\n  // Get all object keys\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {\n      // continue\n    }\n  }\n\n  return e;\n};\n\n/**\n * @ignore\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(function(param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\nvar parseIndexOptions = function(fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys;\n\n  // Get all the fields accordingly\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function(f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function(k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function(key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = (exports.isObject = function(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n});\n\nvar debugOptions = function(debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function(n) {\n    finaloptions[n] = options[n];\n  });\n\n  return finaloptions;\n};\n\nvar decorateCommand = function(command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function(target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n};\n\n// Merge options with translation\nvar translateOptions = function(target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function(options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  }\n\n  // Filtered options\n  return filterOptions;\n};\n\n// Write concern keys\nconst WRITE_CONCERN_KEYS = ['w', 'j', 'wtimeout', 'fsync', 'writeConcern'];\n\n/**\n * If there is no WriteConcern related options defined on target then inherit from source.\n * Otherwise, do not inherit **any** options from source.\n * @internal\n * @param {object} target - options object conditionally receiving the writeConcern options\n * @param {object} source - options object containing the potentially inherited writeConcern options\n */\nfunction conditionallyMergeWriteConcern(target, source) {\n  let found = false;\n  for (const wcKey of WRITE_CONCERN_KEYS) {\n    if (wcKey in target) {\n      // Found a writeConcern option\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (const wcKey of WRITE_CONCERN_KEYS) {\n      if (source[wcKey]) {\n        if (!('writeConcern' in target)) {\n          target.writeConcern = {};\n        }\n        target.writeConcern[wcKey] = source[wcKey];\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1];\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session, opOptions, owner;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({ owner });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) =>\n    function executeCallback(err, result) {\n      if (session && session.owner === owner && !options.returnsCursor) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(\n      result => callback(null, result),\n      err => callback(err, null)\n    );\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function(resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, { writeConcern });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n  }\n\n  return target;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  const topology = (target.s && target.s.topology) || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  let readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param {object} command - the command on which to apply the explain\n * @param {Explain} explain - the options containing the explain verbosity\n * @return the new command\n */\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return { explain: command, verbosity: explain.verbosity };\n}\n\nconst nodejsMajorVersion = +process.version.split('.')[0].substring(1);\nconst emitProcessWarning = msg =>\n  nodejsMajorVersion <= 6\n    ? process.emitWarning(msg, 'DeprecationWarning', MONGODB_WARNING_CODE)\n    : process.emitWarning(msg, { type: 'DeprecationWarning', code: MONGODB_WARNING_CODE });\n// eslint-disable-next-line no-console\nconst emitConsoleWarning = msg => console.error(msg);\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n\n  const optionsWarned = new Set();\n  function deprecated() {\n    const options = arguments[config.optionsIndex];\n\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (\n        Object.prototype.hasOwnProperty.call(options, deprecatedOption) &&\n        !optionsWarned.has(deprecatedOption)\n      ) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n\n    return fn.apply(this, arguments);\n  }\n\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {};\n// Test asyncIterator support\ntry {\n  require('./async/async_iterator');\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = (parent && parent.s && parent.s.promiseLibrary) || Promise;\n\n  let result;\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function(err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n      return;\n    }\n\n    callback(err, res);\n  });\n\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime;\n\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return { wake, stop };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  return (\n    Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON())\n      .map(k => k[0])\n      .indexOf('$') >= 0\n  );\n}\n\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nconst MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n\n/**\n * @internal\n * @param {string} message - message to warn about\n */\nfunction emitWarning(message) {\n  if (process.emitWarning) {\n    return nodejsMajorVersion <= 6\n      ? process.emitWarning(message, undefined, MONGODB_WARNING_CODE)\n      : process.emitWarning(message, { code: MONGODB_WARNING_CODE });\n  } else {\n    // Approximate the style of print out on node versions pre 8.x\n    // eslint-disable-next-line no-console\n    return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);\n  }\n}\n\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n * @param {string} message - message to warn about\n */\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isRecord(value, requiredKeys) {\n  const toString = Object.prototype.toString;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  const isObject = v => toString.call(v) === '[object Object]';\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = value.constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n\n    // Check to see if some method exists from the Object exists\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n    return res;\n  }\n\n  const ctor = value.constructor;\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n      case 'map':\n        return new Map(value);\n      case 'set':\n        return new Set(value);\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n/**\n * @param {{version: string}} pkg\n * @returns {{ major: number; minor: number; patch: number }}\n */\nfunction parsePackageVersion(pkg) {\n  const versionParts = pkg.version.split('.').map(n => Number.parseInt(n, 10));\n  return { major: versionParts[0], minor: versionParts[1], patch: versionParts[2] };\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  conditionallyMergeWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  decorateWithExplain,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators,\n  MONGODB_WARNING_CODE,\n  emitWarning,\n  emitWarningOnce,\n  deepCopy,\n  parsePackageVersion\n};\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,cAAc,CAAC,CAACD,UAAU;AACrD,MAAME,YAAY,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAE/C,IAAIE,YAAY,GAAG,UAASC,GAAG,EAAE;EAC/B,IAAIC,IAAI,GAAG,CAAC,CAAC;EACb,KAAK,IAAIC,IAAI,IAAIF,GAAG,EAAEC,IAAI,CAACC,IAAI,CAAC,GAAGF,GAAG,CAACE,IAAI,CAAC;EAC5C,OAAOD,IAAI;AACb,CAAC;;AAED;AACA,IAAIE,iBAAiB,GAAG,UAASH,GAAG,EAAEE,IAAI,EAAEE,KAAK,EAAE;EACjDC,MAAM,CAACC,cAAc,CAACN,GAAG,EAAEE,IAAI,EAAE;IAC/BK,UAAU,EAAE,IAAI;IAChBC,GAAG,EAAE,YAAW;MACd,OAAOJ,KAAK;IACd;EACF,CAAC,CAAC;AACJ,CAAC;AAED,IAAIK,eAAe,GAAIC,OAAO,CAACD,eAAe,GAAG,UAASE,aAAa,EAAE;EACvE,IAAIP,KAAK,GAAG,CAAC,EAAE,GAAGO,aAAa,EAAEC,WAAW,EAAE;EAE9C,QAAQR,KAAK;IACX,KAAK,WAAW;IAChB,KAAK,KAAK;IACV,KAAK,GAAG;MACN,OAAO,CAAC;IACV,KAAK,YAAY;IACjB,KAAK,MAAM;IACX,KAAK,IAAI;MACP,OAAO,CAAC,CAAC;IACX;MACE,MAAM,IAAIS,KAAK,CACb,2CAA2C,GACzC,yCAAyC,GACzC,uCAAuC,CAC1C;EAAC;AAER,CAAE;AAEF,IAAIC,oBAAoB,GAAIJ,OAAO,CAACI,oBAAoB,GAAG,UAASC,SAAS,EAAE;EAC7E,IAAIC,OAAO,GAAG,IAAIC,GAAG,EAAE;EACvB,IAAIF,SAAS,IAAI,IAAI,EAAE,OAAO,IAAI;EAClC,IAAIG,KAAK,CAACC,OAAO,CAACJ,SAAS,CAAC,EAAE;IAC5B,IAAIA,SAAS,CAACK,MAAM,KAAK,CAAC,EAAE;MAC1B,OAAO,IAAI;IACb;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,SAAS,CAACK,MAAM,EAAEC,CAAC,EAAE,EAAE;MACzC,IAAIN,SAAS,CAACM,CAAC,CAAC,CAACC,WAAW,KAAKC,MAAM,EAAE;QACvCP,OAAO,CAACQ,GAAG,CAAE,GAAET,SAAS,CAACM,CAAC,CAAE,EAAC,EAAE,CAAC,CAAC;MACnC,CAAC,MAAM;QACLL,OAAO,CAACQ,GAAG,CAAE,GAAET,SAAS,CAACM,CAAC,CAAC,CAAC,CAAC,CAAE,EAAC,EAAEZ,eAAe,CAACM,SAAS,CAACM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACrE;IACF;EACF,CAAC,MAAM,IAAIN,SAAS,IAAI,IAAI,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;IAC7D,IAAIA,SAAS,YAAYE,GAAG,EAAE;MAC5BD,OAAO,GAAGD,SAAS;IACrB,CAAC,MAAM;MACL,IAAIU,QAAQ,GAAGpB,MAAM,CAACqB,IAAI,CAACX,SAAS,CAAC;MACrC,KAAK,IAAIY,CAAC,IAAIF,QAAQ,EAAE;QACtBT,OAAO,CAACQ,GAAG,CAACG,CAAC,EAAEZ,SAAS,CAACY,CAAC,CAAC,CAAC;MAC9B;IACF;EACF,CAAC,MAAM,IAAI,OAAOZ,SAAS,KAAK,QAAQ,EAAE;IACxCC,OAAO,CAACQ,GAAG,CAAE,GAAET,SAAU,EAAC,EAAE,CAAC,CAAC;EAChC,CAAC,MAAM;IACL,MAAM,IAAIF,KAAK,CACb,2CAA2C,GACzC,8EAA8E,CACjF;EACH;EAEA,OAAOG,OAAO;AAChB,CAAE;AAEF,IAAIY,mBAAmB,GAAG,SAASA,mBAAmB,CAACC,cAAc,EAAE;EACrE,IAAI,QAAQ,KAAK,OAAOA,cAAc,EAAE;IACtC,MAAM,IAAIjC,UAAU,CAAC,kCAAkC,CAAC;EAC1D;EAEA,IAAI,CAACiC,cAAc,IAAIA,cAAc,CAACC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;IAC1D,MAAM,IAAIlC,UAAU,CAAC,kCAAkC,CAAC;EAC1D;EAEA,IACEiC,cAAc,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,IAClCD,cAAc,CAACE,KAAK,CAAC,4BAA4B,CAAC,IAAI,IAAI,EAC1D;IACA,MAAM,IAAInC,UAAU,CAAC,uCAAuC,CAAC;EAC/D;EAEA,IAAIiC,cAAc,CAACE,KAAK,CAAC,SAAS,CAAC,IAAI,IAAI,EAAE;IAC3C,MAAM,IAAInC,UAAU,CAAC,iDAAiD,CAAC;EACzE;;EAEA;EACA,IAAIiC,cAAc,CAACC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;IACzC,MAAM,IAAIlC,UAAU,CAAC,kDAAkD,CAAC;EAC1E;AACF,CAAC;AAED,IAAIoC,cAAc,GAAG,UAASC,QAAQ,EAAEC,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAE;EAC3D,IAAI;IACF,IAAIH,QAAQ,IAAI,IAAI,EAAE;IAEtB,IAAIA,QAAQ,EAAE;MACZ,OAAOG,MAAM,GAAGH,QAAQ,CAACC,GAAG,EAAEC,MAAM,EAAEC,MAAM,CAAC,GAAGH,QAAQ,CAACC,GAAG,EAAEC,MAAM,CAAC;IACvE;EACF,CAAC,CAAC,OAAOD,GAAG,EAAE;IACZG,OAAO,CAACC,QAAQ,CAAC,YAAW;MAC1B,MAAMJ,GAAG;IACX,CAAC,CAAC;IACF,OAAO,KAAK;EACd;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,IAAIK,OAAO,GAAG,UAASC,KAAK,EAAE;EAC5B,IAAIA,KAAK,YAAY3B,KAAK,EAAE,OAAO2B,KAAK;EAExC,IAAIC,GAAG,GAAGD,KAAK,CAACN,GAAG,IAAIM,KAAK,CAACE,MAAM,IAAIF,KAAK,CAACG,UAAU,IAAIH,KAAK;EAChE,IAAII,CAAC,GAAGhD,UAAU,CAACiD,MAAM,CAAC;IAAEC,OAAO,EAAEL,GAAG;IAAEM,MAAM,EAAE;EAAK,CAAC,CAAC;;EAEzD;EACA,IAAIrB,IAAI,GAAG,OAAOc,KAAK,KAAK,QAAQ,GAAGnC,MAAM,CAACqB,IAAI,CAACc,KAAK,CAAC,GAAG,EAAE;EAE9D,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,IAAI,CAACN,MAAM,EAAEC,CAAC,EAAE,EAAE;IACpC,IAAI;MACFuB,CAAC,CAAClB,IAAI,CAACL,CAAC,CAAC,CAAC,GAAGmB,KAAK,CAACd,IAAI,CAACL,CAAC,CAAC,CAAC;IAC7B,CAAC,CAAC,OAAOa,GAAG,EAAE;MACZ;IACF;EACF;EAEA,OAAOU,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA,IAAII,kBAAkB,GAAG,SAASA,kBAAkB,CAACC,IAAI,EAAE;EACzD,IAAIC,SAAS,GAAG,IAAI;EAEpB,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;IAC5BC,SAAS,GAAGD,IAAI;EAClB,CAAC,MAAM,IAAI/B,KAAK,CAACC,OAAO,CAAC8B,IAAI,CAAC,EAAE;IAC9BC,SAAS,GAAG,CAAC,CAAC;IAEdD,IAAI,CAACE,OAAO,CAAC,UAASC,KAAK,EAAE;MAC3BF,SAAS,CAACE,KAAK,CAAC,GAAG,CAAC;IACtB,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIH,IAAI,IAAI,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IACnDC,SAAS,GAAG,CAAC,CAAC;IACd,KAAK,IAAIhD,IAAI,IAAI+C,IAAI,EAAE;MACrBC,SAAS,CAAChD,IAAI,CAAC,GAAG+C,IAAI,CAAC/C,IAAI,CAAC;IAC9B;EACF;EAEA,OAAOgD,SAAS;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAIG,iBAAiB,GAAG,UAASC,WAAW,EAAE;EAC5C,IAAIC,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAI9B,IAAI;;EAER;EACA,IAAI,QAAQ,KAAK,OAAO4B,WAAW,EAAE;IACnC;IACAE,OAAO,CAACC,IAAI,CAACH,WAAW,GAAG,GAAG,GAAG,CAAC,CAAC;IACnCC,SAAS,CAACD,WAAW,CAAC,GAAG,CAAC;EAC5B,CAAC,MAAM,IAAIpC,KAAK,CAACC,OAAO,CAACmC,WAAW,CAAC,EAAE;IACrCA,WAAW,CAACH,OAAO,CAAC,UAASO,CAAC,EAAE;MAC9B,IAAI,QAAQ,KAAK,OAAOA,CAAC,EAAE;QACzB;QACAF,OAAO,CAACC,IAAI,CAACC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;QACzBH,SAAS,CAACG,CAAC,CAAC,GAAG,CAAC;MAClB,CAAC,MAAM,IAAIxC,KAAK,CAACC,OAAO,CAACuC,CAAC,CAAC,EAAE;QAC3B;QACAF,OAAO,CAACC,IAAI,CAACC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QACtCH,SAAS,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;MAC7B,CAAC,MAAM,IAAIC,QAAQ,CAACD,CAAC,CAAC,EAAE;QACtB;QACAhC,IAAI,GAAGrB,MAAM,CAACqB,IAAI,CAACgC,CAAC,CAAC;QACrBhC,IAAI,CAACyB,OAAO,CAAC,UAASxB,CAAC,EAAE;UACvB6B,OAAO,CAACC,IAAI,CAAC9B,CAAC,GAAG,GAAG,GAAG+B,CAAC,CAAC/B,CAAC,CAAC,CAAC;UAC5B4B,SAAS,CAAC5B,CAAC,CAAC,GAAG+B,CAAC,CAAC/B,CAAC,CAAC;QACrB,CAAC,CAAC;MACJ,CAAC,MAAM;QACL;MACF;IACF,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIgC,QAAQ,CAACL,WAAW,CAAC,EAAE;IAChC;IACA5B,IAAI,GAAGrB,MAAM,CAACqB,IAAI,CAAC4B,WAAW,CAAC;IAC/B5B,IAAI,CAACyB,OAAO,CAAC,UAASS,GAAG,EAAE;MACzBJ,OAAO,CAACC,IAAI,CAACG,GAAG,GAAG,GAAG,GAAGN,WAAW,CAACM,GAAG,CAAC,CAAC;MAC1CL,SAAS,CAACK,GAAG,CAAC,GAAGN,WAAW,CAACM,GAAG,CAAC;IACnC,CAAC,CAAC;EACJ;EAEA,OAAO;IACL1D,IAAI,EAAEsD,OAAO,CAACK,IAAI,CAAC,GAAG,CAAC;IACvBnC,IAAI,EAAEA,IAAI;IACV6B,SAAS,EAAEA;EACb,CAAC;AACH,CAAC;AAED,IAAII,QAAQ,GAAIjD,OAAO,CAACiD,QAAQ,GAAG,UAASG,GAAG,EAAE;EAC/C,OAAO,iBAAiB,KAAKzD,MAAM,CAAC0D,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACH,GAAG,CAAC;AAClE,CAAE;AAEF,IAAII,YAAY,GAAG,UAASC,WAAW,EAAEC,OAAO,EAAE;EAChD,IAAIC,YAAY,GAAG,CAAC,CAAC;EACrBF,WAAW,CAAChB,OAAO,CAAC,UAASmB,CAAC,EAAE;IAC9BD,YAAY,CAACC,CAAC,CAAC,GAAGF,OAAO,CAACE,CAAC,CAAC;EAC9B,CAAC,CAAC;EAEF,OAAOD,YAAY;AACrB,CAAC;AAED,IAAIE,eAAe,GAAG,UAASC,OAAO,EAAEJ,OAAO,EAAEK,OAAO,EAAE;EACxD,KAAK,IAAIvE,IAAI,IAAIkE,OAAO,EAAE;IACxB,IAAIK,OAAO,CAAC3C,OAAO,CAAC5B,IAAI,CAAC,KAAK,CAAC,CAAC,EAAEsE,OAAO,CAACtE,IAAI,CAAC,GAAGkE,OAAO,CAAClE,IAAI,CAAC;EACjE;EAEA,OAAOsE,OAAO;AAChB,CAAC;AAED,IAAIE,YAAY,GAAG,UAASC,MAAM,EAAEC,MAAM,EAAE;EAC1C,KAAK,IAAI1E,IAAI,IAAI0E,MAAM,EAAE;IACvBD,MAAM,CAACzE,IAAI,CAAC,GAAG0E,MAAM,CAAC1E,IAAI,CAAC;EAC7B;EAEA,OAAOyE,MAAM;AACf,CAAC;;AAED;AACA,IAAIE,gBAAgB,GAAG,UAASF,MAAM,EAAEC,MAAM,EAAE;EAC9C,IAAIE,YAAY,GAAG;IACjB;IACAC,KAAK,EAAE,IAAI;IACXC,MAAM,EAAE,KAAK;IACbC,WAAW,EAAE,oBAAoB;IACjCC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAE,MAAM;IACfC,OAAO,EAAE,YAAY;IACrB;IACAC,eAAe,EAAE,eAAe;IAChCC,gBAAgB,EAAE,mBAAmB;IACrC;IACAC,UAAU,EAAE,SAAS;IACrBC,OAAO,EAAE,SAAS;IAClBC,4BAA4B,EAAE,mBAAmB;IACjDC,oBAAoB,EAAE,gCAAgC;IACtD;IACAC,mBAAmB,EAAE;EACvB,CAAC;EAED,KAAK,IAAIzF,IAAI,IAAI0E,MAAM,EAAE;IACvB,IAAIE,YAAY,CAAC5E,IAAI,CAAC,EAAE;MACtByE,MAAM,CAACG,YAAY,CAAC5E,IAAI,CAAC,CAAC,GAAG0E,MAAM,CAAC1E,IAAI,CAAC;IAC3C,CAAC,MAAM;MACLyE,MAAM,CAACzE,IAAI,CAAC,GAAG0E,MAAM,CAAC1E,IAAI,CAAC;IAC7B;EACF;EAEA,OAAOyE,MAAM;AACf,CAAC;AAED,IAAIiB,aAAa,GAAG,UAASxB,OAAO,EAAEyB,KAAK,EAAE;EAC3C,IAAID,aAAa,GAAG,CAAC,CAAC;EAEtB,KAAK,IAAI1F,IAAI,IAAIkE,OAAO,EAAE;IACxB,IAAIyB,KAAK,CAAC/D,OAAO,CAAC5B,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE0F,aAAa,CAAC1F,IAAI,CAAC,GAAGkE,OAAO,CAAClE,IAAI,CAAC;EACrE;;EAEA;EACA,OAAO0F,aAAa;AACtB,CAAC;;AAED;AACA,MAAME,kBAAkB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,UAAU,EAAE,OAAO,EAAE,cAAc,CAAC;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,8BAA8B,CAACpB,MAAM,EAAEC,MAAM,EAAE;EACtD,IAAIoB,KAAK,GAAG,KAAK;EACjB,KAAK,MAAMC,KAAK,IAAIH,kBAAkB,EAAE;IACtC,IAAIG,KAAK,IAAItB,MAAM,EAAE;MACnB;MACAqB,KAAK,GAAG,IAAI;MACZ;IACF;EACF;EAEA,IAAI,CAACA,KAAK,EAAE;IACV,KAAK,MAAMC,KAAK,IAAIH,kBAAkB,EAAE;MACtC,IAAIlB,MAAM,CAACqB,KAAK,CAAC,EAAE;QACjB,IAAI,EAAE,cAAc,IAAItB,MAAM,CAAC,EAAE;UAC/BA,MAAM,CAACuB,YAAY,GAAG,CAAC,CAAC;QAC1B;QACAvB,MAAM,CAACuB,YAAY,CAACD,KAAK,CAAC,GAAGrB,MAAM,CAACqB,KAAK,CAAC;MAC5C;IACF;EACF;EAEA,OAAOtB,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMwB,sBAAsB,GAAG,CAACC,QAAQ,EAAEC,SAAS,EAAEC,IAAI,EAAElC,OAAO,KAAK;EACrE,IAAIgC,QAAQ,IAAI,IAAI,EAAE;IACpB,MAAM,IAAIG,SAAS,CAAC,gDAAgD,CAAC;EACvE;EAEA,IAAI,CAACrF,KAAK,CAACC,OAAO,CAACmF,IAAI,CAAC,EAAE;IACxB,MAAM,IAAIC,SAAS,CAAC,qDAAqD,CAAC;EAC5E;EAEAnC,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAMoC,OAAO,GAAGJ,QAAQ,CAACK,CAAC,CAACC,cAAc;EACzC,IAAIzE,QAAQ,GAAGqE,IAAI,CAACA,IAAI,CAAClF,MAAM,GAAG,CAAC,CAAC;;EAEpC;EACA;EACA,IAAIuF,OAAO,EAAEC,SAAS,EAAEC,KAAK;EAC7B,IAAI,CAACzC,OAAO,CAAC0C,YAAY,IAAIV,QAAQ,CAACW,iBAAiB,EAAE,EAAE;IACzDH,SAAS,GAAGN,IAAI,CAACA,IAAI,CAAClF,MAAM,GAAG,CAAC,CAAC;IACjC,IAAIwF,SAAS,IAAI,IAAI,IAAIA,SAAS,CAACD,OAAO,IAAI,IAAI,EAAE;MAClDE,KAAK,GAAGG,MAAM,EAAE;MAChBL,OAAO,GAAGP,QAAQ,CAACa,YAAY,CAAC;QAAEJ;MAAM,CAAC,CAAC;MAC1C,MAAMK,YAAY,GAAGZ,IAAI,CAAClF,MAAM,GAAG,CAAC;MACpCkF,IAAI,CAACY,YAAY,CAAC,GAAG7G,MAAM,CAAC8G,MAAM,CAAC,CAAC,CAAC,EAAEb,IAAI,CAACY,YAAY,CAAC,EAAE;QAAEP,OAAO,EAAEA;MAAQ,CAAC,CAAC;IAClF,CAAC,MAAM,IAAIC,SAAS,CAACD,OAAO,IAAIC,SAAS,CAACD,OAAO,CAACS,QAAQ,EAAE;MAC1D,MAAM,IAAIxH,UAAU,CAAC,0CAA0C,CAAC;IAClE;EACF;EAEA,MAAMyH,mBAAmB,GAAG,CAACC,OAAO,EAAEC,MAAM,KAC1C,SAASC,eAAe,CAACtF,GAAG,EAAEuF,MAAM,EAAE;IACpC,IAAId,OAAO,IAAIA,OAAO,CAACE,KAAK,KAAKA,KAAK,IAAI,CAACzC,OAAO,CAACsD,aAAa,EAAE;MAChEf,OAAO,CAACgB,UAAU,CAAC,MAAM;QACvB,OAAOf,SAAS,CAACD,OAAO;QACxB,IAAIzE,GAAG,EAAE,OAAOqF,MAAM,CAACrF,GAAG,CAAC;QAC3BoF,OAAO,CAACG,MAAM,CAAC;MACjB,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,IAAIvF,GAAG,EAAE,OAAOqF,MAAM,CAACrF,GAAG,CAAC;MAC3BoF,OAAO,CAACG,MAAM,CAAC;IACjB;EACF,CAAC;;EAEH;EACA,IAAI,OAAOxF,QAAQ,KAAK,UAAU,EAAE;IAClCA,QAAQ,GAAGqE,IAAI,CAACsB,GAAG,EAAE;IACrB,MAAMC,OAAO,GAAGR,mBAAmB,CACjCI,MAAM,IAAIxF,QAAQ,CAAC,IAAI,EAAEwF,MAAM,CAAC,EAChCvF,GAAG,IAAID,QAAQ,CAACC,GAAG,EAAE,IAAI,CAAC,CAC3B;IACDoE,IAAI,CAAC7C,IAAI,CAACoE,OAAO,CAAC;IAElB,IAAI;MACF,OAAOxB,SAAS,CAACyB,KAAK,CAAC,IAAI,EAAExB,IAAI,CAAC;IACpC,CAAC,CAAC,OAAO1D,CAAC,EAAE;MACViF,OAAO,CAACjF,CAAC,CAAC;MACV,MAAMA,CAAC;IACT;EACF;;EAEA;EACA,IAAI0D,IAAI,CAACA,IAAI,CAAClF,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI,EAAE;IACjC,MAAM,IAAImF,SAAS,CAAC,+DAA+D,CAAC;EACtF;EAEA,OAAO,IAAIC,OAAO,CAAC,UAASc,OAAO,EAAEC,MAAM,EAAE;IAC3C,MAAMM,OAAO,GAAGR,mBAAmB,CAACC,OAAO,EAAEC,MAAM,CAAC;IACpDjB,IAAI,CAACA,IAAI,CAAClF,MAAM,GAAG,CAAC,CAAC,GAAGyG,OAAO;IAE/B,IAAI;MACF,OAAOxB,SAAS,CAACyB,KAAK,CAAC,IAAI,EAAExB,IAAI,CAAC;IACpC,CAAC,CAAC,OAAO1D,CAAC,EAAE;MACViF,OAAO,CAACjF,CAAC,CAAC;IACZ;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAASmF,oBAAoB,CAACpD,MAAM,EAAEqD,EAAE,EAAE;EACxC,IAAIA,EAAE,IAAIA,EAAE,CAACvB,CAAC,CAACrC,OAAO,CAAC6D,WAAW,EAAE;IAClCtD,MAAM,CAACsD,WAAW,GAAG,IAAI;EAC3B;EAEA,OAAOtD,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuD,iBAAiB,CAACvD,MAAM,EAAEwD,OAAO,EAAE/D,OAAO,EAAE;EACnDA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAM4D,EAAE,GAAGG,OAAO,CAACH,EAAE;EACrB,MAAMI,IAAI,GAAGD,OAAO,CAACE,UAAU;EAE/B,IAAIjE,OAAO,CAACuC,OAAO,IAAIvC,OAAO,CAACuC,OAAO,CAAC2B,aAAa,EAAE,EAAE;IACtD;IACA,IAAI3D,MAAM,CAACuB,YAAY,EAAE;MACvB,OAAOvB,MAAM,CAACuB,YAAY;IAC5B;IAEA,OAAOvB,MAAM;EACf;EAEA,MAAMuB,YAAY,GAAGpG,YAAY,CAACyI,WAAW,CAACnE,OAAO,CAAC;EACtD,IAAI8B,YAAY,EAAE;IAChB,OAAO7F,MAAM,CAAC8G,MAAM,CAACxC,MAAM,EAAE;MAAEuB;IAAa,CAAC,CAAC;EAChD;EAEA,IAAIkC,IAAI,IAAIA,IAAI,CAAClC,YAAY,EAAE;IAC7B,OAAO7F,MAAM,CAAC8G,MAAM,CAACxC,MAAM,EAAE;MAAEuB,YAAY,EAAE7F,MAAM,CAAC8G,MAAM,CAAC,CAAC,CAAC,EAAEiB,IAAI,CAAClC,YAAY;IAAE,CAAC,CAAC;EACtF;EAEA,IAAI8B,EAAE,IAAIA,EAAE,CAAC9B,YAAY,EAAE;IACzB,OAAO7F,MAAM,CAAC8G,MAAM,CAACxC,MAAM,EAAE;MAAEuB,YAAY,EAAE7F,MAAM,CAAC8G,MAAM,CAAC,CAAC,CAAC,EAAEa,EAAE,CAAC9B,YAAY;IAAE,CAAC,CAAC;EACpF;EAEA,OAAOvB,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6D,aAAa,CAACC,YAAY,EAAE;EACnC,OAAOA,YAAY,IAAI,OAAOA,YAAY,CAACC,IAAI,KAAK,UAAU;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqB,CAACnE,OAAO,EAAEG,MAAM,EAAEP,OAAO,EAAE;EACvD,MAAMgC,QAAQ,GAAIzB,MAAM,CAAC8B,CAAC,IAAI9B,MAAM,CAAC8B,CAAC,CAACL,QAAQ,IAAKzB,MAAM,CAACyB,QAAQ;EAEnE,IAAI,CAACA,QAAQ,EAAE;IACb,MAAM,IAAIG,SAAS,CAAC,0CAA0C,CAAC;EACjE;EAEA,MAAMqC,YAAY,GAAGxC,QAAQ,CAACwC,YAAY,EAAE;EAC5C,IAAIxE,OAAO,CAACyE,SAAS,IAAI,OAAOzE,OAAO,CAACyE,SAAS,KAAK,QAAQ,EAAE;IAC9D,IAAID,YAAY,IAAIA,YAAY,CAACE,qBAAqB,EAAE;MACtDtE,OAAO,CAACqE,SAAS,GAAGzE,OAAO,CAACyE,SAAS;IACvC,CAAC,MAAM;MACL,MAAM,IAAIjJ,UAAU,CAAE,6CAA4C,CAAC;IACrE;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmJ,uBAAuB,CAACvE,OAAO,EAAE4D,IAAI,EAAEhE,OAAO,EAAE;EACvD,IAAIA,OAAO,IAAIA,OAAO,CAACuC,OAAO,IAAIvC,OAAO,CAACuC,OAAO,CAAC2B,aAAa,EAAE,EAAE;IACjE;EACF;EACA,IAAIU,WAAW,GAAG3I,MAAM,CAAC8G,MAAM,CAAC,CAAC,CAAC,EAAE3C,OAAO,CAACwE,WAAW,IAAI,CAAC,CAAC,CAAC;EAC9D,IAAIZ,IAAI,CAAC3B,CAAC,CAACuC,WAAW,EAAE;IACtB3I,MAAM,CAAC8G,MAAM,CAAC6B,WAAW,EAAEZ,IAAI,CAAC3B,CAAC,CAACuC,WAAW,CAAC;EAChD;EAEA,IAAI3I,MAAM,CAACqB,IAAI,CAACsH,WAAW,CAAC,CAAC5H,MAAM,GAAG,CAAC,EAAE;IACvCf,MAAM,CAAC8G,MAAM,CAAC3C,OAAO,EAAE;MAAEwE,WAAW,EAAEA;IAAY,CAAC,CAAC;EACtD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmB,CAACzE,OAAO,EAAE0E,OAAO,EAAE;EAC7C,IAAI1E,OAAO,CAAC0E,OAAO,EAAE;IACnB,OAAO1E,OAAO;EAChB;EAEA,OAAO;IAAE0E,OAAO,EAAE1E,OAAO;IAAE2E,SAAS,EAAED,OAAO,CAACC;EAAU,CAAC;AAC3D;AAEA,MAAMC,kBAAkB,GAAG,CAAC/G,OAAO,CAACgH,OAAO,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC,CAAC;AACtE,MAAMC,kBAAkB,GAAG/G,GAAG,IAC5B2G,kBAAkB,IAAI,CAAC,GACnB/G,OAAO,CAACoH,WAAW,CAAChH,GAAG,EAAE,oBAAoB,EAAEiH,oBAAoB,CAAC,GACpErH,OAAO,CAACoH,WAAW,CAAChH,GAAG,EAAE;EAAEkH,IAAI,EAAE,oBAAoB;EAAEC,IAAI,EAAEF;AAAqB,CAAC,CAAC;AAC1F;AACA,MAAMG,kBAAkB,GAAGpH,GAAG,IAAIqH,OAAO,CAACtH,KAAK,CAACC,GAAG,CAAC;AACpD,MAAMsH,sBAAsB,GAAG1H,OAAO,CAACoH,WAAW,GAAGD,kBAAkB,GAAGK,kBAAkB;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,iBAAiB,CAAC9J,IAAI,EAAE+J,MAAM,EAAE;EACvC,OAAQ,GAAE/J,IAAK,YAAW+J,MAAO,yDAAwD;AAC3F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgB,CAACC,MAAM,EAAEC,EAAE,EAAE;EACpC,IAAI/H,OAAO,CAACgI,aAAa,KAAK,IAAI,EAAE;IAClC,OAAOD,EAAE;EACX;EAEA,MAAME,UAAU,GAAGH,MAAM,CAACG,UAAU,GAAGH,MAAM,CAACG,UAAU,GAAGN,iBAAiB;EAE5E,MAAMO,aAAa,GAAG,IAAIC,GAAG,EAAE;EAC/B,SAASC,UAAU,GAAG;IACpB,MAAMrG,OAAO,GAAGsG,SAAS,CAACP,MAAM,CAACjD,YAAY,CAAC;;IAE9C;IACA,IAAI,CAACvD,QAAQ,CAACS,OAAO,CAAC,IAAI/D,MAAM,CAACqB,IAAI,CAAC0C,OAAO,CAAC,CAAChD,MAAM,KAAK,CAAC,EAAE;MAC3D,OAAOgJ,EAAE,CAACtC,KAAK,CAAC,IAAI,EAAE4C,SAAS,CAAC;IAClC;IAEAP,MAAM,CAACQ,iBAAiB,CAACxH,OAAO,CAACyH,gBAAgB,IAAI;MACnD,IACEvK,MAAM,CAAC0D,SAAS,CAAC8G,cAAc,CAAC5G,IAAI,CAACG,OAAO,EAAEwG,gBAAgB,CAAC,IAC/D,CAACL,aAAa,CAACO,GAAG,CAACF,gBAAgB,CAAC,EACpC;QACAL,aAAa,CAACQ,GAAG,CAACH,gBAAgB,CAAC;QACnC,MAAMnI,GAAG,GAAG6H,UAAU,CAACH,MAAM,CAACjK,IAAI,EAAE0K,gBAAgB,CAAC;QACrDb,sBAAsB,CAACtH,GAAG,CAAC;QAC3B,IAAI,IAAI,IAAI,IAAI,CAACuI,SAAS,EAAE;UAC1B,MAAMC,MAAM,GAAG,IAAI,CAACD,SAAS,EAAE;UAC/B,IAAIC,MAAM,EAAE;YACVA,MAAM,CAACC,IAAI,CAACzI,GAAG,CAAC;UAClB;QACF;MACF;IACF,CAAC,CAAC;IAEF,OAAO2H,EAAE,CAACtC,KAAK,CAAC,IAAI,EAAE4C,SAAS,CAAC;EAClC;;EAEA;EACA;EACArK,MAAM,CAAC8K,cAAc,CAACV,UAAU,EAAEL,EAAE,CAAC;EACrC,IAAIA,EAAE,CAACrG,SAAS,EAAE;IAChB;IACA;IACA;IACA0G,UAAU,CAAC1G,SAAS,GAAGqG,EAAE,CAACrG,SAAS;EACrC;EAEA,OAAO0G,UAAU;AACnB;AAEA,MAAMW,QAAQ,GAAG,CAAC,CAAC;AACnB;AACA,IAAI;EACFvL,OAAO,CAAC,wBAAwB,CAAC;EACjCuL,QAAQ,CAACC,cAAc,GAAG,IAAI;AAChC,CAAC,CAAC,OAAOzI,CAAC,EAAE;EACVwI,QAAQ,CAACC,cAAc,GAAG,KAAK;AACjC;AAEA,MAAMC,gBAAgB,CAAC;EACrBhK,WAAW,CAAC0G,EAAE,EAAEK,UAAU,EAAE;IAC1B,IAAI,CAACL,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACK,UAAU,GAAGA,UAAU;EAC9B;EAEArE,QAAQ,GAAG;IACT,OAAO,IAAI,CAACqE,UAAU,GAAI,GAAE,IAAI,CAACL,EAAG,IAAG,IAAI,CAACK,UAAW,EAAC,GAAG,IAAI,CAACL,EAAE;EACpE;EAEAuD,cAAc,CAAClD,UAAU,EAAE;IACzB,OAAO,IAAIiD,gBAAgB,CAAC,IAAI,CAACtD,EAAE,EAAEK,UAAU,CAAC;EAClD;EAEA,OAAOmD,UAAU,CAACC,SAAS,EAAE;IAC3B,IAAI,CAACA,SAAS,EAAE;MACd,MAAM,IAAI5K,KAAK,CAAE,gCAA+B4K,SAAU,GAAE,CAAC;IAC/D;IAEA,MAAMC,KAAK,GAAGD,SAAS,CAAC3J,OAAO,CAAC,GAAG,CAAC;IACpC,OAAO,IAAIwJ,gBAAgB,CAACG,SAAS,CAAClC,SAAS,CAAC,CAAC,EAAEmC,KAAK,CAAC,EAAED,SAAS,CAAClC,SAAS,CAACmC,KAAK,GAAG,CAAC,CAAC,CAAC;EAC5F;AACF;AAEA,UAAUC,WAAW,CAACC,IAAI,EAAE;EAC1B,IAAIC,KAAK,GAAGD,IAAI,IAAI,CAAC;EACrB,OAAO,IAAI,EAAE;IACX,MAAME,QAAQ,GAAGD,KAAK;IACtBA,KAAK,IAAI,CAAC;IACV,MAAMC,QAAQ;EAChB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrD,YAAY,CAACsD,MAAM,EAAE9J,QAAQ,EAAEmI,EAAE,EAAE;EAC1C,MAAM4B,cAAc,GAAID,MAAM,IAAIA,MAAM,CAACtF,CAAC,IAAIsF,MAAM,CAACtF,CAAC,CAACC,cAAc,IAAKF,OAAO;EAEjF,IAAIiB,MAAM;EACV,IAAI,OAAOxF,QAAQ,KAAK,UAAU,EAAE;IAClCwF,MAAM,GAAG,IAAIuE,cAAc,CAAC,CAAC1E,OAAO,EAAEC,MAAM,KAAK;MAC/CtF,QAAQ,GAAG,CAACC,GAAG,EAAE+J,GAAG,KAAK;QACvB,IAAI/J,GAAG,EAAE,OAAOqF,MAAM,CAACrF,GAAG,CAAC;QAC3BoF,OAAO,CAAC2E,GAAG,CAAC;MACd,CAAC;IACH,CAAC,CAAC;EACJ;EAEA7B,EAAE,CAAC,UAASlI,GAAG,EAAE+J,GAAG,EAAE;IACpB,IAAI/J,GAAG,IAAI,IAAI,EAAE;MACf,IAAI;QACFD,QAAQ,CAACC,GAAG,CAAC;MACf,CAAC,CAAC,OAAOM,KAAK,EAAE;QACd,OAAOH,OAAO,CAACC,QAAQ,CAAC,MAAM;UAC5B,MAAME,KAAK;QACb,CAAC,CAAC;MACJ;MACA;IACF;IAEAP,QAAQ,CAACC,GAAG,EAAE+J,GAAG,CAAC;EACpB,CAAC,CAAC;EAEF,OAAOxE,MAAM;AACf;AAEA,SAASyE,GAAG,GAAG;EACb,MAAMC,MAAM,GAAG9J,OAAO,CAAC8J,MAAM,EAAE;EAC/B,OAAOC,IAAI,CAACC,KAAK,CAACF,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGA,MAAM,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;AAC3D;AAEA,SAASG,qBAAqB,CAACC,OAAO,EAAE;EACtC,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC/B,MAAMhG,SAAS,CAAC,8CAA8C,CAAC;EACjE;EAEA,MAAMiG,OAAO,GAAGN,GAAG,EAAE,GAAGK,OAAO;EAC/B,OAAOC,OAAO,GAAG,CAAC,GAAG,CAAC,GAAGA,OAAO;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,8BAA8B,CAACrC,EAAE,EAAEhG,OAAO,EAAE;EACnD,IAAIsI,OAAO;EACX,IAAIC,YAAY;EAChB,IAAIC,YAAY;EAChB,IAAIC,OAAO,GAAG,KAAK;EAEnBzI,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAM0I,QAAQ,GAAG1I,OAAO,CAAC0I,QAAQ,IAAI,IAAI;EACzC,MAAMC,WAAW,GAAG3I,OAAO,CAAC2I,WAAW,IAAI,GAAG;EAC9C,MAAMC,SAAS,GAAG,OAAO5I,OAAO,CAAC4I,SAAS,KAAK,SAAS,GAAG5I,OAAO,CAAC4I,SAAS,GAAG,KAAK;EACpF,MAAMC,KAAK,GAAG,OAAO7I,OAAO,CAAC6I,KAAK,KAAK,UAAU,GAAG7I,OAAO,CAAC6I,KAAK,GAAGf,GAAG;EAEvE,SAASgB,IAAI,GAAG;IACd,MAAMC,WAAW,GAAGF,KAAK,EAAE;IAC3B,MAAMG,iBAAiB,GAAGD,WAAW,GAAGP,YAAY;IACpD,MAAMS,iBAAiB,GAAGF,WAAW,GAAGR,YAAY;IACpD,MAAMW,iBAAiB,GAAGR,QAAQ,GAAGO,iBAAiB;IACtDT,YAAY,GAAGO,WAAW;;IAE1B;IACA;IACA;IACA;IACA;;IAEA;IACA,IAAIC,iBAAiB,GAAGL,WAAW,EAAE;MACnC;IACF;;IAEA;IACA;IACA,IAAIO,iBAAiB,GAAGP,WAAW,EAAE;MACnCQ,UAAU,CAACR,WAAW,CAAC;IACzB;;IAEA;IACA;IACA;IACA;IACA,IAAIO,iBAAiB,GAAG,CAAC,EAAE;MACzBE,oBAAoB,EAAE;IACxB;EACF;EAEA,SAASC,IAAI,GAAG;IACdZ,OAAO,GAAG,IAAI;IACd,IAAIH,OAAO,EAAE;MACXgB,YAAY,CAAChB,OAAO,CAAC;MACrBA,OAAO,GAAG,IAAI;IAChB;IAEAC,YAAY,GAAG,CAAC;IAChBC,YAAY,GAAG,CAAC;EAClB;EAEA,SAASW,UAAU,CAACI,EAAE,EAAE;IACtB,IAAId,OAAO,EAAE;IACba,YAAY,CAAChB,OAAO,CAAC;IACrBA,OAAO,GAAGkB,UAAU,CAACJ,oBAAoB,EAAEG,EAAE,IAAIb,QAAQ,CAAC;EAC5D;EAEA,SAASU,oBAAoB,GAAG;IAC9BZ,YAAY,GAAG,CAAC;IAChBD,YAAY,GAAGM,KAAK,EAAE;IAEtB7C,EAAE,CAAClI,GAAG,IAAI;MACR,IAAIA,GAAG,EAAE,MAAMA,GAAG;MAClBqL,UAAU,CAACT,QAAQ,CAAC;IACtB,CAAC,CAAC;EACJ;EAEA,IAAIE,SAAS,EAAE;IACbQ,oBAAoB,EAAE;EACxB,CAAC,MAAM;IACLb,YAAY,GAAGM,KAAK,EAAE;IACtBM,UAAU,EAAE;EACd;EAEA,OAAO;IAAEL,IAAI;IAAEO;EAAK,CAAC;AACvB;AAEA,SAASI,kBAAkB,CAACC,GAAG,EAAE;EAC/B,IAAI5M,KAAK,CAACC,OAAO,CAAC2M,GAAG,CAAC,EAAE;IACtB,OAAOA,GAAG,CAACC,MAAM,CAAC,CAAC7L,GAAG,EAAE8L,CAAC,KAAK9L,GAAG,IAAI2L,kBAAkB,CAACG,CAAC,CAAC,EAAE,IAAI,CAAC;EACnE;EAEA,OACE3N,MAAM,CAACqB,IAAI,CAAC,OAAOoM,GAAG,CAACG,MAAM,KAAK,UAAU,GAAGH,GAAG,GAAGA,GAAG,CAACG,MAAM,EAAE,CAAC,CAC/DC,GAAG,CAACvM,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAAC,CACdG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC;AAExB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM4H,oBAAoB,GAAG,gBAAgB;;AAE7C;AACA;AACA;AACA;AACA,SAASD,WAAW,CAAC3G,OAAO,EAAE;EAC5B,IAAIT,OAAO,CAACoH,WAAW,EAAE;IACvB,OAAOL,kBAAkB,IAAI,CAAC,GAC1B/G,OAAO,CAACoH,WAAW,CAAC3G,OAAO,EAAEqL,SAAS,EAAEzE,oBAAoB,CAAC,GAC7DrH,OAAO,CAACoH,WAAW,CAAC3G,OAAO,EAAE;MAAE8G,IAAI,EAAEF;IAAqB,CAAC,CAAC;EAClE,CAAC,MAAM;IACL;IACA;IACA,OAAOI,OAAO,CAACtH,KAAK,CAAE,IAAGkH,oBAAqB,YAAW,EAAE5G,OAAO,CAAC;EACrE;AACF;AAEA,MAAMsL,eAAe,GAAG,IAAI5D,GAAG,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6D,eAAe,CAACvL,OAAO,EAAE;EAChC,IAAI,CAACsL,eAAe,CAACtD,GAAG,CAAChI,OAAO,CAAC,EAAE;IACjCsL,eAAe,CAACrD,GAAG,CAACjI,OAAO,CAAC;IAC5B,OAAO2G,WAAW,CAAC3G,OAAO,CAAC;EAC7B;AACF;AAEA,SAASwL,UAAU,CAAC9M,GAAG,EAAE+M,MAAM,EAAE;EAC/B/M,GAAG,GAAGN,KAAK,CAACC,OAAO,CAACK,GAAG,CAAC,GAAG,IAAIgJ,GAAG,CAAChJ,GAAG,CAAC,GAAGA,GAAG;EAC7C+M,MAAM,GAAGrN,KAAK,CAACC,OAAO,CAACoN,MAAM,CAAC,GAAG,IAAI/D,GAAG,CAAC+D,MAAM,CAAC,GAAGA,MAAM;EACzD,KAAK,MAAMC,IAAI,IAAID,MAAM,EAAE;IACzB,IAAI,CAAC/M,GAAG,CAACsJ,GAAG,CAAC0D,IAAI,CAAC,EAAE;MAClB,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AAEA,SAASC,QAAQ,CAACrO,KAAK,EAAEsO,YAAY,EAAE;EACrC,MAAM1K,QAAQ,GAAG3D,MAAM,CAAC0D,SAAS,CAACC,QAAQ;EAC1C,MAAM6G,cAAc,GAAGxK,MAAM,CAAC0D,SAAS,CAAC8G,cAAc;EACtD,MAAMlH,QAAQ,GAAGgL,CAAC,IAAI3K,QAAQ,CAACC,IAAI,CAAC0K,CAAC,CAAC,KAAK,iBAAiB;EAC5D,IAAI,CAAChL,QAAQ,CAACvD,KAAK,CAAC,EAAE;IACpB,OAAO,KAAK;EACd;EAEA,MAAMwO,IAAI,GAAGxO,KAAK,CAACkB,WAAW;EAC9B,IAAIsN,IAAI,IAAIA,IAAI,CAAC7K,SAAS,EAAE;IAC1B,IAAI,CAACJ,QAAQ,CAACiL,IAAI,CAAC7K,SAAS,CAAC,EAAE;MAC7B,OAAO,KAAK;IACd;;IAEA;IACA,IAAI,CAAC8G,cAAc,CAAC5G,IAAI,CAAC2K,IAAI,CAAC7K,SAAS,EAAE,eAAe,CAAC,EAAE;MACzD,OAAO,KAAK;IACd;EACF;EAEA,IAAI2K,YAAY,EAAE;IAChB,MAAMhN,IAAI,GAAGrB,MAAM,CAACqB,IAAI,CAACtB,KAAK,CAAC;IAC/B,OAAOkO,UAAU,CAAC5M,IAAI,EAAEgN,YAAY,CAAC;EACvC;EAEA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,QAAQ,CAACzO,KAAK,EAAE;EACvB,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjB,OAAOA,KAAK;EACd,CAAC,MAAM,IAAIc,KAAK,CAACC,OAAO,CAACf,KAAK,CAAC,EAAE;IAC/B,OAAOA,KAAK,CAAC8N,GAAG,CAACY,IAAI,IAAID,QAAQ,CAACC,IAAI,CAAC,CAAC;EAC1C,CAAC,MAAM,IAAIL,QAAQ,CAACrO,KAAK,CAAC,EAAE;IAC1B,MAAM6L,GAAG,GAAG,CAAC,CAAC;IACd,KAAK,MAAMrI,GAAG,IAAIxD,KAAK,EAAE;MACvB6L,GAAG,CAACrI,GAAG,CAAC,GAAGiL,QAAQ,CAACzO,KAAK,CAACwD,GAAG,CAAC,CAAC;IACjC;IACA,OAAOqI,GAAG;EACZ;EAEA,MAAM2C,IAAI,GAAGxO,KAAK,CAACkB,WAAW;EAC9B,IAAIsN,IAAI,EAAE;IACR,QAAQA,IAAI,CAAC1O,IAAI,CAACU,WAAW,EAAE;MAC7B,KAAK,MAAM;QACT,OAAO,IAAIgO,IAAI,CAACG,MAAM,CAAC3O,KAAK,CAAC,CAAC;MAChC,KAAK,KAAK;QACR,OAAO,IAAIa,GAAG,CAACb,KAAK,CAAC;MACvB,KAAK,KAAK;QACR,OAAO,IAAIoK,GAAG,CAACpK,KAAK,CAAC;MACvB,KAAK,QAAQ;QACX,OAAO4O,MAAM,CAACC,IAAI,CAAC7O,KAAK,CAAC;IAAC;EAEhC;EAEA,OAAOA,KAAK;AACd;AACA;AACA;AACA;AACA;AACA,SAAS8O,mBAAmB,CAACC,GAAG,EAAE;EAChC,MAAMC,YAAY,GAAGD,GAAG,CAAC9F,OAAO,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC4E,GAAG,CAAC5J,CAAC,IAAIyK,MAAM,CAACM,QAAQ,CAAC/K,CAAC,EAAE,EAAE,CAAC,CAAC;EAC5E,OAAO;IAAEgL,KAAK,EAAEF,YAAY,CAAC,CAAC,CAAC;IAAEG,KAAK,EAAEH,YAAY,CAAC,CAAC,CAAC;IAAEI,KAAK,EAAEJ,YAAY,CAAC,CAAC;EAAE,CAAC;AACnF;AAEAK,MAAM,CAAC/O,OAAO,GAAG;EACfkF,aAAa;EACblB,YAAY;EACZG,gBAAgB;EAChB9E,YAAY;EACZI,iBAAiB;EACjByB,mBAAmB;EACnBW,OAAO;EACPzB,oBAAoB;EACpBuC,iBAAiB;EACjBL,kBAAkB;EAClBhB,cAAc;EACduC,eAAe;EACfZ,QAAQ;EACRO,YAAY;EACZwL,UAAU,EAAEX,MAAM,CAACY,gBAAgB,GAAG,CAAC;EACvC5J,8BAA8B;EAC9BI,sBAAsB;EACtB4B,oBAAoB;EACpBG,iBAAiB;EACjBM,aAAa;EACbG,qBAAqB;EACrBI,uBAAuB;EACvBE,mBAAmB;EACnBiB,gBAAgB;EAChBkB,QAAQ;EACRE,gBAAgB;EAChBvB,sBAAsB;EACtB4B,WAAW;EACXlD,YAAY;EACZyD,GAAG;EACHI,qBAAqB;EACrBG,8BAA8B;EAC9BoB,kBAAkB;EAClBnE,oBAAoB;EACpBD,WAAW;EACX4E,eAAe;EACfQ,QAAQ;EACRK;AACF,CAAC"},"metadata":{},"sourceType":"script"}