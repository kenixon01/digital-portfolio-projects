{"ast":null,"code":"'use strict';\n\nconst ReadPreference = require('./read_preference');\nconst TopologyType = require('../sdam/common').TopologyType;\nconst MongoError = require('../error').MongoError;\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  }\n\n  // Check that all supplied compressors are valid\n  options.compression.compressors.forEach(function (compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n  return options.compression.compressors;\n}\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\nvar getPreviousDescription = function (self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n  return self.s.serverDescription;\n};\nvar emitServerDescriptionChanged = function (self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\nvar getPreviousTopologyDescription = function (self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: 'Unknown'\n      }]\n    };\n  }\n  return self.s.topologyDescription;\n};\nvar emitTopologyDescriptionChanged = function (self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\nvar changedIsMaster = function (self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\nvar getTopologyType = function (self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\nvar inquireServerState = function (self) {\n  return function (callback) {\n    if (self.s.state === 'destroyed') return;\n    // Record response time\n    var start = new Date().getTime();\n\n    // emitSDAMEvent\n    emitSDAMEvent(self, 'serverHeartbeatStarted', {\n      connectionId: self.name\n    });\n\n    // Attempt to execute ismaster command\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true\n    }, function (err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self);\n\n        // Calculate latencyMS\n        var latencyMS = new Date().getTime() - start;\n\n        // Server heart beat event\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        });\n\n        // Did the server change\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        }\n\n        // Updat ismaster view\n        self.s.ismaster = r.result;\n\n        // Set server response time\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      }\n\n      // Peforming an ismaster monitoring callback operation\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      }\n\n      // Perform another sweep\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n};\n\n//\n// Clone the options\nvar cloneOptions = function (options) {\n  var opts = {};\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n  return opts;\n};\nfunction Interval(fn, time) {\n  var timer = false;\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n    return this;\n  };\n  this.stop = function () {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\nfunction Timeout(fn, time) {\n  var timer = false;\n  var func = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = false;\n      fn();\n    }\n  };\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setTimeout(func, time);\n    }\n    return this;\n  };\n  this.stop = function () {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  };\n\n  // Previous entry\n  if (!previous) {\n    previous = {\n      servers: []\n    };\n  }\n\n  // Check if we have any previous servers missing in the current ones\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  }\n\n  // Check if there are any severs that don't exist\n  for (j = 0; j < current.servers.length; j++) {\n    found = false;\n\n    // Go over all the previous servers\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    // Add the server to the diff\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  }\n\n  // Got through all the servers\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i];\n\n    // Go through all current servers\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j];\n\n      // Matching server\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  }\n\n  // Return difference\n  return diff;\n}\n\n/**\n * Shared function to determine clusterTime for a given topology\n *\n * @param {*} topology\n * @param {*} clusterTime\n */\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n}\n\n// NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\nconst SessionMixins = {\n  endSessions: function (sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    }\n\n    // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n    this.command('admin.$cmd', {\n      endSessions: sessions\n    }, {\n      readPreference: ReadPreference.primaryPreferred\n    }, () => {\n      // intentionally ignored, per spec\n      if (typeof callback === 'function') callback();\n    });\n  }\n};\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n  return TopologyType.Single;\n}\nconst RETRYABLE_WIRE_VERSION = 6;\n\n/**\n * Determines whether the provided topology supports retryable writes\n *\n * @param {Mongos|Replset} topology\n */\nconst isRetryableWritesSupported = function (topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n  return true;\n};\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  }\n\n  // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n}\n\n// NOTE: only used for legacy topology types\nfunction legacyIsRetryableWriteError(err, topology) {\n  if (!(err instanceof MongoError)) {\n    return false;\n  }\n\n  // if pre-4.4 server, then add error label if its a retryable write error\n  if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {\n    err.addErrorLabel('RetryableWriteError');\n  }\n  return err.hasErrorLabel('RetryableWriteError');\n}\nmodule.exports = {\n  SessionMixins,\n  resolveClusterTime,\n  inquireServerState,\n  getTopologyType,\n  emitServerDescriptionChanged,\n  emitTopologyDescriptionChanged,\n  cloneOptions,\n  createCompressionInfo,\n  clone,\n  diff,\n  Interval,\n  Timeout,\n  isRetryableWritesSupported,\n  getMMAPError,\n  topologyType,\n  legacyIsRetryableWriteError\n};","map":{"version":3,"names":["ReadPreference","require","TopologyType","MongoError","isRetryableWriteError","maxWireVersion","MongoNetworkError","MMAPv1_RETRY_WRITES_ERROR_CODE","emitSDAMEvent","self","event","description","listeners","length","emit","createCompressionInfo","options","compression","compressors","forEach","compressor","Error","clone","object","JSON","parse","stringify","getPreviousDescription","s","serverDescription","address","name","arbiters","hosts","passives","type","emitServerDescriptionChanged","topologyId","id","previousDescription","newDescription","getPreviousTopologyDescription","topologyDescription","topologyType","servers","emitTopologyDescriptionChanged","changedIsMaster","currentIsmaster","ismaster","currentType","getTopologyType","newType","msg","secondary","arbiterOnly","inquireServerState","callback","state","start","Date","getTime","connectionId","command","monitoring","err","r","latencyMS","durationMS","reply","result","inTopology","isMasterLatencyMS","failure","inquireServerStateTimeout","setTimeout","haInterval","cloneOptions","opts","Interval","fn","time","timer","isRunning","setInterval","stop","clearInterval","Timeout","func","clearTimeout","diff","previous","current","i","found","j","toLowerCase","push","from","to","prevServer","currServer","resolveClusterTime","topology","$clusterTime","clusterTime","greaterThan","SessionMixins","endSessions","sessions","Array","isArray","readPreference","primaryPreferred","Sharded","ReplicaSetWithPrimary","Single","RETRYABLE_WIRE_VERSION","isRetryableWritesSupported","lastIsMaster","logicalSessionTimeoutMinutes","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","getMMAPError","code","errmsg","includes","newErr","message","originalError","legacyIsRetryableWriteError","addErrorLabel","hasErrorLabel","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/topologies/shared.js"],"sourcesContent":["'use strict';\nconst ReadPreference = require('./read_preference');\nconst TopologyType = require('../sdam/common').TopologyType;\nconst MongoError = require('../error').MongoError;\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  }\n\n  // Check that all supplied compressors are valid\n  options.compression.compressors.forEach(function(compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n\n  return options.compression.compressors;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function(self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function(self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function(self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [\n        {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        }\n      ]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function(self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function(self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function(self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function(self) {\n  return function(callback) {\n    if (self.s.state === 'destroyed') return;\n    // Record response time\n    var start = new Date().getTime();\n\n    // emitSDAMEvent\n    emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });\n\n    // Attempt to execute ismaster command\n    self.command('admin.$cmd', { ismaster: true }, { monitoring: true }, function(err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self);\n\n        // Calculate latencyMS\n        var latencyMS = new Date().getTime() - start;\n\n        // Server heart beat event\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        });\n\n        // Did the server change\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        }\n\n        // Updat ismaster view\n        self.s.ismaster = r.result;\n\n        // Set server response time\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      }\n\n      // Peforming an ismaster monitoring callback operation\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      }\n\n      // Perform another sweep\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n};\n\n//\n// Clone the options\nvar cloneOptions = function(options) {\n  var opts = {};\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function() {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function() {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function() {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n  var func = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = false;\n\n      fn();\n    }\n  };\n\n  this.start = function() {\n    if (!this.isRunning()) {\n      timer = setTimeout(func, time);\n    }\n    return this;\n  };\n\n  this.stop = function() {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function() {\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  };\n\n  // Previous entry\n  if (!previous) {\n    previous = { servers: [] };\n  }\n\n  // Check if we have any previous servers missing in the current ones\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  }\n\n  // Check if there are any severs that don't exist\n  for (j = 0; j < current.servers.length; j++) {\n    found = false;\n\n    // Go over all the previous servers\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    // Add the server to the diff\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  }\n\n  // Got through all the servers\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i];\n\n    // Go through all current servers\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j];\n\n      // Matching server\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  }\n\n  // Return difference\n  return diff;\n}\n\n/**\n * Shared function to determine clusterTime for a given topology\n *\n * @param {*} topology\n * @param {*} clusterTime\n */\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n}\n\n// NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\nconst SessionMixins = {\n  endSessions: function(sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    }\n\n    // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n    this.command(\n      'admin.$cmd',\n      { endSessions: sessions },\n      { readPreference: ReadPreference.primaryPreferred },\n      () => {\n        // intentionally ignored, per spec\n        if (typeof callback === 'function') callback();\n      }\n    );\n  }\n};\n\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  return TopologyType.Single;\n}\n\nconst RETRYABLE_WIRE_VERSION = 6;\n\n/**\n * Determines whether the provided topology supports retryable writes\n *\n * @param {Mongos|Replset} topology\n */\nconst isRetryableWritesSupported = function(topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  }\n\n  // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n}\n\n// NOTE: only used for legacy topology types\nfunction legacyIsRetryableWriteError(err, topology) {\n  if (!(err instanceof MongoError)) {\n    return false;\n  }\n\n  // if pre-4.4 server, then add error label if its a retryable write error\n  if (\n    isRetryableWritesSupported(topology) &&\n    (err instanceof MongoNetworkError ||\n      (maxWireVersion(topology) < 9 && isRetryableWriteError(err)))\n  ) {\n    err.addErrorLabel('RetryableWriteError');\n  }\n\n  return err.hasErrorLabel('RetryableWriteError');\n}\n\nmodule.exports = {\n  SessionMixins,\n  resolveClusterTime,\n  inquireServerState,\n  getTopologyType,\n  emitServerDescriptionChanged,\n  emitTopologyDescriptionChanged,\n  cloneOptions,\n  createCompressionInfo,\n  clone,\n  diff,\n  Interval,\n  Timeout,\n  isRetryableWritesSupported,\n  getMMAPError,\n  topologyType,\n  legacyIsRetryableWriteError\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}