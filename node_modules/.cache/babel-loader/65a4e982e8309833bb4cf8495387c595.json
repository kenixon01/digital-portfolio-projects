{"ast":null,"code":"'use strict';\n\nconst Denque = require('denque');\nconst EventEmitter = require('events');\nconst ServerDescription = require('./server_description').ServerDescription;\nconst ServerType = require('./common').ServerType;\nconst TopologyDescription = require('./topology_description').TopologyDescription;\nconst TopologyType = require('./common').TopologyType;\nconst events = require('./events');\nconst Server = require('./server').Server;\nconst relayEvents = require('../utils').relayEvents;\nconst ReadPreference = require('../topologies/read_preference');\nconst CoreCursor = require('../cursor').CoreCursor;\nconst deprecate = require('util').deprecate;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst createCompressionInfo = require('../topologies/shared').createCompressionInfo;\nconst ClientSession = require('../sessions').ClientSession;\nconst MongoError = require('../error').MongoError;\nconst MongoServerSelectionError = require('../error').MongoServerSelectionError;\nconst resolveClusterTime = require('../topologies/shared').resolveClusterTime;\nconst SrvPoller = require('./srv_polling').SrvPoller;\nconst getMMAPError = require('../topologies/shared').getMMAPError;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst eachAsync = require('../utils').eachAsync;\nconst emitDeprecationWarning = require('../../utils').emitDeprecationWarning;\nconst ServerSessionPool = require('../sessions').ServerSessionPool;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\nconst compareTopologyVersion = require('./server_description').compareTopologyVersion;\nconst emitWarning = require('../../utils').emitWarning;\nconst common = require('./common');\nconst drainTimerQueue = common.drainTimerQueue;\nconst clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;\nconst serverSelection = require('./server_selection');\nconst readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;\nconst writableServerSelector = serverSelection.writableServerSelector;\n\n// Global state\nlet globalTopologyCounter = 0;\n\n// events that we relay to the `Topology`\nconst SERVER_RELAY_EVENTS = ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'commandStarted', 'commandSucceeded', 'commandFailed',\n// NOTE: Legacy events\n'monitoring'].concat(CMAP_EVENT_NAMES);\n\n// all events we listen to from `Server` instances\nconst LOCAL_SERVER_EVENTS = ['connect', 'descriptionReceived', 'close', 'ended'];\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\nconst DEPRECATED_OPTIONS = new Set(['autoReconnect', 'reconnectTries', 'reconnectInterval', 'bufferMaxEntries']);\nconst kCancelled = Symbol('cancelled');\nconst kWaitQueue = Symbol('waitQueue');\n\n/**\n * A container of server instances representing a connection to a MongoDB topology.\n *\n * @fires Topology#serverOpening\n * @fires Topology#serverClosed\n * @fires Topology#serverDescriptionChanged\n * @fires Topology#topologyOpening\n * @fires Topology#topologyClosed\n * @fires Topology#topologyDescriptionChanged\n * @fires Topology#serverHeartbeatStarted\n * @fires Topology#serverHeartbeatSucceeded\n * @fires Topology#serverHeartbeatFailed\n */\nclass Topology extends EventEmitter {\n  /**\n   * Create a topology\n   *\n   * @param {Array|String} [seedlist] a string list, or array of Server instances to connect to\n   * @param {Object} [options] Optional settings\n   * @param {Number} [options.localThresholdMS=15] The size of the latency window for selecting among multiple suitable servers\n   * @param {Number} [options.serverSelectionTimeoutMS=30000] How long to block for server selection before throwing an error\n   * @param {Number} [options.heartbeatFrequencyMS=10000] The frequency with which topology updates are scheduled\n   */\n  constructor(seedlist, options) {\n    super();\n    if (typeof options === 'undefined' && typeof seedlist !== 'string') {\n      options = seedlist;\n      seedlist = [];\n\n      // this is for legacy single server constructor support\n      if (options.host) {\n        seedlist.push({\n          host: options.host,\n          port: options.port\n        });\n      }\n    }\n    seedlist = seedlist || [];\n    if (typeof seedlist === 'string') {\n      seedlist = parseStringSeedlist(seedlist);\n    }\n    options = Object.assign({}, common.TOPOLOGY_DEFAULTS, options);\n    options = Object.freeze(Object.assign(options, {\n      metadata: makeClientMetadata(options),\n      compression: {\n        compressors: createCompressionInfo(options)\n      }\n    }));\n    DEPRECATED_OPTIONS.forEach(optionName => {\n      if (options[optionName]) {\n        emitDeprecationWarning(`The option \\`${optionName}\\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, 'DeprecationWarning');\n      }\n    });\n    const topologyType = topologyTypeFromSeedlist(seedlist, options);\n    const topologyId = globalTopologyCounter++;\n    const serverDescriptions = seedlist.reduce((result, seed) => {\n      if (seed.domain_socket) seed.host = seed.domain_socket;\n      const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;\n      result.set(address, new ServerDescription(address));\n      return result;\n    }, new Map());\n    this[kWaitQueue] = new Denque();\n    this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options,\n      // initial seedlist of servers to connect to\n      seedlist: seedlist,\n      // initial state\n      state: STATE_CLOSED,\n      // the topology description\n      description: new TopologyDescription(topologyType, serverDescriptions, options.replicaSet, null, null, null, options),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,\n      // allow users to override the cursor factory\n      Cursor: options.cursorFactory || CoreCursor,\n      // the bson parser\n      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      // Server Session Pool\n      sessionPool: new ServerSessionPool(this),\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: options.promiseLibrary || Promise,\n      credentials: options.credentials,\n      clusterTime: null,\n      // timer management\n      connectionTimers: new Set()\n    };\n    if (options.srvHost) {\n      this.s.srvPoller = options.srvPoller || new SrvPoller({\n        heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,\n        srvHost: options.srvHost,\n        // TODO: GET THIS\n        logger: options.logger,\n        loggerLevel: options.loggerLevel\n      });\n      this.s.detectTopologyDescriptionChange = ev => {\n        const previousType = ev.previousDescription.type;\n        const newType = ev.newDescription.type;\n        if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {\n          this.s.handleSrvPolling = srvPollingHandler(this);\n          this.s.srvPoller.on('srvRecordDiscovery', this.s.handleSrvPolling);\n          this.s.srvPoller.start();\n        }\n      };\n      this.on('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\n    }\n\n    // NOTE: remove this when NODE-1709 is resolved\n    this.setMaxListeners(Infinity);\n  }\n\n  /**\n   * @return A `TopologyDescription` for this topology\n   */\n  get description() {\n    return this.s.description;\n  }\n  get parserType() {\n    return BSON.native ? 'c++' : 'js';\n  }\n\n  /**\n   * Initiate server connect\n   *\n   * @param {Object} [options] Optional settings\n   * @param {Array} [options.auth=null] Array of auth options to apply on connect\n   * @param {function} [callback] An optional callback called once on the first connected server\n   */\n  connect(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {};\n    if (this.s.state === STATE_CONNECTED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    stateTransition(this, STATE_CONNECTING);\n\n    // emit SDAM monitoring events\n    this.emit('topologyOpening', new events.TopologyOpeningEvent(this.s.id));\n\n    // emit an event for the topology change\n    this.emit('topologyDescriptionChanged', new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown),\n    // initial is always Unknown\n    this.s.description));\n\n    // connect all known servers, then attempt server selection to connect\n    connectServers(this, Array.from(this.s.description.servers.values()));\n    ReadPreference.translate(options);\n    const readPreference = options.readPreference || ReadPreference.primary;\n    const connectHandler = err => {\n      if (err) {\n        this.close();\n        if (typeof callback === 'function') {\n          callback(err);\n        } else {\n          this.emit('error', err);\n        }\n        return;\n      }\n      stateTransition(this, STATE_CONNECTED);\n      this.emit('open', err, this);\n      this.emit('connect', this);\n      if (typeof callback === 'function') callback(err, this);\n    };\n\n    // TODO: NODE-2471\n    if (this.s.credentials) {\n      this.command('admin.$cmd', {\n        ping: 1\n      }, {\n        readPreference\n      }, connectHandler);\n      return;\n    }\n    this.selectServer(readPreferenceServerSelector(readPreference), options, connectHandler);\n  }\n\n  /**\n   * Close this topology\n   */\n  close(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (typeof options === 'boolean') {\n      options = {\n        force: options\n      };\n    }\n    options = options || {};\n    if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    stateTransition(this, STATE_CLOSING);\n    drainWaitQueue(this[kWaitQueue], new MongoError('Topology closed'));\n    drainTimerQueue(this.s.connectionTimers);\n    if (this.s.srvPoller) {\n      this.s.srvPoller.stop();\n      if (this.s.handleSrvPolling) {\n        this.s.srvPoller.removeListener('srvRecordDiscovery', this.s.handleSrvPolling);\n        delete this.s.handleSrvPolling;\n      }\n    }\n    if (this.s.detectTopologyDescriptionChange) {\n      this.removeListener('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\n      delete this.s.detectTopologyDescriptionChange;\n    }\n    this.s.sessions.forEach(session => session.endSession());\n    this.s.sessionPool.endAllPooledSessions(() => {\n      eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options, cb), err => {\n        this.s.servers.clear();\n\n        // emit an event for close\n        this.emit('topologyClosed', new events.TopologyClosedEvent(this.s.id));\n        stateTransition(this, STATE_CLOSED);\n        if (typeof callback === 'function') {\n          callback(err);\n        }\n      });\n    });\n  }\n\n  /**\n   * Selects a server according to the selection predicate provided\n   *\n   * @param {function} [selector] An optional selector to select servers by, defaults to a random selection within a latency window\n   * @param {object} [options] Optional settings related to server selection\n   * @param {number} [options.serverSelectionTimeoutMS] How long to block for server selection before throwing an error\n   * @param {function} callback The callback used to indicate success or failure\n   * @return {Server} An instance of a `Server` meeting the criteria of the predicate provided\n   */\n  selectServer(selector, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      if (typeof selector !== 'function') {\n        options = selector;\n        let readPreference;\n        if (selector instanceof ReadPreference) {\n          readPreference = selector;\n        } else if (typeof selector === 'string') {\n          readPreference = new ReadPreference(selector);\n        } else {\n          ReadPreference.translate(options);\n          readPreference = options.readPreference || ReadPreference.primary;\n        }\n        selector = readPreferenceServerSelector(readPreference);\n      } else {\n        options = {};\n      }\n    }\n    options = Object.assign({}, {\n      serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS\n    }, options);\n    const isSharded = this.description.type === TopologyType.Sharded;\n    const session = options.session;\n    const transaction = session && session.transaction;\n    if (isSharded && transaction && transaction.server) {\n      callback(undefined, transaction.server);\n      return;\n    }\n\n    // support server selection by options with readPreference\n    let serverSelector = selector;\n    if (typeof selector === 'object') {\n      const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;\n      serverSelector = readPreferenceServerSelector(readPreference);\n    }\n    const waitQueueMember = {\n      serverSelector,\n      transaction,\n      callback\n    };\n    const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n    if (serverSelectionTimeoutMS) {\n      waitQueueMember.timer = setTimeout(() => {\n        waitQueueMember[kCancelled] = true;\n        waitQueueMember.timer = undefined;\n        const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);\n        waitQueueMember.callback(timeoutError);\n      }, serverSelectionTimeoutMS);\n    }\n    this[kWaitQueue].push(waitQueueMember);\n    processWaitQueue(this);\n  }\n\n  // Sessions related methods\n\n  /**\n   * @return Whether the topology should initiate selection to determine session support\n   */\n  shouldCheckForSessionSupport() {\n    if (this.description.type === TopologyType.Single) {\n      return !this.description.hasKnownServers;\n    }\n    return !this.description.hasDataBearingServers;\n  }\n\n  /**\n   * @return Whether sessions are supported on the current topology\n   */\n  hasSessionSupport() {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n\n  /**\n   * Start a logical session\n   */\n  startSession(options, clientOptions) {\n    const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);\n    session.once('ended', () => {\n      this.s.sessions.delete(session);\n    });\n    this.s.sessions.add(session);\n    return session;\n  }\n\n  /**\n   * Send endSessions command(s) with the given session ids\n   *\n   * @param {Array} sessions The sessions to end\n   * @param {function} [callback]\n   */\n  endSessions(sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    }\n    this.command('admin.$cmd', {\n      endSessions: sessions\n    }, {\n      readPreference: ReadPreference.primaryPreferred,\n      noResponse: true\n    }, () => {\n      // intentionally ignored, per spec\n      if (typeof callback === 'function') callback();\n    });\n  }\n\n  /**\n   * Update the internal TopologyDescription with a ServerDescription\n   *\n   * @param {object} serverDescription The server to update in the internal list of server descriptions\n   */\n  serverUpdateHandler(serverDescription) {\n    if (!this.s.description.hasServer(serverDescription.address)) {\n      return;\n    }\n\n    // ignore this server update if its from an outdated topologyVersion\n    if (isStaleServerDescription(this.s.description, serverDescription)) {\n      return;\n    }\n\n    // these will be used for monitoring events later\n    const previousTopologyDescription = this.s.description;\n    const previousServerDescription = this.s.description.servers.get(serverDescription.address);\n\n    // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n    // a server it MUST compare it to the current highest seen cluster time\n    // for the deployment. If the new cluster time is higher than the\n    // highest seen cluster time it MUST become the new highest seen cluster\n    // time. Two cluster times are compared using only the BsonTimestamp\n    // value of the clusterTime embedded field.\"\n    const clusterTime = serverDescription.$clusterTime;\n    if (clusterTime) {\n      resolveClusterTime(this, clusterTime);\n    }\n\n    // If we already know all the information contained in this updated description, then\n    // we don't need to emit SDAM events, but still need to update the description, in order\n    // to keep client-tracked attributes like last update time and round trip time up to date\n    const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);\n\n    // first update the TopologyDescription\n    this.s.description = this.s.description.update(serverDescription);\n    if (this.s.description.compatibilityError) {\n      this.emit('error', new MongoError(this.s.description.compatibilityError));\n      return;\n    }\n\n    // emit monitoring events for this change\n    if (!equalDescriptions) {\n      this.emit('serverDescriptionChanged', new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));\n    }\n\n    // update server list from updated descriptions\n    updateServers(this, serverDescription);\n\n    // attempt to resolve any outstanding server selection attempts\n    if (this[kWaitQueue].length > 0) {\n      processWaitQueue(this);\n    }\n    if (!equalDescriptions) {\n      this.emit('topologyDescriptionChanged', new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n    }\n  }\n  auth(credentials, callback) {\n    if (typeof credentials === 'function') callback = credentials, credentials = null;\n    if (typeof callback === 'function') callback(null, true);\n  }\n  logout(callback) {\n    if (typeof callback === 'function') callback(null, true);\n  }\n\n  // Basic operation support. Eventually this should be moved into command construction\n  // during the command refactor.\n\n  /**\n   * Insert one or more documents\n   *\n   * @param {String} ns The full qualified namespace for this operation\n   * @param {Array} ops An array of documents to insert\n   * @param {Boolean} [options.ordered=true] Execute in order or out of order\n   * @param {Object} [options.writeConcern] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n   * @param {opResultCallback} callback A callback function\n   */\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({\n      topology: this,\n      op: 'insert',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n  /**\n   * Perform one or more update operations\n   *\n   * @param {string} ns The fully qualified namespace for this operation\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n   * @param {opResultCallback} callback A callback function\n   */\n  update(ns, ops, options, callback) {\n    executeWriteOperation({\n      topology: this,\n      op: 'update',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n  /**\n   * Perform one or more remove operations\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n   * @param {opResultCallback} callback A callback function\n   */\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({\n      topology: this,\n      op: 'remove',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n  /**\n   * Execute a command\n   *\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Connection} [options.connection] Specify connection object to execute command against\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      callback = options, options = {}, options = options || {};\n    }\n    ReadPreference.translate(options);\n    const readPreference = options.readPreference || ReadPreference.primary;\n    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      const notAlreadyRetrying = !options.retrying;\n      const retryWrites = !!options.retryWrites;\n      const hasSession = !!options.session;\n      const supportsRetryableWrites = server.supportsRetryableWrites;\n      const notInTransaction = !hasSession || !options.session.inTransaction();\n      const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && isWriteCommand(cmd);\n      const cb = (err, result) => {\n        if (!err) return callback(null, result);\n        if (!shouldRetryOperation(err)) {\n          return callback(err);\n        }\n        if (willRetryWrite) {\n          const newOptions = Object.assign({}, options, {\n            retrying: true\n          });\n          return this.command(ns, cmd, newOptions, callback);\n        }\n        return callback(err);\n      };\n\n      // increment and assign txnNumber\n      if (willRetryWrite) {\n        options.session.incrementTransactionNumber();\n        options.willRetryWrite = willRetryWrite;\n      }\n      server.command(ns, cmd, options, cb);\n    });\n  }\n\n  /**\n   * Create a new cursor\n   *\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n   * @param {object} [options] Options for the cursor\n   * @param {object} [options.batchSize=0] Batchsize for the operation\n   * @param {array} [options.documents=[]] Initial documents list for cursor\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {object} [options.topology] The internal topology of the created cursor\n   * @returns {Cursor}\n   */\n  cursor(ns, cmd, options) {\n    options = options || {};\n    const topology = options.topology || this;\n    const CursorClass = options.cursorFactory || this.s.Cursor;\n    ReadPreference.translate(options);\n    return new CursorClass(topology, ns, cmd, options);\n  }\n  get clientMetadata() {\n    return this.s.options.metadata;\n  }\n  isConnected() {\n    return this.s.state === STATE_CONNECTED;\n  }\n  isDestroyed() {\n    return this.s.state === STATE_CLOSED;\n  }\n\n  /**\n   * @deprecated This function is deprecated and will be removed in the next major version.\n   */\n  unref() {\n    emitWarning('`unref` is a noop and will be removed in the next major version');\n  }\n\n  // NOTE: There are many places in code where we explicitly check the last isMaster\n  //       to do feature support detection. This should be done any other way, but for\n  //       now we will just return the first isMaster seen, which should suffice.\n  lastIsMaster() {\n    const serverDescriptions = Array.from(this.description.servers.values());\n    if (serverDescriptions.length === 0) return {};\n    const sd = serverDescriptions.filter(sd => sd.type !== ServerType.Unknown)[0];\n    const result = sd || {\n      maxWireVersion: this.description.commonWireVersion\n    };\n    return result;\n  }\n  get logicalSessionTimeoutMinutes() {\n    return this.description.logicalSessionTimeoutMinutes;\n  }\n  get bson() {\n    return this.s.bson;\n  }\n}\nObject.defineProperty(Topology.prototype, 'clusterTime', {\n  enumerable: true,\n  get: function () {\n    return this.s.clusterTime;\n  },\n  set: function (clusterTime) {\n    this.s.clusterTime = clusterTime;\n  }\n});\n\n// legacy aliases\nTopology.prototype.destroy = deprecate(Topology.prototype.close, 'destroy() is deprecated, please use close() instead');\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\nfunction isStaleServerDescription(topologyDescription, incomingServerDescription) {\n  const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);\n  const currentTopologyVersion = currentServerDescription.topologyVersion;\n  return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;\n}\n\n/**\n * Destroys a server, and removes all event listeners from the instance\n *\n * @param {Server} server\n */\nfunction destroyServer(server, topology, options, callback) {\n  options = options || {};\n  LOCAL_SERVER_EVENTS.forEach(event => server.removeAllListeners(event));\n  server.destroy(options, () => {\n    topology.emit('serverClosed', new events.ServerClosedEvent(topology.s.id, server.description.address));\n    SERVER_RELAY_EVENTS.forEach(event => server.removeAllListeners(event));\n    if (typeof callback === 'function') {\n      callback();\n    }\n  });\n}\n\n/**\n * Parses a basic seedlist in string form\n *\n * @param {string} seedlist The seedlist to parse\n */\nfunction parseStringSeedlist(seedlist) {\n  return seedlist.split(',').map(seed => ({\n    host: seed.split(':')[0],\n    port: seed.split(':')[1] || 27017\n  }));\n}\nfunction topologyTypeFromSeedlist(seedlist, options) {\n  if (options.directConnection) {\n    return TopologyType.Single;\n  }\n  const replicaSet = options.replicaSet || options.setName || options.rs_name;\n  if (replicaSet == null) {\n    return TopologyType.Unknown;\n  }\n  return TopologyType.ReplicaSetNoPrimary;\n}\nfunction randomSelection(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}\nfunction createAndConnectServer(topology, serverDescription, connectDelay) {\n  topology.emit('serverOpening', new events.ServerOpeningEvent(topology.s.id, serverDescription.address));\n  const server = new Server(serverDescription, topology.s.options, topology);\n  relayEvents(server, topology, SERVER_RELAY_EVENTS);\n  server.on('descriptionReceived', topology.serverUpdateHandler.bind(topology));\n  if (connectDelay) {\n    const connectTimer = setTimeout(() => {\n      clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);\n      server.connect();\n    }, connectDelay);\n    topology.s.connectionTimers.add(connectTimer);\n    return server;\n  }\n  server.connect();\n  return server;\n}\n\n/**\n * Create `Server` instances for all initially known servers, connect them, and assign\n * them to the passed in `Topology`.\n *\n * @param {Topology} topology The topology responsible for the servers\n * @param {ServerDescription[]} serverDescriptions A list of server descriptions to connect\n */\nfunction connectServers(topology, serverDescriptions) {\n  topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {\n    const server = createAndConnectServer(topology, serverDescription);\n    servers.set(serverDescription.address, server);\n    return servers;\n  }, new Map());\n}\nfunction updateServers(topology, incomingServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    const server = topology.s.servers.get(incomingServerDescription.address);\n    server.s.description = incomingServerDescription;\n  }\n\n  // add new servers for all descriptions we currently don't know about locally\n  for (const serverDescription of topology.description.servers.values()) {\n    if (!topology.s.servers.has(serverDescription.address)) {\n      const server = createAndConnectServer(topology, serverDescription);\n      topology.s.servers.set(serverDescription.address, server);\n    }\n  }\n\n  // for all servers no longer known, remove their descriptions and destroy their instances\n  for (const entry of topology.s.servers) {\n    const serverAddress = entry[0];\n    if (topology.description.hasServer(serverAddress)) {\n      continue;\n    }\n    const server = topology.s.servers.get(serverAddress);\n    topology.s.servers.delete(serverAddress);\n\n    // prepare server for garbage collection\n    destroyServer(server, topology);\n  }\n}\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const topology = args.topology;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n  topology.selectServer(writableServerSelector(), options, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n    const notAlreadyRetrying = !args.retrying;\n    const retryWrites = !!options.retryWrites;\n    const hasSession = !!options.session;\n    const supportsRetryableWrites = server.supportsRetryableWrites;\n    const notInTransaction = !hasSession || !options.session.inTransaction();\n    const notExplaining = options.explain === undefined;\n    const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && notExplaining;\n    const handler = (err, result) => {\n      if (!err) return callback(null, result);\n      if (!shouldRetryOperation(err)) {\n        err = getMMAPError(err);\n        return callback(err);\n      }\n      if (willRetryWrite) {\n        const newArgs = Object.assign({}, args, {\n          retrying: true\n        });\n        return executeWriteOperation(newArgs, options, callback);\n      }\n      return callback(err);\n    };\n    if (callback.operationId) {\n      handler.operationId = callback.operationId;\n    }\n\n    // increment and assign txnNumber\n    if (willRetryWrite) {\n      options.session.incrementTransactionNumber();\n      options.willRetryWrite = willRetryWrite;\n    }\n\n    // execute the write operation\n    server[op](ns, ops, options, handler);\n  });\n}\nfunction shouldRetryOperation(err) {\n  return err instanceof MongoError && err.hasErrorLabel('RetryableWriteError');\n}\nfunction srvPollingHandler(topology) {\n  return function handleSrvPolling(ev) {\n    const previousTopologyDescription = topology.s.description;\n    topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);\n    if (topology.s.description === previousTopologyDescription) {\n      // Nothing changed, so return\n      return;\n    }\n    updateServers(topology);\n    topology.emit('topologyDescriptionChanged', new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));\n  };\n}\nfunction drainWaitQueue(queue, err) {\n  while (queue.length) {\n    const waitQueueMember = queue.shift();\n    clearTimeout(waitQueueMember.timer);\n    if (!waitQueueMember[kCancelled]) {\n      waitQueueMember.callback(err);\n    }\n  }\n}\nfunction processWaitQueue(topology) {\n  if (topology.s.state === STATE_CLOSED) {\n    drainWaitQueue(topology[kWaitQueue], new MongoError('Topology is closed, please connect'));\n    return;\n  }\n  const serverDescriptions = Array.from(topology.description.servers.values());\n  const membersToProcess = topology[kWaitQueue].length;\n  for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {\n    const waitQueueMember = topology[kWaitQueue].shift();\n    if (waitQueueMember[kCancelled]) {\n      continue;\n    }\n    let selectedDescriptions;\n    try {\n      const serverSelector = waitQueueMember.serverSelector;\n      selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;\n    } catch (e) {\n      clearTimeout(waitQueueMember.timer);\n      waitQueueMember.callback(e);\n      continue;\n    }\n    if (selectedDescriptions.length === 0) {\n      topology[kWaitQueue].push(waitQueueMember);\n      continue;\n    }\n    const selectedServerDescription = randomSelection(selectedDescriptions);\n    const selectedServer = topology.s.servers.get(selectedServerDescription.address);\n    const transaction = waitQueueMember.transaction;\n    const isSharded = topology.description.type === TopologyType.Sharded;\n    if (isSharded && transaction && transaction.isActive) {\n      transaction.pinServer(selectedServer);\n    }\n    clearTimeout(waitQueueMember.timer);\n    waitQueueMember.callback(undefined, selectedServer);\n  }\n  if (topology[kWaitQueue].length > 0) {\n    // ensure all server monitors attempt monitoring soon\n    topology.s.servers.forEach(server => process.nextTick(() => server.requestCheck()));\n  }\n}\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event Topology#serverOpening\n * @type {ServerOpeningEvent}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event Topology#serverClosed\n * @type {ServerClosedEvent}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event Topology#serverDescriptionChanged\n * @type {ServerDescriptionChangedEvent}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event Topology#topologyOpening\n * @type {TopologyOpeningEvent}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event Topology#topologyClosed\n * @type {TopologyClosedEvent}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event Topology#topologyDescriptionChanged\n * @type {TopologyDescriptionChangedEvent}\n */\n\n/**\n * A topology serverHeartbeatStarted SDAM event\n *\n * @event Topology#serverHeartbeatStarted\n * @type {ServerHeartbeatStartedEvent}\n */\n\n/**\n * A topology serverHeartbeatFailed SDAM event\n *\n * @event Topology#serverHeartbeatFailed\n * @type {ServerHearbeatFailedEvent}\n */\n\n/**\n * A topology serverHeartbeatSucceeded SDAM change event\n *\n * @event Topology#serverHeartbeatSucceeded\n * @type {ServerHeartbeatSucceededEvent}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event Topology#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event Topology#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event Topology#commandFailed\n * @type {object}\n */\n\nmodule.exports = {\n  Topology\n};","map":{"version":3,"names":["Denque","require","EventEmitter","ServerDescription","ServerType","TopologyDescription","TopologyType","events","Server","relayEvents","ReadPreference","CoreCursor","deprecate","BSON","retrieveBSON","createCompressionInfo","ClientSession","MongoError","MongoServerSelectionError","resolveClusterTime","SrvPoller","getMMAPError","makeStateMachine","eachAsync","emitDeprecationWarning","ServerSessionPool","makeClientMetadata","CMAP_EVENT_NAMES","compareTopologyVersion","emitWarning","common","drainTimerQueue","clearAndRemoveTimerFrom","serverSelection","readPreferenceServerSelector","writableServerSelector","globalTopologyCounter","SERVER_RELAY_EVENTS","concat","LOCAL_SERVER_EVENTS","STATE_CLOSING","STATE_CLOSED","STATE_CONNECTING","STATE_CONNECTED","stateTransition","DEPRECATED_OPTIONS","Set","kCancelled","Symbol","kWaitQueue","Topology","constructor","seedlist","options","host","push","port","parseStringSeedlist","Object","assign","TOPOLOGY_DEFAULTS","freeze","metadata","compression","compressors","forEach","optionName","topologyType","topologyTypeFromSeedlist","topologyId","serverDescriptions","reduce","result","seed","domain_socket","address","set","Map","s","id","state","description","replicaSet","serverSelectionTimeoutMS","heartbeatFrequencyMS","minHeartbeatFrequencyMS","Cursor","cursorFactory","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","MaxKey","MinKey","ObjectId","BSONRegExp","Timestamp","servers","sessionPool","sessions","promiseLibrary","Promise","credentials","clusterTime","connectionTimers","srvHost","srvPoller","logger","loggerLevel","detectTopologyDescriptionChange","ev","previousType","previousDescription","type","newType","newDescription","Sharded","handleSrvPolling","srvPollingHandler","on","start","setMaxListeners","Infinity","parserType","native","connect","callback","emit","TopologyOpeningEvent","TopologyDescriptionChangedEvent","Unknown","connectServers","Array","from","values","translate","readPreference","primary","connectHandler","err","close","command","ping","selectServer","force","drainWaitQueue","stop","removeListener","session","endSession","endAllPooledSessions","server","cb","destroyServer","clear","TopologyClosedEvent","selector","isSharded","transaction","undefined","serverSelector","waitQueueMember","timer","setTimeout","timeoutError","processWaitQueue","shouldCheckForSessionSupport","Single","hasKnownServers","hasDataBearingServers","hasSessionSupport","logicalSessionTimeoutMinutes","startSession","clientOptions","once","delete","add","endSessions","isArray","primaryPreferred","noResponse","serverUpdateHandler","serverDescription","hasServer","isStaleServerDescription","previousTopologyDescription","previousServerDescription","get","$clusterTime","equalDescriptions","equals","update","compatibilityError","ServerDescriptionChangedEvent","updateServers","length","auth","logout","insert","ns","ops","executeWriteOperation","topology","op","remove","cmd","notAlreadyRetrying","retrying","retryWrites","hasSession","supportsRetryableWrites","notInTransaction","inTransaction","willRetryWrite","isWriteCommand","shouldRetryOperation","newOptions","incrementTransactionNumber","cursor","CursorClass","clientMetadata","isConnected","isDestroyed","unref","lastIsMaster","sd","filter","maxWireVersion","commonWireVersion","defineProperty","prototype","enumerable","destroy","RETRYABLE_WRITE_OPERATIONS","some","topologyDescription","incomingServerDescription","currentServerDescription","currentTopologyVersion","topologyVersion","event","removeAllListeners","ServerClosedEvent","split","map","directConnection","setName","rs_name","ReplicaSetNoPrimary","randomSelection","array","Math","floor","random","createAndConnectServer","connectDelay","ServerOpeningEvent","bind","connectTimer","has","entry","serverAddress","args","notExplaining","explain","handler","newArgs","operationId","hasErrorLabel","updateFromSrvPollingEvent","queue","shift","clearTimeout","membersToProcess","i","selectedDescriptions","e","selectedServerDescription","selectedServer","isActive","pinServer","process","nextTick","requestCheck","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/sdam/topology.js"],"sourcesContent":["'use strict';\nconst Denque = require('denque');\nconst EventEmitter = require('events');\nconst ServerDescription = require('./server_description').ServerDescription;\nconst ServerType = require('./common').ServerType;\nconst TopologyDescription = require('./topology_description').TopologyDescription;\nconst TopologyType = require('./common').TopologyType;\nconst events = require('./events');\nconst Server = require('./server').Server;\nconst relayEvents = require('../utils').relayEvents;\nconst ReadPreference = require('../topologies/read_preference');\nconst CoreCursor = require('../cursor').CoreCursor;\nconst deprecate = require('util').deprecate;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst createCompressionInfo = require('../topologies/shared').createCompressionInfo;\nconst ClientSession = require('../sessions').ClientSession;\nconst MongoError = require('../error').MongoError;\nconst MongoServerSelectionError = require('../error').MongoServerSelectionError;\nconst resolveClusterTime = require('../topologies/shared').resolveClusterTime;\nconst SrvPoller = require('./srv_polling').SrvPoller;\nconst getMMAPError = require('../topologies/shared').getMMAPError;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst eachAsync = require('../utils').eachAsync;\nconst emitDeprecationWarning = require('../../utils').emitDeprecationWarning;\nconst ServerSessionPool = require('../sessions').ServerSessionPool;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\nconst compareTopologyVersion = require('./server_description').compareTopologyVersion;\nconst emitWarning = require('../../utils').emitWarning;\n\nconst common = require('./common');\nconst drainTimerQueue = common.drainTimerQueue;\nconst clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;\n\nconst serverSelection = require('./server_selection');\nconst readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;\nconst writableServerSelector = serverSelection.writableServerSelector;\n\n// Global state\nlet globalTopologyCounter = 0;\n\n// events that we relay to the `Topology`\nconst SERVER_RELAY_EVENTS = [\n  'serverHeartbeatStarted',\n  'serverHeartbeatSucceeded',\n  'serverHeartbeatFailed',\n  'commandStarted',\n  'commandSucceeded',\n  'commandFailed',\n\n  // NOTE: Legacy events\n  'monitoring'\n].concat(CMAP_EVENT_NAMES);\n\n// all events we listen to from `Server` instances\nconst LOCAL_SERVER_EVENTS = ['connect', 'descriptionReceived', 'close', 'ended'];\n\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\nconst DEPRECATED_OPTIONS = new Set([\n  'autoReconnect',\n  'reconnectTries',\n  'reconnectInterval',\n  'bufferMaxEntries'\n]);\n\nconst kCancelled = Symbol('cancelled');\nconst kWaitQueue = Symbol('waitQueue');\n\n/**\n * A container of server instances representing a connection to a MongoDB topology.\n *\n * @fires Topology#serverOpening\n * @fires Topology#serverClosed\n * @fires Topology#serverDescriptionChanged\n * @fires Topology#topologyOpening\n * @fires Topology#topologyClosed\n * @fires Topology#topologyDescriptionChanged\n * @fires Topology#serverHeartbeatStarted\n * @fires Topology#serverHeartbeatSucceeded\n * @fires Topology#serverHeartbeatFailed\n */\nclass Topology extends EventEmitter {\n  /**\n   * Create a topology\n   *\n   * @param {Array|String} [seedlist] a string list, or array of Server instances to connect to\n   * @param {Object} [options] Optional settings\n   * @param {Number} [options.localThresholdMS=15] The size of the latency window for selecting among multiple suitable servers\n   * @param {Number} [options.serverSelectionTimeoutMS=30000] How long to block for server selection before throwing an error\n   * @param {Number} [options.heartbeatFrequencyMS=10000] The frequency with which topology updates are scheduled\n   */\n  constructor(seedlist, options) {\n    super();\n    if (typeof options === 'undefined' && typeof seedlist !== 'string') {\n      options = seedlist;\n      seedlist = [];\n\n      // this is for legacy single server constructor support\n      if (options.host) {\n        seedlist.push({ host: options.host, port: options.port });\n      }\n    }\n\n    seedlist = seedlist || [];\n    if (typeof seedlist === 'string') {\n      seedlist = parseStringSeedlist(seedlist);\n    }\n\n    options = Object.assign({}, common.TOPOLOGY_DEFAULTS, options);\n    options = Object.freeze(\n      Object.assign(options, {\n        metadata: makeClientMetadata(options),\n        compression: { compressors: createCompressionInfo(options) }\n      })\n    );\n\n    DEPRECATED_OPTIONS.forEach(optionName => {\n      if (options[optionName]) {\n        emitDeprecationWarning(\n          `The option \\`${optionName}\\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`,\n          'DeprecationWarning'\n        );\n      }\n    });\n\n    const topologyType = topologyTypeFromSeedlist(seedlist, options);\n    const topologyId = globalTopologyCounter++;\n    const serverDescriptions = seedlist.reduce((result, seed) => {\n      if (seed.domain_socket) seed.host = seed.domain_socket;\n      const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;\n      result.set(address, new ServerDescription(address));\n      return result;\n    }, new Map());\n\n    this[kWaitQueue] = new Denque();\n    this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options,\n      // initial seedlist of servers to connect to\n      seedlist: seedlist,\n      // initial state\n      state: STATE_CLOSED,\n      // the topology description\n      description: new TopologyDescription(\n        topologyType,\n        serverDescriptions,\n        options.replicaSet,\n        null,\n        null,\n        null,\n        options\n      ),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,\n      // allow users to override the cursor factory\n      Cursor: options.cursorFactory || CoreCursor,\n      // the bson parser\n      bson:\n        options.bson ||\n        new BSON([\n          BSON.Binary,\n          BSON.Code,\n          BSON.DBRef,\n          BSON.Decimal128,\n          BSON.Double,\n          BSON.Int32,\n          BSON.Long,\n          BSON.Map,\n          BSON.MaxKey,\n          BSON.MinKey,\n          BSON.ObjectId,\n          BSON.BSONRegExp,\n          BSON.Symbol,\n          BSON.Timestamp\n        ]),\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      // Server Session Pool\n      sessionPool: new ServerSessionPool(this),\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: options.promiseLibrary || Promise,\n      credentials: options.credentials,\n      clusterTime: null,\n\n      // timer management\n      connectionTimers: new Set()\n    };\n\n    if (options.srvHost) {\n      this.s.srvPoller =\n        options.srvPoller ||\n        new SrvPoller({\n          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,\n          srvHost: options.srvHost, // TODO: GET THIS\n          logger: options.logger,\n          loggerLevel: options.loggerLevel\n        });\n      this.s.detectTopologyDescriptionChange = ev => {\n        const previousType = ev.previousDescription.type;\n        const newType = ev.newDescription.type;\n\n        if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {\n          this.s.handleSrvPolling = srvPollingHandler(this);\n          this.s.srvPoller.on('srvRecordDiscovery', this.s.handleSrvPolling);\n          this.s.srvPoller.start();\n        }\n      };\n\n      this.on('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\n    }\n\n    // NOTE: remove this when NODE-1709 is resolved\n    this.setMaxListeners(Infinity);\n  }\n\n  /**\n   * @return A `TopologyDescription` for this topology\n   */\n  get description() {\n    return this.s.description;\n  }\n\n  get parserType() {\n    return BSON.native ? 'c++' : 'js';\n  }\n\n  /**\n   * Initiate server connect\n   *\n   * @param {Object} [options] Optional settings\n   * @param {Array} [options.auth=null] Array of auth options to apply on connect\n   * @param {function} [callback] An optional callback called once on the first connected server\n   */\n  connect(options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || {};\n    if (this.s.state === STATE_CONNECTED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n\n    // emit SDAM monitoring events\n    this.emit('topologyOpening', new events.TopologyOpeningEvent(this.s.id));\n\n    // emit an event for the topology change\n    this.emit(\n      'topologyDescriptionChanged',\n      new events.TopologyDescriptionChangedEvent(\n        this.s.id,\n        new TopologyDescription(TopologyType.Unknown), // initial is always Unknown\n        this.s.description\n      )\n    );\n\n    // connect all known servers, then attempt server selection to connect\n    connectServers(this, Array.from(this.s.description.servers.values()));\n\n    ReadPreference.translate(options);\n    const readPreference = options.readPreference || ReadPreference.primary;\n    const connectHandler = err => {\n      if (err) {\n        this.close();\n\n        if (typeof callback === 'function') {\n          callback(err);\n        } else {\n          this.emit('error', err);\n        }\n\n        return;\n      }\n\n      stateTransition(this, STATE_CONNECTED);\n      this.emit('open', err, this);\n      this.emit('connect', this);\n\n      if (typeof callback === 'function') callback(err, this);\n    };\n\n    // TODO: NODE-2471\n    if (this.s.credentials) {\n      this.command('admin.$cmd', { ping: 1 }, { readPreference }, connectHandler);\n      return;\n    }\n\n    this.selectServer(readPreferenceServerSelector(readPreference), options, connectHandler);\n  }\n\n  /**\n   * Close this topology\n   */\n  close(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    if (typeof options === 'boolean') {\n      options = { force: options };\n    }\n\n    options = options || {};\n    if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n\n    drainWaitQueue(this[kWaitQueue], new MongoError('Topology closed'));\n    drainTimerQueue(this.s.connectionTimers);\n\n    if (this.s.srvPoller) {\n      this.s.srvPoller.stop();\n      if (this.s.handleSrvPolling) {\n        this.s.srvPoller.removeListener('srvRecordDiscovery', this.s.handleSrvPolling);\n        delete this.s.handleSrvPolling;\n      }\n    }\n\n    if (this.s.detectTopologyDescriptionChange) {\n      this.removeListener('topologyDescriptionChanged', this.s.detectTopologyDescriptionChange);\n      delete this.s.detectTopologyDescriptionChange;\n    }\n\n    this.s.sessions.forEach(session => session.endSession());\n    this.s.sessionPool.endAllPooledSessions(() => {\n      eachAsync(\n        Array.from(this.s.servers.values()),\n        (server, cb) => destroyServer(server, this, options, cb),\n        err => {\n          this.s.servers.clear();\n\n          // emit an event for close\n          this.emit('topologyClosed', new events.TopologyClosedEvent(this.s.id));\n\n          stateTransition(this, STATE_CLOSED);\n\n          if (typeof callback === 'function') {\n            callback(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Selects a server according to the selection predicate provided\n   *\n   * @param {function} [selector] An optional selector to select servers by, defaults to a random selection within a latency window\n   * @param {object} [options] Optional settings related to server selection\n   * @param {number} [options.serverSelectionTimeoutMS] How long to block for server selection before throwing an error\n   * @param {function} callback The callback used to indicate success or failure\n   * @return {Server} An instance of a `Server` meeting the criteria of the predicate provided\n   */\n  selectServer(selector, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      if (typeof selector !== 'function') {\n        options = selector;\n\n        let readPreference;\n        if (selector instanceof ReadPreference) {\n          readPreference = selector;\n        } else if (typeof selector === 'string') {\n          readPreference = new ReadPreference(selector);\n        } else {\n          ReadPreference.translate(options);\n          readPreference = options.readPreference || ReadPreference.primary;\n        }\n\n        selector = readPreferenceServerSelector(readPreference);\n      } else {\n        options = {};\n      }\n    }\n\n    options = Object.assign(\n      {},\n      { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS },\n      options\n    );\n\n    const isSharded = this.description.type === TopologyType.Sharded;\n    const session = options.session;\n    const transaction = session && session.transaction;\n\n    if (isSharded && transaction && transaction.server) {\n      callback(undefined, transaction.server);\n      return;\n    }\n\n    // support server selection by options with readPreference\n    let serverSelector = selector;\n    if (typeof selector === 'object') {\n      const readPreference = selector.readPreference\n        ? selector.readPreference\n        : ReadPreference.primary;\n\n      serverSelector = readPreferenceServerSelector(readPreference);\n    }\n\n    const waitQueueMember = {\n      serverSelector,\n      transaction,\n      callback\n    };\n\n    const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n    if (serverSelectionTimeoutMS) {\n      waitQueueMember.timer = setTimeout(() => {\n        waitQueueMember[kCancelled] = true;\n        waitQueueMember.timer = undefined;\n        const timeoutError = new MongoServerSelectionError(\n          `Server selection timed out after ${serverSelectionTimeoutMS} ms`,\n          this.description\n        );\n\n        waitQueueMember.callback(timeoutError);\n      }, serverSelectionTimeoutMS);\n    }\n\n    this[kWaitQueue].push(waitQueueMember);\n    processWaitQueue(this);\n  }\n\n  // Sessions related methods\n\n  /**\n   * @return Whether the topology should initiate selection to determine session support\n   */\n  shouldCheckForSessionSupport() {\n    if (this.description.type === TopologyType.Single) {\n      return !this.description.hasKnownServers;\n    }\n\n    return !this.description.hasDataBearingServers;\n  }\n\n  /**\n   * @return Whether sessions are supported on the current topology\n   */\n  hasSessionSupport() {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n\n  /**\n   * Start a logical session\n   */\n  startSession(options, clientOptions) {\n    const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);\n    session.once('ended', () => {\n      this.s.sessions.delete(session);\n    });\n\n    this.s.sessions.add(session);\n    return session;\n  }\n\n  /**\n   * Send endSessions command(s) with the given session ids\n   *\n   * @param {Array} sessions The sessions to end\n   * @param {function} [callback]\n   */\n  endSessions(sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    }\n\n    this.command(\n      'admin.$cmd',\n      { endSessions: sessions },\n      { readPreference: ReadPreference.primaryPreferred, noResponse: true },\n      () => {\n        // intentionally ignored, per spec\n        if (typeof callback === 'function') callback();\n      }\n    );\n  }\n\n  /**\n   * Update the internal TopologyDescription with a ServerDescription\n   *\n   * @param {object} serverDescription The server to update in the internal list of server descriptions\n   */\n  serverUpdateHandler(serverDescription) {\n    if (!this.s.description.hasServer(serverDescription.address)) {\n      return;\n    }\n\n    // ignore this server update if its from an outdated topologyVersion\n    if (isStaleServerDescription(this.s.description, serverDescription)) {\n      return;\n    }\n\n    // these will be used for monitoring events later\n    const previousTopologyDescription = this.s.description;\n    const previousServerDescription = this.s.description.servers.get(serverDescription.address);\n\n    // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n    // a server it MUST compare it to the current highest seen cluster time\n    // for the deployment. If the new cluster time is higher than the\n    // highest seen cluster time it MUST become the new highest seen cluster\n    // time. Two cluster times are compared using only the BsonTimestamp\n    // value of the clusterTime embedded field.\"\n    const clusterTime = serverDescription.$clusterTime;\n    if (clusterTime) {\n      resolveClusterTime(this, clusterTime);\n    }\n\n    // If we already know all the information contained in this updated description, then\n    // we don't need to emit SDAM events, but still need to update the description, in order\n    // to keep client-tracked attributes like last update time and round trip time up to date\n    const equalDescriptions =\n      previousServerDescription && previousServerDescription.equals(serverDescription);\n\n    // first update the TopologyDescription\n    this.s.description = this.s.description.update(serverDescription);\n    if (this.s.description.compatibilityError) {\n      this.emit('error', new MongoError(this.s.description.compatibilityError));\n      return;\n    }\n\n    // emit monitoring events for this change\n    if (!equalDescriptions) {\n      this.emit(\n        'serverDescriptionChanged',\n        new events.ServerDescriptionChangedEvent(\n          this.s.id,\n          serverDescription.address,\n          previousServerDescription,\n          this.s.description.servers.get(serverDescription.address)\n        )\n      );\n    }\n\n    // update server list from updated descriptions\n    updateServers(this, serverDescription);\n\n    // attempt to resolve any outstanding server selection attempts\n    if (this[kWaitQueue].length > 0) {\n      processWaitQueue(this);\n    }\n\n    if (!equalDescriptions) {\n      this.emit(\n        'topologyDescriptionChanged',\n        new events.TopologyDescriptionChangedEvent(\n          this.s.id,\n          previousTopologyDescription,\n          this.s.description\n        )\n      );\n    }\n  }\n\n  auth(credentials, callback) {\n    if (typeof credentials === 'function') (callback = credentials), (credentials = null);\n    if (typeof callback === 'function') callback(null, true);\n  }\n\n  logout(callback) {\n    if (typeof callback === 'function') callback(null, true);\n  }\n\n  // Basic operation support. Eventually this should be moved into command construction\n  // during the command refactor.\n\n  /**\n   * Insert one or more documents\n   *\n   * @param {String} ns The full qualified namespace for this operation\n   * @param {Array} ops An array of documents to insert\n   * @param {Boolean} [options.ordered=true] Execute in order or out of order\n   * @param {Object} [options.writeConcern] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n   * @param {opResultCallback} callback A callback function\n   */\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({ topology: this, op: 'insert', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more update operations\n   *\n   * @param {string} ns The fully qualified namespace for this operation\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n   * @param {opResultCallback} callback A callback function\n   */\n  update(ns, ops, options, callback) {\n    executeWriteOperation({ topology: this, op: 'update', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more remove operations\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n   * @param {opResultCallback} callback A callback function\n   */\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({ topology: this, op: 'remove', ns, ops }, options, callback);\n  }\n\n  /**\n   * Execute a command\n   *\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Connection} [options.connection] Specify connection object to execute command against\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      (callback = options), (options = {}), (options = options || {});\n    }\n\n    ReadPreference.translate(options);\n    const readPreference = options.readPreference || ReadPreference.primary;\n\n    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const notAlreadyRetrying = !options.retrying;\n      const retryWrites = !!options.retryWrites;\n      const hasSession = !!options.session;\n      const supportsRetryableWrites = server.supportsRetryableWrites;\n      const notInTransaction = !hasSession || !options.session.inTransaction();\n      const willRetryWrite =\n        notAlreadyRetrying &&\n        retryWrites &&\n        hasSession &&\n        supportsRetryableWrites &&\n        notInTransaction &&\n        isWriteCommand(cmd);\n\n      const cb = (err, result) => {\n        if (!err) return callback(null, result);\n        if (!shouldRetryOperation(err)) {\n          return callback(err);\n        }\n\n        if (willRetryWrite) {\n          const newOptions = Object.assign({}, options, { retrying: true });\n          return this.command(ns, cmd, newOptions, callback);\n        }\n\n        return callback(err);\n      };\n\n      // increment and assign txnNumber\n      if (willRetryWrite) {\n        options.session.incrementTransactionNumber();\n        options.willRetryWrite = willRetryWrite;\n      }\n\n      server.command(ns, cmd, options, cb);\n    });\n  }\n\n  /**\n   * Create a new cursor\n   *\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n   * @param {object} [options] Options for the cursor\n   * @param {object} [options.batchSize=0] Batchsize for the operation\n   * @param {array} [options.documents=[]] Initial documents list for cursor\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {object} [options.topology] The internal topology of the created cursor\n   * @returns {Cursor}\n   */\n  cursor(ns, cmd, options) {\n    options = options || {};\n    const topology = options.topology || this;\n    const CursorClass = options.cursorFactory || this.s.Cursor;\n    ReadPreference.translate(options);\n\n    return new CursorClass(topology, ns, cmd, options);\n  }\n\n  get clientMetadata() {\n    return this.s.options.metadata;\n  }\n\n  isConnected() {\n    return this.s.state === STATE_CONNECTED;\n  }\n\n  isDestroyed() {\n    return this.s.state === STATE_CLOSED;\n  }\n\n  /**\n   * @deprecated This function is deprecated and will be removed in the next major version.\n   */\n  unref() {\n    emitWarning('`unref` is a noop and will be removed in the next major version');\n  }\n\n  // NOTE: There are many places in code where we explicitly check the last isMaster\n  //       to do feature support detection. This should be done any other way, but for\n  //       now we will just return the first isMaster seen, which should suffice.\n  lastIsMaster() {\n    const serverDescriptions = Array.from(this.description.servers.values());\n    if (serverDescriptions.length === 0) return {};\n\n    const sd = serverDescriptions.filter(sd => sd.type !== ServerType.Unknown)[0];\n    const result = sd || { maxWireVersion: this.description.commonWireVersion };\n    return result;\n  }\n\n  get logicalSessionTimeoutMinutes() {\n    return this.description.logicalSessionTimeoutMinutes;\n  }\n\n  get bson() {\n    return this.s.bson;\n  }\n}\n\nObject.defineProperty(Topology.prototype, 'clusterTime', {\n  enumerable: true,\n  get: function() {\n    return this.s.clusterTime;\n  },\n  set: function(clusterTime) {\n    this.s.clusterTime = clusterTime;\n  }\n});\n\n// legacy aliases\nTopology.prototype.destroy = deprecate(\n  Topology.prototype.close,\n  'destroy() is deprecated, please use close() instead'\n);\n\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\n\nfunction isStaleServerDescription(topologyDescription, incomingServerDescription) {\n  const currentServerDescription = topologyDescription.servers.get(\n    incomingServerDescription.address\n  );\n  const currentTopologyVersion = currentServerDescription.topologyVersion;\n  return (\n    compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0\n  );\n}\n\n/**\n * Destroys a server, and removes all event listeners from the instance\n *\n * @param {Server} server\n */\nfunction destroyServer(server, topology, options, callback) {\n  options = options || {};\n  LOCAL_SERVER_EVENTS.forEach(event => server.removeAllListeners(event));\n\n  server.destroy(options, () => {\n    topology.emit(\n      'serverClosed',\n      new events.ServerClosedEvent(topology.s.id, server.description.address)\n    );\n\n    SERVER_RELAY_EVENTS.forEach(event => server.removeAllListeners(event));\n    if (typeof callback === 'function') {\n      callback();\n    }\n  });\n}\n\n/**\n * Parses a basic seedlist in string form\n *\n * @param {string} seedlist The seedlist to parse\n */\nfunction parseStringSeedlist(seedlist) {\n  return seedlist.split(',').map(seed => ({\n    host: seed.split(':')[0],\n    port: seed.split(':')[1] || 27017\n  }));\n}\n\nfunction topologyTypeFromSeedlist(seedlist, options) {\n  if (options.directConnection) {\n    return TopologyType.Single;\n  }\n\n  const replicaSet = options.replicaSet || options.setName || options.rs_name;\n  if (replicaSet == null) {\n    return TopologyType.Unknown;\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction randomSelection(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}\n\nfunction createAndConnectServer(topology, serverDescription, connectDelay) {\n  topology.emit(\n    'serverOpening',\n    new events.ServerOpeningEvent(topology.s.id, serverDescription.address)\n  );\n\n  const server = new Server(serverDescription, topology.s.options, topology);\n  relayEvents(server, topology, SERVER_RELAY_EVENTS);\n\n  server.on('descriptionReceived', topology.serverUpdateHandler.bind(topology));\n\n  if (connectDelay) {\n    const connectTimer = setTimeout(() => {\n      clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);\n      server.connect();\n    }, connectDelay);\n\n    topology.s.connectionTimers.add(connectTimer);\n    return server;\n  }\n\n  server.connect();\n  return server;\n}\n\n/**\n * Create `Server` instances for all initially known servers, connect them, and assign\n * them to the passed in `Topology`.\n *\n * @param {Topology} topology The topology responsible for the servers\n * @param {ServerDescription[]} serverDescriptions A list of server descriptions to connect\n */\nfunction connectServers(topology, serverDescriptions) {\n  topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {\n    const server = createAndConnectServer(topology, serverDescription);\n    servers.set(serverDescription.address, server);\n    return servers;\n  }, new Map());\n}\n\nfunction updateServers(topology, incomingServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    const server = topology.s.servers.get(incomingServerDescription.address);\n    server.s.description = incomingServerDescription;\n  }\n\n  // add new servers for all descriptions we currently don't know about locally\n  for (const serverDescription of topology.description.servers.values()) {\n    if (!topology.s.servers.has(serverDescription.address)) {\n      const server = createAndConnectServer(topology, serverDescription);\n      topology.s.servers.set(serverDescription.address, server);\n    }\n  }\n\n  // for all servers no longer known, remove their descriptions and destroy their instances\n  for (const entry of topology.s.servers) {\n    const serverAddress = entry[0];\n    if (topology.description.hasServer(serverAddress)) {\n      continue;\n    }\n\n    const server = topology.s.servers.get(serverAddress);\n    topology.s.servers.delete(serverAddress);\n\n    // prepare server for garbage collection\n    destroyServer(server, topology);\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const topology = args.topology;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n\n  topology.selectServer(writableServerSelector(), options, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    const notAlreadyRetrying = !args.retrying;\n    const retryWrites = !!options.retryWrites;\n    const hasSession = !!options.session;\n    const supportsRetryableWrites = server.supportsRetryableWrites;\n    const notInTransaction = !hasSession || !options.session.inTransaction();\n    const notExplaining = options.explain === undefined;\n    const willRetryWrite =\n      notAlreadyRetrying &&\n      retryWrites &&\n      hasSession &&\n      supportsRetryableWrites &&\n      notInTransaction &&\n      notExplaining;\n\n    const handler = (err, result) => {\n      if (!err) return callback(null, result);\n      if (!shouldRetryOperation(err)) {\n        err = getMMAPError(err);\n        return callback(err);\n      }\n\n      if (willRetryWrite) {\n        const newArgs = Object.assign({}, args, { retrying: true });\n        return executeWriteOperation(newArgs, options, callback);\n      }\n\n      return callback(err);\n    };\n\n    if (callback.operationId) {\n      handler.operationId = callback.operationId;\n    }\n\n    // increment and assign txnNumber\n    if (willRetryWrite) {\n      options.session.incrementTransactionNumber();\n      options.willRetryWrite = willRetryWrite;\n    }\n\n    // execute the write operation\n    server[op](ns, ops, options, handler);\n  });\n}\n\nfunction shouldRetryOperation(err) {\n  return err instanceof MongoError && err.hasErrorLabel('RetryableWriteError');\n}\n\nfunction srvPollingHandler(topology) {\n  return function handleSrvPolling(ev) {\n    const previousTopologyDescription = topology.s.description;\n    topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);\n    if (topology.s.description === previousTopologyDescription) {\n      // Nothing changed, so return\n      return;\n    }\n\n    updateServers(topology);\n\n    topology.emit(\n      'topologyDescriptionChanged',\n      new events.TopologyDescriptionChangedEvent(\n        topology.s.id,\n        previousTopologyDescription,\n        topology.s.description\n      )\n    );\n  };\n}\n\nfunction drainWaitQueue(queue, err) {\n  while (queue.length) {\n    const waitQueueMember = queue.shift();\n    clearTimeout(waitQueueMember.timer);\n    if (!waitQueueMember[kCancelled]) {\n      waitQueueMember.callback(err);\n    }\n  }\n}\n\nfunction processWaitQueue(topology) {\n  if (topology.s.state === STATE_CLOSED) {\n    drainWaitQueue(topology[kWaitQueue], new MongoError('Topology is closed, please connect'));\n    return;\n  }\n\n  const serverDescriptions = Array.from(topology.description.servers.values());\n  const membersToProcess = topology[kWaitQueue].length;\n  for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {\n    const waitQueueMember = topology[kWaitQueue].shift();\n    if (waitQueueMember[kCancelled]) {\n      continue;\n    }\n\n    let selectedDescriptions;\n    try {\n      const serverSelector = waitQueueMember.serverSelector;\n      selectedDescriptions = serverSelector\n        ? serverSelector(topology.description, serverDescriptions)\n        : serverDescriptions;\n    } catch (e) {\n      clearTimeout(waitQueueMember.timer);\n      waitQueueMember.callback(e);\n      continue;\n    }\n\n    if (selectedDescriptions.length === 0) {\n      topology[kWaitQueue].push(waitQueueMember);\n      continue;\n    }\n\n    const selectedServerDescription = randomSelection(selectedDescriptions);\n    const selectedServer = topology.s.servers.get(selectedServerDescription.address);\n    const transaction = waitQueueMember.transaction;\n    const isSharded = topology.description.type === TopologyType.Sharded;\n    if (isSharded && transaction && transaction.isActive) {\n      transaction.pinServer(selectedServer);\n    }\n\n    clearTimeout(waitQueueMember.timer);\n    waitQueueMember.callback(undefined, selectedServer);\n  }\n\n  if (topology[kWaitQueue].length > 0) {\n    // ensure all server monitors attempt monitoring soon\n    topology.s.servers.forEach(server => process.nextTick(() => server.requestCheck()));\n  }\n}\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event Topology#serverOpening\n * @type {ServerOpeningEvent}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event Topology#serverClosed\n * @type {ServerClosedEvent}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event Topology#serverDescriptionChanged\n * @type {ServerDescriptionChangedEvent}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event Topology#topologyOpening\n * @type {TopologyOpeningEvent}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event Topology#topologyClosed\n * @type {TopologyClosedEvent}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event Topology#topologyDescriptionChanged\n * @type {TopologyDescriptionChangedEvent}\n */\n\n/**\n * A topology serverHeartbeatStarted SDAM event\n *\n * @event Topology#serverHeartbeatStarted\n * @type {ServerHeartbeatStartedEvent}\n */\n\n/**\n * A topology serverHeartbeatFailed SDAM event\n *\n * @event Topology#serverHeartbeatFailed\n * @type {ServerHearbeatFailedEvent}\n */\n\n/**\n * A topology serverHeartbeatSucceeded SDAM change event\n *\n * @event Topology#serverHeartbeatSucceeded\n * @type {ServerHeartbeatSucceededEvent}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event Topology#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event Topology#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event Topology#commandFailed\n * @type {object}\n */\n\nmodule.exports = {\n  Topology\n};\n"],"mappings":"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,WAAW,CAAC0H,SAAS,CAACF,cAAc,CAAC;IACvC;IAEAN,YAAY,CAAC/G,eAAe,CAACC,KAAK,CAAC;IACnCD,eAAe,CAACnC,QAAQ,CAACiC,SAAS,EAAEuH,cAAc,CAAC;EACrD;EAEA,IAAI5E,QAAQ,CAAC7J,UAAU,CAAC,CAACsJ,MAAM,GAAG,CAAC,EAAE;IACnC;IACAO,QAAQ,CAAChI,CAAC,CAACuB,OAAO,CAACpC,OAAO,CAAC0F,MAAM,IAAIkI,OAAO,CAACC,QAAQ,CAAC,MAAMnI,MAAM,CAACoI,YAAY,EAAE,CAAC,CAAC;EACrF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG;EACf/O;AACF,CAAC"},"metadata":{},"sourceType":"script"}