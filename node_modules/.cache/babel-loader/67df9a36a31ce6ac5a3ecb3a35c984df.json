{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst crypto = require('crypto');\nconst debugOptions = require('./utils').debugOptions;\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\nconst decompress = require('../wireprotocol/compression').decompress;\nconst Response = require('./commands').Response;\nconst BinMsg = require('./msg').BinMsg;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst MongoError = require('../error').MongoError;\nconst Logger = require('./logger');\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst Buffer = require('safe-buffer').Buffer;\nconst Query = require('./commands').Query;\nconst CommandResult = require('./command_result');\nlet _id = 0;\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'checkServerIdentity'];\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {boolean} [options.bsonRegExp] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n    options = options || {};\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n\n    // These values are inspected directly in tests, but maybe not necessary to keep around\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n    this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    }\n\n    // Debug information\n    if (this.logger.isDebug()) {\n      this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);\n    }\n\n    // Response options\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n      bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false\n    };\n\n    // Flushing\n    this.flushing = false;\n    this.queue = [];\n\n    // Internal state\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false;\n\n    // Create hash method\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex');\n\n    // All operations in flight on the connection\n    this.workItems = [];\n\n    // setup socket\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n    connectionAccounting = true;\n    connections = {};\n  }\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n  static connections() {\n    return connections;\n  }\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   * @deprecated This function is deprecated and will be removed in the next major version.\n   */\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n    this.socket.unref();\n  }\n\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n\n  /**\n   * Destroy connection\n   * @method\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = Object.assign({\n      force: false\n    }, options);\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [ ${buffer.length} ] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++) this.logger.debug(`writing buffer [ ${buffer[i].length} ] to ${this.address}`);\n      }\n    }\n\n    // Double check that the connection is not destroyed\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      }\n\n      // Iterate over all buffers and write them in order to the socket\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n      return true;\n    }\n\n    // Connection is destroyed return write failed\n    return false;\n  }\n\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n  toString() {\n    return '' + this.id;\n  }\n\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      host: this.host,\n      port: this.port\n    };\n  }\n\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n\n  /**\n   * @ignore\n   */\n  command(ns, command, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const conn = this;\n    const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    const bson = conn.options.bson;\n    const query = new Query(bson, ns, command, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    });\n    const noop = () => {};\n    function _callback(err, result) {\n      callback(err, result);\n      callback = noop;\n    }\n    function errorHandler(err) {\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n      if (err == null) {\n        err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n      }\n\n      // ignore all future errors\n      conn.on('error', noop);\n      _callback(err);\n    }\n    function messageHandler(msg) {\n      if (msg.responseTo !== query.requestId) {\n        return;\n      }\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n      msg.parse({\n        promoteValues: true\n      });\n      const response = msg.documents[0];\n      if (response.ok === 0 || response.$err || response.errmsg || response.code) {\n        _callback(new MongoError(response));\n        return;\n      }\n      _callback(undefined, new CommandResult(response, this, msg));\n    }\n    conn.setSocketTimeout(socketTimeout);\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n    conn.on('message', messageHandler);\n    conn.write(query.toBin());\n  }\n}\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n}\n\n//\n// Connection handlers\nfunction errorHandler(conn) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(conn.id);\n    // Debug information\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);\n    }\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\nfunction timeoutHandler(conn) {\n  return function () {\n    if (connectionAccounting) deleteConnection(conn.id);\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n    conn.timedOut = true;\n    conn.emit('timeout', new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {\n      beforeHandshake: conn.ismaster == null\n    }), conn);\n  };\n}\nfunction closeHandler(conn) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n    if (!hadError) {\n      conn.emit('close', new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);\n    }\n  };\n}\n\n// Handle a message once it is received\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);\n    return;\n  }\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit('error', new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);\n  });\n}\nfunction dataHandler(conn) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          conn.bytesRead = conn.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          const emitBuffer = conn.buffer;\n          // Reset state of buffer\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            conn.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, conn.stubBuffer.length);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;\n            // If we have a negative sizeOfMessage emit error and return\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {\n              conn.buffer = Buffer.alloc(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(conn.buffer, 0);\n              // Update bytes read\n              conn.bytesRead = data.length;\n              // Update sizeOfMessage\n              conn.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {\n              const emitBuffer = data;\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n\n              // Clear out the state of the parser\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length);\n            // Copy the data to the stub buffer\n            data.copy(conn.stubBuffer, 0);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\nmodule.exports = Connection;","map":{"version":3,"names":["EventEmitter","require","crypto","debugOptions","parseHeader","decompress","Response","BinMsg","MongoNetworkError","MongoNetworkTimeoutError","MongoError","Logger","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","Buffer","Query","CommandResult","_id","DEFAULT_MAX_BSON_MESSAGE_SIZE","DEBUG_FIELDS","connectionAccountingSpy","undefined","connectionAccounting","connections","Connection","constructor","socket","options","bson","TypeError","id","logger","tag","maxBsonMessageSize","port","host","socketTimeout","keepAlive","keepAliveInitialDelay","connectionTimeout","Math","round","isDebug","debug","JSON","stringify","responseOptions","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","flushing","queue","writeStream","destroyed","timedOut","hash","createHash","update","address","hashedName","digest","workItems","once","errorHandler","timeoutHandler","closeHandler","on","dataHandler","addConnection","setSocketTimeout","value","setTimeout","resetSocketTimeout","enableConnectionAccounting","spy","disableConnectionAccounting","unref","flush","err","length","workItem","shift","cb","destroy","callback","Object","assign","force","deleteConnection","end","write","buffer","Array","isArray","i","toString","toJSON","isConnected","writable","command","ns","conn","query","numberToSkip","numberToReturn","noop","_callback","result","CONNECTION_ERROR_EVENTS","forEach","eventName","removeListener","messageHandler","msg","responseTo","requestId","parse","response","documents","ok","$err","errmsg","code","toBin","connection","emit","beforeHandshake","ismaster","hadError","processMessage","message","msgHeader","opCode","ResponseConstructor","slice","fromCompressed","index","readInt32LE","compressorID","decompressedMsgBody","data","bytesRead","sizeOfMessage","remainingBytesToRead","copy","alloc","emitBuffer","stubBuffer","newData","newStubBuffer","errorObject","trace","bin","parseState","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/connection/connection.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst crypto = require('crypto');\nconst debugOptions = require('./utils').debugOptions;\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\nconst decompress = require('../wireprotocol/compression').decompress;\nconst Response = require('./commands').Response;\nconst BinMsg = require('./msg').BinMsg;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst MongoError = require('../error').MongoError;\nconst Logger = require('./logger');\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst Buffer = require('safe-buffer').Buffer;\nconst Query = require('./commands').Query;\nconst CommandResult = require('./command_result');\n\nlet _id = 0;\n\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = [\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'checkServerIdentity'\n];\n\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {boolean} [options.bsonRegExp] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n\n    options = options || {};\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n\n    // These values are inspected directly in tests, but maybe not necessary to keep around\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay =\n      typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n    this.connectionTimeout =\n      typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    }\n\n    // Debug information\n    if (this.logger.isDebug()) {\n      this.logger.debug(\n        `creating connection ${this.id} with options [${JSON.stringify(\n          debugOptions(DEBUG_FIELDS, options)\n        )}]`\n      );\n    }\n\n    // Response options\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n      bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false\n    };\n\n    // Flushing\n    this.flushing = false;\n    this.queue = [];\n\n    // Internal state\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false;\n\n    // Create hash method\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex');\n\n    // All operations in flight on the connection\n    this.workItems = [];\n\n    // setup socket\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   * @deprecated This function is deprecated and will be removed in the next major version.\n   */\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n\n  /**\n   * Destroy connection\n   * @method\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [ ${buffer.length} ] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++)\n          this.logger.debug(`writing buffer [ ${buffer[i].length} ] to ${this.address}`);\n      }\n    }\n\n    // Double check that the connection is not destroyed\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      }\n\n      // Iterate over all buffers and write them in order to the socket\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    }\n\n    // Connection is destroyed return write failed\n    return false;\n  }\n\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n  toString() {\n    return '' + this.id;\n  }\n\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n  toJSON() {\n    return { id: this.id, host: this.host, port: this.port };\n  }\n\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n\n  /**\n   * @ignore\n   */\n  command(ns, command, options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    const conn = this;\n    const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    const bson = conn.options.bson;\n    const query = new Query(bson, ns, command, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    });\n\n    const noop = () => {};\n    function _callback(err, result) {\n      callback(err, result);\n      callback = noop;\n    }\n\n    function errorHandler(err) {\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      if (err == null) {\n        err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n      }\n\n      // ignore all future errors\n      conn.on('error', noop);\n      _callback(err);\n    }\n\n    function messageHandler(msg) {\n      if (msg.responseTo !== query.requestId) {\n        return;\n      }\n\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      msg.parse({ promoteValues: true });\n\n      const response = msg.documents[0];\n      if (response.ok === 0 || response.$err || response.errmsg || response.code) {\n        _callback(new MongoError(response));\n        return;\n      }\n\n      _callback(undefined, new CommandResult(response, this, msg));\n    }\n\n    conn.setSocketTimeout(socketTimeout);\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n    conn.on('message', messageHandler);\n    conn.write(query.toBin());\n  }\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n}\n\n//\n// Connection handlers\nfunction errorHandler(conn) {\n  return function(err) {\n    if (connectionAccounting) deleteConnection(conn.id);\n    // Debug information\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\n        `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`\n      );\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function() {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit(\n      'timeout',\n      new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {\n        beforeHandshake: conn.ismaster == null\n      }),\n      conn\n    );\n  };\n}\n\nfunction closeHandler(conn) {\n  return function(hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit(\n        'close',\n        new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),\n        conn\n      );\n    }\n  };\n}\n\n// Handle a message once it is received\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        message.slice(MESSAGE_HEADER_SIZE),\n        conn.responseOptions\n      ),\n      conn\n    );\n\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit(\n        'error',\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        decompressedMsgBody,\n        conn.responseOptions\n      ),\n      conn\n    );\n  });\n}\n\nfunction dataHandler(conn) {\n  return function(data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          conn.bytesRead = conn.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          const emitBuffer = conn.buffer;\n          // Reset state of buffer\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            conn.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, conn.stubBuffer.length);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n            // If we have a negative sizeOfMessage emit error and return\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage > data.length\n            ) {\n              conn.buffer = Buffer.alloc(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(conn.buffer, 0);\n              // Update bytes read\n              conn.bytesRead = data.length;\n              // Update sizeOfMessage\n              conn.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage === data.length\n            ) {\n              const emitBuffer = data;\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n\n              // Clear out the state of the parser\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length);\n            // Copy the data to the stub buffer\n            data.copy(conn.stubBuffer, 0);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}