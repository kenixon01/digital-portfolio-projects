{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n  f = require('util').format,\n  EventEmitter = require('events').EventEmitter,\n  ReadPreference = require('./read_preference'),\n  Logger = require('../connection/logger'),\n  debugOptions = require('../connection/utils').debugOptions,\n  retrieveBSON = require('../connection/utils').retrieveBSON,\n  Pool = require('../connection/pool'),\n  MongoError = require('../error').MongoError,\n  MongoNetworkError = require('../error').MongoNetworkError,\n  wireProtocol = require('../wireprotocol'),\n  CoreCursor = require('../cursor').CoreCursor,\n  sdam = require('./shared'),\n  createCompressionInfo = require('./shared').createCompressionInfo,\n  resolveClusterTime = require('./shared').resolveClusterTime,\n  SessionMixins = require('./shared').SessionMixins,\n  extractCommand = require('../../command_utils').extractCommand,\n  relayEvents = require('../utils').relayEvents;\nconst collationNotSupported = require('../utils').collationNotSupported;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\n\n// Used for filtering out fields for loggin\nvar debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'servername'];\n\n// Server instance id\nvar id = 0;\nvar serverAccounting = false;\nvar servers = {};\nvar BSON = retrieveBSON();\nfunction topologyId(server) {\n  return server.s.parent == null ? server.id : server.s.parent.id;\n}\n\n/**\n * Creates a new Server instance\n * @class\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)\n * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.bsonRegExp=false] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {Server} A cursor instance\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#reconnectFailed\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n * @fires Server#topologyOpening\n * @fires Server#topologyClosed\n * @fires Server#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\nvar Server = function (options) {\n  options = options || {};\n\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Server instance id\n  this.id = id++;\n\n  // Internal state\n  this.s = {\n    // Options\n    options: Object.assign({\n      metadata: makeClientMetadata(options)\n    }, options),\n    // Logger\n    logger: Logger('Server', options),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Pool\n    pool: null,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Monitor thread (keeps the connection alive)\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,\n    // Is the server in a topology\n    inTopology: !!options.parent,\n    // Monitoring timeout\n    monitoringInterval: typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,\n    compression: {\n      compressors: createCompressionInfo(options)\n    },\n    // Optional parent topology\n    parent: options.parent\n  };\n\n  // If this is a single deployment we need to track the clusterTime here\n  if (!this.s.parent) {\n    this.s.clusterTime = null;\n  }\n\n  // Curent ismaster\n  this.ismaster = null;\n  // Current ping time\n  this.lastIsMasterMS = -1;\n  // The monitoringProcessId\n  this.monitoringProcessId = null;\n  // Initial connection\n  this.initialConnect = true;\n  // Default type\n  this._type = 'server';\n\n  // Max Stalleness values\n  // last time we updated the ismaster state\n  this.lastUpdateTime = 0;\n  // Last write time\n  this.lastWriteDate = 0;\n  // Stalleness\n  this.staleness = 0;\n};\ninherits(Server, EventEmitter);\nObject.assign(Server.prototype, SessionMixins);\nObject.defineProperty(Server.prototype, 'type', {\n  enumerable: true,\n  get: function () {\n    return this._type;\n  }\n});\nObject.defineProperty(Server.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\nObject.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function () {\n    if (!this.ismaster) return null;\n    return this.ismaster.logicalSessionTimeoutMinutes || null;\n  }\n});\nObject.defineProperty(Server.prototype, 'clientMetadata', {\n  enumerable: true,\n  get: function () {\n    return this.s.options.metadata;\n  }\n});\n\n// In single server deployments we track the clusterTime directly on the topology, however\n// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the\n// tracking objects so we can ensure we are gossiping the maximum time received from the\n// server.\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  enumerable: true,\n  set: function (clusterTime) {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    resolveClusterTime(settings, clusterTime);\n  },\n  get: function () {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    return settings.clusterTime || null;\n  }\n});\nServer.enableServerAccounting = function () {\n  serverAccounting = true;\n  servers = {};\n};\nServer.disableServerAccounting = function () {\n  serverAccounting = false;\n};\nServer.servers = function () {\n  return servers;\n};\nObject.defineProperty(Server.prototype, 'name', {\n  enumerable: true,\n  get: function () {\n    return this.s.options.host + ':' + this.s.options.port;\n  }\n});\nfunction disconnectHandler(self, type, ns, cmd, options, callback) {\n  // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n  if (!self.s.pool.isConnected() && self.s.options.reconnect && self.s.disconnectHandler != null && !options.monitoring) {\n    self.s.disconnectHandler.add(type, ns, cmd, options, callback);\n    return true;\n  }\n\n  // If we have no connection error\n  if (!self.s.pool.isConnected()) {\n    callback(new MongoError(f('no connection available to server %s', self.name)));\n    return true;\n  }\n}\nfunction monitoringProcess(self) {\n  return function () {\n    // Pool was destroyed do not continue process\n    if (self.s.pool.isDestroyed()) return;\n    // Emit monitoring Process event\n    self.emit('monitoring', self);\n    // Perform ismaster call\n    // Get start time\n    var start = new Date().getTime();\n\n    // Execute the ismaster query\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      socketTimeout: typeof self.s.options.connectionTimeout !== 'number' ? 2000 : self.s.options.connectionTimeout,\n      monitoring: true\n    }, (err, result) => {\n      // Set initial lastIsMasterMS\n      self.lastIsMasterMS = new Date().getTime() - start;\n      if (self.s.pool.isDestroyed()) return;\n      // Update the ismaster view if we have a result\n      if (result) {\n        self.ismaster = result.result;\n      }\n      // Re-schedule the monitoring process\n      self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n    });\n  };\n}\nvar eventHandler = function (self, event) {\n  return function (err, conn) {\n    // Log information of received information if in info mode\n    if (self.s.logger.isInfo()) {\n      var object = err instanceof MongoError ? JSON.stringify(err) : {};\n      self.s.logger.info(f('server %s fired event %s out with message %s', self.name, event, object));\n    }\n\n    // Handle connect event\n    if (event === 'connect') {\n      self.initialConnect = false;\n      self.ismaster = conn.ismaster;\n      self.lastIsMasterMS = conn.lastIsMasterMS;\n      if (conn.agreedCompressor) {\n        self.s.pool.options.agreedCompressor = conn.agreedCompressor;\n      }\n      if (conn.zlibCompressionLevel) {\n        self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\n      }\n      if (conn.ismaster.$clusterTime) {\n        const $clusterTime = conn.ismaster.$clusterTime;\n        self.clusterTime = $clusterTime;\n      }\n\n      // It's a proxy change the type so\n      // the wireprotocol will send $readPreference\n      if (self.ismaster.msg === 'isdbgrid') {\n        self._type = 'mongos';\n      }\n\n      // Have we defined self monitoring\n      if (self.s.monitoring) {\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n      }\n\n      // Emit server description changed if something listening\n      sdam.emitServerDescriptionChanged(self, {\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: sdam.getTopologyType(self)\n      });\n      if (!self.s.inTopology) {\n        // Emit topology description changed if something listening\n        sdam.emitTopologyDescriptionChanged(self, {\n          topologyType: 'Single',\n          servers: [{\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: sdam.getTopologyType(self)\n          }]\n        });\n      }\n\n      // Log the ismaster if available\n      if (self.s.logger.isInfo()) {\n        self.s.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster)));\n      }\n\n      // Emit connect\n      self.emit('connect', self);\n    } else if (event === 'error' || event === 'parseError' || event === 'close' || event === 'timeout' || event === 'reconnect' || event === 'attemptReconnect' || event === 'reconnectFailed') {\n      // Remove server instance from accounting\n      if (serverAccounting && ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1) {\n        // Emit toplogy opening event if not in topology\n        if (!self.s.inTopology) {\n          self.emit('topologyOpening', {\n            topologyId: self.id\n          });\n        }\n        delete servers[self.id];\n      }\n      if (event === 'close') {\n        // Closing emits a server description changed event going to unknown.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        });\n      }\n\n      // Reconnect failed return error\n      if (event === 'reconnectFailed') {\n        self.emit('reconnectFailed', err);\n        // Emit error if any listeners\n        if (self.listeners('error').length > 0) {\n          self.emit('error', err);\n        }\n        // Terminate\n        return;\n      }\n\n      // On first connect fail\n      if (['disconnected', 'connecting'].indexOf(self.s.pool.state) !== -1 && self.initialConnect && ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1) {\n        self.initialConnect = false;\n        return self.emit('error', new MongoNetworkError(f('failed to connect to server [%s] on first connect [%s]', self.name, err)));\n      }\n\n      // Reconnect event, emit the server\n      if (event === 'reconnect') {\n        // Reconnecting emits a server description changed event going from unknown to the\n        // current server type.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: sdam.getTopologyType(self)\n        });\n        return self.emit(event, self);\n      }\n\n      // Emit the event\n      self.emit(event, err);\n    }\n  };\n};\n\n/**\n * Initiate server connect\n */\nServer.prototype.connect = function (options) {\n  var self = this;\n  options = options || {};\n\n  // Set the connections\n  if (serverAccounting) servers[this.id] = this;\n\n  // Do not allow connect to be called on anything that's not disconnected\n  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {\n    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));\n  }\n\n  // Create a pool\n  self.s.pool = new Pool(this, Object.assign(self.s.options, options, {\n    bson: this.s.bson\n  }));\n\n  // Set up listeners\n  self.s.pool.on('close', eventHandler(self, 'close'));\n  self.s.pool.on('error', eventHandler(self, 'error'));\n  self.s.pool.on('timeout', eventHandler(self, 'timeout'));\n  self.s.pool.on('parseError', eventHandler(self, 'parseError'));\n  self.s.pool.on('connect', eventHandler(self, 'connect'));\n  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));\n  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));\n\n  // Set up listeners for command monitoring\n  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n  // Emit toplogy opening event if not in topology\n  if (!self.s.inTopology) {\n    this.emit('topologyOpening', {\n      topologyId: topologyId(self)\n    });\n  }\n\n  // Emit opening server event\n  self.emit('serverOpening', {\n    topologyId: topologyId(self),\n    address: self.name\n  });\n  self.s.pool.connect();\n};\n\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\nServer.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Get the server description\n * @method\n * @return {object}\n */\nServer.prototype.getDescription = function () {\n  var ismaster = this.ismaster || {};\n  var description = {\n    type: sdam.getTopologyType(this),\n    address: this.name\n  };\n\n  // Add fields if available\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\n  if (ismaster.passives) description.passives = ismaster.passives;\n  if (ismaster.setName) description.setName = ismaster.setName;\n  return description;\n};\n\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\nServer.prototype.lastIsMaster = function () {\n  return this.ismaster;\n};\n\n/**\n * Unref all connections belong to this server\n * @method\n */\nServer.prototype.unref = function () {\n  this.s.pool.unref();\n};\n\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\nServer.prototype.isConnected = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isConnected();\n};\n\n/**\n * Figure out if the server instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\nServer.prototype.isDestroyed = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isDestroyed();\n};\nfunction basicWriteValidations(self) {\n  if (!self.s.pool) return new MongoError('server instance is not connected');\n  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');\n}\nfunction basicReadValidations(self, options) {\n  basicWriteValidations(self, options);\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    throw new Error('readPreference must be an instance of ReadPreference');\n  }\n}\n\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.command = function (ns, cmd, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n  var result = basicReadValidations(self, options);\n  if (result) return callback(result);\n\n  // Clone the options\n  options = Object.assign({}, options, {\n    wireProtocolCommand: false\n  });\n\n  // Debug log\n  if (self.s.logger.isDebug()) {\n    const extractedCommand = extractCommand(cmd);\n    self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({\n      ns: ns,\n      cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,\n      options: debugOptions(debugFields, options)\n    }), self.name));\n  }\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, cmd)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n  wireProtocol.command(self, ns, cmd, options, callback);\n};\n\n/**\n * Execute a query against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command document for the query\n * @param {object} options Optional settings\n * @param {function} callback\n */\nServer.prototype.query = function (ns, cmd, cursorState, options, callback) {\n  wireProtocol.query(this, ns, cmd, cursorState, options, callback);\n};\n\n/**\n * Execute a `getMore` against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {object} options Optional settings\n * @param {function} callback\n */\nServer.prototype.getMore = function (ns, cursorState, batchSize, options, callback) {\n  wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);\n};\n\n/**\n * Execute a `killCursors` command against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {function} callback\n */\nServer.prototype.killCursors = function (ns, cursorState, callback) {\n  wireProtocol.killCursors(this, ns, cursorState, callback);\n};\n\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.insert = function (ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return;\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n\n  // Execute write\n  return wireProtocol.insert(self, ns, ops, options, callback);\n};\n\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.update = function (ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n  // Execute write\n  return wireProtocol.update(self, ns, ops, options, callback);\n};\n\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.remove = function (ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n  // Execute write\n  return wireProtocol.remove(self, ns, ops, options, callback);\n};\n\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\nServer.prototype.cursor = function (ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this;\n\n  // Set up final cursor type\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\n\n  // Return the cursor\n  return new FinalCursor(topology, ns, cmd, options);\n};\n\n/**\n * Compare two server instances\n * @method\n * @param {Server} server Server to compare equality against\n * @return {boolean}\n */\nServer.prototype.equals = function (server) {\n  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();\n  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();\n  return false;\n};\n\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\nServer.prototype.connections = function () {\n  return this.s.pool.allConnections();\n};\n\n/**\n * Selects a server\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Unused\n * @param {ClientSession} [options.session] Unused\n * @return {Server}\n */\nServer.prototype.selectServer = function (selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined') callback = selector, selector = undefined, options = {};\n  if (typeof options === 'function') callback = options, options = selector, selector = undefined;\n  callback(null, this);\n};\nvar listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];\n\n/**\n * Destroy the server connection\n * @method\n * @param {boolean} [options.emitClose=false] Emit close event on destroy\n * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy\n * @param {boolean} [options.force=false] Force destroy the pool\n */\nServer.prototype.destroy = function (options, callback) {\n  if (this._destroyed) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var self = this;\n\n  // Set the connections\n  if (serverAccounting) delete servers[this.id];\n\n  // Destroy the monitoring process if any\n  if (this.monitoringProcessId) {\n    clearTimeout(this.monitoringProcessId);\n  }\n\n  // No pool, return\n  if (!self.s.pool || this._destroyed) {\n    this._destroyed = true;\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n  this._destroyed = true;\n\n  // Emit close event\n  if (options.emitClose) {\n    self.emit('close', self);\n  }\n\n  // Emit destroy event\n  if (options.emitDestroy) {\n    self.emit('destroy', self);\n  }\n\n  // Remove all listeners\n  listeners.forEach(function (event) {\n    self.s.pool.removeAllListeners(event);\n  });\n\n  // Emit opening server event\n  if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {\n    topologyId: topologyId(self),\n    address: self.name\n  });\n\n  // Emit toplogy opening event if not in topology\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n    self.emit('topologyClosed', {\n      topologyId: topologyId(self)\n    });\n  }\n  if (self.s.logger.isDebug()) {\n    self.s.logger.debug(f('destroy called on server %s', self.name));\n  }\n\n  // Destroy the pool\n  this.s.pool.destroy(options.force, callback);\n};\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Server#connect\n * @type {Server}\n */\n\n/**\n * A server reconnect event, used to verify that the server topology has reconnected\n *\n * @event Server#reconnect\n * @type {Server}\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event Server#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event Server#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event Server#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event Server#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event Server#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event Server#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * Server reconnect failed\n *\n * @event Server#reconnectFailed\n * @type {Error}\n */\n\n/**\n * Server connection pool closed\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server connection pool caused an error\n *\n * @event Server#error\n * @type {Error}\n */\n\n/**\n * Server destroyed was called\n *\n * @event Server#destroy\n * @type {Server}\n */\n\nmodule.exports = Server;","map":{"version":3,"names":["inherits","require","f","format","EventEmitter","ReadPreference","Logger","debugOptions","retrieveBSON","Pool","MongoError","MongoNetworkError","wireProtocol","CoreCursor","sdam","createCompressionInfo","resolveClusterTime","SessionMixins","extractCommand","relayEvents","collationNotSupported","makeClientMetadata","debugFields","id","serverAccounting","servers","BSON","topologyId","server","s","parent","Server","options","call","Object","assign","metadata","logger","Cursor","cursorFactory","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","pool","disconnectHandler","monitoring","inTopology","monitoringInterval","compression","compressors","clusterTime","ismaster","lastIsMasterMS","monitoringProcessId","initialConnect","_type","lastUpdateTime","lastWriteDate","staleness","prototype","defineProperty","enumerable","get","native","logicalSessionTimeoutMinutes","set","settings","enableServerAccounting","disableServerAccounting","host","port","self","type","ns","cmd","callback","isConnected","reconnect","add","name","monitoringProcess","isDestroyed","emit","start","Date","getTime","command","socketTimeout","connectionTimeout","err","result","setTimeout","eventHandler","event","conn","isInfo","object","JSON","stringify","info","agreedCompressor","zlibCompressionLevel","$clusterTime","msg","emitServerDescriptionChanged","address","arbiters","hosts","passives","getTopologyType","emitTopologyDescriptionChanged","topologyType","indexOf","listeners","length","state","connect","isDisconnected","on","auth","credentials","getDescription","description","setName","lastIsMaster","unref","basicWriteValidations","basicReadValidations","readPreference","Error","wireProtocolCommand","isDebug","extractedCommand","debug","shouldRedact","query","cursorState","getMore","batchSize","killCursors","insert","ops","Array","isArray","update","remove","cursor","topology","FinalCursor","equals","toLowerCase","connections","allConnections","selectServer","selector","undefined","destroy","_destroyed","clearTimeout","emitClose","emitDestroy","forEach","removeAllListeners","force","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/topologies/server.js"],"sourcesContent":["'use strict';\n\nvar inherits = require('util').inherits,\n  f = require('util').format,\n  EventEmitter = require('events').EventEmitter,\n  ReadPreference = require('./read_preference'),\n  Logger = require('../connection/logger'),\n  debugOptions = require('../connection/utils').debugOptions,\n  retrieveBSON = require('../connection/utils').retrieveBSON,\n  Pool = require('../connection/pool'),\n  MongoError = require('../error').MongoError,\n  MongoNetworkError = require('../error').MongoNetworkError,\n  wireProtocol = require('../wireprotocol'),\n  CoreCursor = require('../cursor').CoreCursor,\n  sdam = require('./shared'),\n  createCompressionInfo = require('./shared').createCompressionInfo,\n  resolveClusterTime = require('./shared').resolveClusterTime,\n  SessionMixins = require('./shared').SessionMixins,\n  extractCommand = require('../../command_utils').extractCommand,\n  relayEvents = require('../utils').relayEvents;\n\nconst collationNotSupported = require('../utils').collationNotSupported;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\n\n// Used for filtering out fields for loggin\nvar debugFields = [\n  'reconnect',\n  'reconnectTries',\n  'reconnectInterval',\n  'emitError',\n  'cursorFactory',\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'checkServerIdentity',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'key',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'servername'\n];\n\n// Server instance id\nvar id = 0;\nvar serverAccounting = false;\nvar servers = {};\nvar BSON = retrieveBSON();\n\nfunction topologyId(server) {\n  return server.s.parent == null ? server.id : server.s.parent.id;\n}\n\n/**\n * Creates a new Server instance\n * @class\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)\n * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.bsonRegExp=false] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {Server} A cursor instance\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#reconnectFailed\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n * @fires Server#topologyOpening\n * @fires Server#topologyClosed\n * @fires Server#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\nvar Server = function(options) {\n  options = options || {};\n\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Server instance id\n  this.id = id++;\n\n  // Internal state\n  this.s = {\n    // Options\n    options: Object.assign({ metadata: makeClientMetadata(options) }, options),\n    // Logger\n    logger: Logger('Server', options),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // BSON instance\n    bson:\n      options.bson ||\n      new BSON([\n        BSON.Binary,\n        BSON.Code,\n        BSON.DBRef,\n        BSON.Decimal128,\n        BSON.Double,\n        BSON.Int32,\n        BSON.Long,\n        BSON.Map,\n        BSON.MaxKey,\n        BSON.MinKey,\n        BSON.ObjectId,\n        BSON.BSONRegExp,\n        BSON.Symbol,\n        BSON.Timestamp\n      ]),\n    // Pool\n    pool: null,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Monitor thread (keeps the connection alive)\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,\n    // Is the server in a topology\n    inTopology: !!options.parent,\n    // Monitoring timeout\n    monitoringInterval:\n      typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,\n    compression: { compressors: createCompressionInfo(options) },\n    // Optional parent topology\n    parent: options.parent\n  };\n\n  // If this is a single deployment we need to track the clusterTime here\n  if (!this.s.parent) {\n    this.s.clusterTime = null;\n  }\n\n  // Curent ismaster\n  this.ismaster = null;\n  // Current ping time\n  this.lastIsMasterMS = -1;\n  // The monitoringProcessId\n  this.monitoringProcessId = null;\n  // Initial connection\n  this.initialConnect = true;\n  // Default type\n  this._type = 'server';\n\n  // Max Stalleness values\n  // last time we updated the ismaster state\n  this.lastUpdateTime = 0;\n  // Last write time\n  this.lastWriteDate = 0;\n  // Stalleness\n  this.staleness = 0;\n};\n\ninherits(Server, EventEmitter);\nObject.assign(Server.prototype, SessionMixins);\n\nObject.defineProperty(Server.prototype, 'type', {\n  enumerable: true,\n  get: function() {\n    return this._type;\n  }\n});\n\nObject.defineProperty(Server.prototype, 'parserType', {\n  enumerable: true,\n  get: function() {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\n\nObject.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function() {\n    if (!this.ismaster) return null;\n    return this.ismaster.logicalSessionTimeoutMinutes || null;\n  }\n});\n\nObject.defineProperty(Server.prototype, 'clientMetadata', {\n  enumerable: true,\n  get: function() {\n    return this.s.options.metadata;\n  }\n});\n\n// In single server deployments we track the clusterTime directly on the topology, however\n// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the\n// tracking objects so we can ensure we are gossiping the maximum time received from the\n// server.\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  enumerable: true,\n  set: function(clusterTime) {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    resolveClusterTime(settings, clusterTime);\n  },\n  get: function() {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    return settings.clusterTime || null;\n  }\n});\n\nServer.enableServerAccounting = function() {\n  serverAccounting = true;\n  servers = {};\n};\n\nServer.disableServerAccounting = function() {\n  serverAccounting = false;\n};\n\nServer.servers = function() {\n  return servers;\n};\n\nObject.defineProperty(Server.prototype, 'name', {\n  enumerable: true,\n  get: function() {\n    return this.s.options.host + ':' + this.s.options.port;\n  }\n});\n\nfunction disconnectHandler(self, type, ns, cmd, options, callback) {\n  // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n  if (\n    !self.s.pool.isConnected() &&\n    self.s.options.reconnect &&\n    self.s.disconnectHandler != null &&\n    !options.monitoring\n  ) {\n    self.s.disconnectHandler.add(type, ns, cmd, options, callback);\n    return true;\n  }\n\n  // If we have no connection error\n  if (!self.s.pool.isConnected()) {\n    callback(new MongoError(f('no connection available to server %s', self.name)));\n    return true;\n  }\n}\n\nfunction monitoringProcess(self) {\n  return function() {\n    // Pool was destroyed do not continue process\n    if (self.s.pool.isDestroyed()) return;\n    // Emit monitoring Process event\n    self.emit('monitoring', self);\n    // Perform ismaster call\n    // Get start time\n    var start = new Date().getTime();\n\n    // Execute the ismaster query\n    self.command(\n      'admin.$cmd',\n      { ismaster: true },\n      {\n        socketTimeout:\n          typeof self.s.options.connectionTimeout !== 'number'\n            ? 2000\n            : self.s.options.connectionTimeout,\n        monitoring: true\n      },\n      (err, result) => {\n        // Set initial lastIsMasterMS\n        self.lastIsMasterMS = new Date().getTime() - start;\n        if (self.s.pool.isDestroyed()) return;\n        // Update the ismaster view if we have a result\n        if (result) {\n          self.ismaster = result.result;\n        }\n        // Re-schedule the monitoring process\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n      }\n    );\n  };\n}\n\nvar eventHandler = function(self, event) {\n  return function(err, conn) {\n    // Log information of received information if in info mode\n    if (self.s.logger.isInfo()) {\n      var object = err instanceof MongoError ? JSON.stringify(err) : {};\n      self.s.logger.info(\n        f('server %s fired event %s out with message %s', self.name, event, object)\n      );\n    }\n\n    // Handle connect event\n    if (event === 'connect') {\n      self.initialConnect = false;\n      self.ismaster = conn.ismaster;\n      self.lastIsMasterMS = conn.lastIsMasterMS;\n      if (conn.agreedCompressor) {\n        self.s.pool.options.agreedCompressor = conn.agreedCompressor;\n      }\n\n      if (conn.zlibCompressionLevel) {\n        self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\n      }\n\n      if (conn.ismaster.$clusterTime) {\n        const $clusterTime = conn.ismaster.$clusterTime;\n        self.clusterTime = $clusterTime;\n      }\n\n      // It's a proxy change the type so\n      // the wireprotocol will send $readPreference\n      if (self.ismaster.msg === 'isdbgrid') {\n        self._type = 'mongos';\n      }\n\n      // Have we defined self monitoring\n      if (self.s.monitoring) {\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n      }\n\n      // Emit server description changed if something listening\n      sdam.emitServerDescriptionChanged(self, {\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: sdam.getTopologyType(self)\n      });\n\n      if (!self.s.inTopology) {\n        // Emit topology description changed if something listening\n        sdam.emitTopologyDescriptionChanged(self, {\n          topologyType: 'Single',\n          servers: [\n            {\n              address: self.name,\n              arbiters: [],\n              hosts: [],\n              passives: [],\n              type: sdam.getTopologyType(self)\n            }\n          ]\n        });\n      }\n\n      // Log the ismaster if available\n      if (self.s.logger.isInfo()) {\n        self.s.logger.info(\n          f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster))\n        );\n      }\n\n      // Emit connect\n      self.emit('connect', self);\n    } else if (\n      event === 'error' ||\n      event === 'parseError' ||\n      event === 'close' ||\n      event === 'timeout' ||\n      event === 'reconnect' ||\n      event === 'attemptReconnect' ||\n      event === 'reconnectFailed'\n    ) {\n      // Remove server instance from accounting\n      if (\n        serverAccounting &&\n        ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1\n      ) {\n        // Emit toplogy opening event if not in topology\n        if (!self.s.inTopology) {\n          self.emit('topologyOpening', { topologyId: self.id });\n        }\n\n        delete servers[self.id];\n      }\n\n      if (event === 'close') {\n        // Closing emits a server description changed event going to unknown.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        });\n      }\n\n      // Reconnect failed return error\n      if (event === 'reconnectFailed') {\n        self.emit('reconnectFailed', err);\n        // Emit error if any listeners\n        if (self.listeners('error').length > 0) {\n          self.emit('error', err);\n        }\n        // Terminate\n        return;\n      }\n\n      // On first connect fail\n      if (\n        ['disconnected', 'connecting'].indexOf(self.s.pool.state) !== -1 &&\n        self.initialConnect &&\n        ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1\n      ) {\n        self.initialConnect = false;\n        return self.emit(\n          'error',\n          new MongoNetworkError(\n            f('failed to connect to server [%s] on first connect [%s]', self.name, err)\n          )\n        );\n      }\n\n      // Reconnect event, emit the server\n      if (event === 'reconnect') {\n        // Reconnecting emits a server description changed event going from unknown to the\n        // current server type.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: sdam.getTopologyType(self)\n        });\n        return self.emit(event, self);\n      }\n\n      // Emit the event\n      self.emit(event, err);\n    }\n  };\n};\n\n/**\n * Initiate server connect\n */\nServer.prototype.connect = function(options) {\n  var self = this;\n  options = options || {};\n\n  // Set the connections\n  if (serverAccounting) servers[this.id] = this;\n\n  // Do not allow connect to be called on anything that's not disconnected\n  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {\n    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));\n  }\n\n  // Create a pool\n  self.s.pool = new Pool(this, Object.assign(self.s.options, options, { bson: this.s.bson }));\n\n  // Set up listeners\n  self.s.pool.on('close', eventHandler(self, 'close'));\n  self.s.pool.on('error', eventHandler(self, 'error'));\n  self.s.pool.on('timeout', eventHandler(self, 'timeout'));\n  self.s.pool.on('parseError', eventHandler(self, 'parseError'));\n  self.s.pool.on('connect', eventHandler(self, 'connect'));\n  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));\n  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));\n\n  // Set up listeners for command monitoring\n  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n  // Emit toplogy opening event if not in topology\n  if (!self.s.inTopology) {\n    this.emit('topologyOpening', { topologyId: topologyId(self) });\n  }\n\n  // Emit opening server event\n  self.emit('serverOpening', { topologyId: topologyId(self), address: self.name });\n\n  self.s.pool.connect();\n};\n\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\nServer.prototype.auth = function(credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Get the server description\n * @method\n * @return {object}\n */\nServer.prototype.getDescription = function() {\n  var ismaster = this.ismaster || {};\n  var description = {\n    type: sdam.getTopologyType(this),\n    address: this.name\n  };\n\n  // Add fields if available\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\n  if (ismaster.passives) description.passives = ismaster.passives;\n  if (ismaster.setName) description.setName = ismaster.setName;\n  return description;\n};\n\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\nServer.prototype.lastIsMaster = function() {\n  return this.ismaster;\n};\n\n/**\n * Unref all connections belong to this server\n * @method\n */\nServer.prototype.unref = function() {\n  this.s.pool.unref();\n};\n\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\nServer.prototype.isConnected = function() {\n  if (!this.s.pool) return false;\n  return this.s.pool.isConnected();\n};\n\n/**\n * Figure out if the server instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\nServer.prototype.isDestroyed = function() {\n  if (!this.s.pool) return false;\n  return this.s.pool.isDestroyed();\n};\n\nfunction basicWriteValidations(self) {\n  if (!self.s.pool) return new MongoError('server instance is not connected');\n  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');\n}\n\nfunction basicReadValidations(self, options) {\n  basicWriteValidations(self, options);\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    throw new Error('readPreference must be an instance of ReadPreference');\n  }\n}\n\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.command = function(ns, cmd, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicReadValidations(self, options);\n  if (result) return callback(result);\n\n  // Clone the options\n  options = Object.assign({}, options, { wireProtocolCommand: false });\n\n  // Debug log\n  if (self.s.logger.isDebug()) {\n    const extractedCommand = extractCommand(cmd);\n    self.s.logger.debug(\n      f(\n        'executing command [%s] against %s',\n        JSON.stringify({\n          ns: ns,\n          cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,\n          options: debugOptions(debugFields, options)\n        }),\n        self.name\n      )\n    );\n  }\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, cmd)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  wireProtocol.command(self, ns, cmd, options, callback);\n};\n\n/**\n * Execute a query against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command document for the query\n * @param {object} options Optional settings\n * @param {function} callback\n */\nServer.prototype.query = function(ns, cmd, cursorState, options, callback) {\n  wireProtocol.query(this, ns, cmd, cursorState, options, callback);\n};\n\n/**\n * Execute a `getMore` against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {object} options Optional settings\n * @param {function} callback\n */\nServer.prototype.getMore = function(ns, cursorState, batchSize, options, callback) {\n  wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);\n};\n\n/**\n * Execute a `killCursors` command against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {function} callback\n */\nServer.prototype.killCursors = function(ns, cursorState, callback) {\n  wireProtocol.killCursors(this, ns, cursorState, callback);\n};\n\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.insert = function(ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return;\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n\n  // Execute write\n  return wireProtocol.insert(self, ns, ops, options, callback);\n};\n\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.update = function(ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n  // Execute write\n  return wireProtocol.update(self, ns, ops, options, callback);\n};\n\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.remove = function(ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n  // Execute write\n  return wireProtocol.remove(self, ns, ops, options, callback);\n};\n\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\nServer.prototype.cursor = function(ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this;\n\n  // Set up final cursor type\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\n\n  // Return the cursor\n  return new FinalCursor(topology, ns, cmd, options);\n};\n\n/**\n * Compare two server instances\n * @method\n * @param {Server} server Server to compare equality against\n * @return {boolean}\n */\nServer.prototype.equals = function(server) {\n  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();\n  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();\n  return false;\n};\n\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\nServer.prototype.connections = function() {\n  return this.s.pool.allConnections();\n};\n\n/**\n * Selects a server\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Unused\n * @param {ClientSession} [options.session] Unused\n * @return {Server}\n */\nServer.prototype.selectServer = function(selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined')\n    (callback = selector), (selector = undefined), (options = {});\n  if (typeof options === 'function')\n    (callback = options), (options = selector), (selector = undefined);\n\n  callback(null, this);\n};\n\nvar listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];\n\n/**\n * Destroy the server connection\n * @method\n * @param {boolean} [options.emitClose=false] Emit close event on destroy\n * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy\n * @param {boolean} [options.force=false] Force destroy the pool\n */\nServer.prototype.destroy = function(options, callback) {\n  if (this._destroyed) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var self = this;\n\n  // Set the connections\n  if (serverAccounting) delete servers[this.id];\n\n  // Destroy the monitoring process if any\n  if (this.monitoringProcessId) {\n    clearTimeout(this.monitoringProcessId);\n  }\n\n  // No pool, return\n  if (!self.s.pool || this._destroyed) {\n    this._destroyed = true;\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  this._destroyed = true;\n\n  // Emit close event\n  if (options.emitClose) {\n    self.emit('close', self);\n  }\n\n  // Emit destroy event\n  if (options.emitDestroy) {\n    self.emit('destroy', self);\n  }\n\n  // Remove all listeners\n  listeners.forEach(function(event) {\n    self.s.pool.removeAllListeners(event);\n  });\n\n  // Emit opening server event\n  if (self.listeners('serverClosed').length > 0)\n    self.emit('serverClosed', { topologyId: topologyId(self), address: self.name });\n\n  // Emit toplogy opening event if not in topology\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n    self.emit('topologyClosed', { topologyId: topologyId(self) });\n  }\n\n  if (self.s.logger.isDebug()) {\n    self.s.logger.debug(f('destroy called on server %s', self.name));\n  }\n\n  // Destroy the pool\n  this.s.pool.destroy(options.force, callback);\n};\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Server#connect\n * @type {Server}\n */\n\n/**\n * A server reconnect event, used to verify that the server topology has reconnected\n *\n * @event Server#reconnect\n * @type {Server}\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event Server#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event Server#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event Server#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event Server#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event Server#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event Server#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * Server reconnect failed\n *\n * @event Server#reconnectFailed\n * @type {Error}\n */\n\n/**\n * Server connection pool closed\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server connection pool caused an error\n *\n * @event Server#error\n * @type {Error}\n */\n\n/**\n * Server destroyed was called\n *\n * @event Server#destroy\n * @type {Server}\n */\n\nmodule.exports = Server;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}