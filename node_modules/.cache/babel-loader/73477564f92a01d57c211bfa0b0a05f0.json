{"ast":null,"code":"'use strict';\n\nconst net = require('net');\nconst tls = require('tls');\nconst Connection = require('./connection');\nconst MongoError = require('../error').MongoError;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\nconst AuthContext = require('../auth/auth_provider').AuthContext;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n      return;\n    }\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\nfunction isModernConnectionType(conn) {\n  return !(conn instanceof Connection);\n}\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === 'number' && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === 'number' && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n  const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n  const credentials = options.credentials;\n  if (credentials) {\n    if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {\n      callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err) {\n      return callback(err);\n    }\n    const handshakeOptions = Object.assign({}, options);\n    if (options.connectTimeoutMS || options.connectionTimeout) {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n    }\n    const start = new Date().getTime();\n    conn.command('admin.$cmd', handshakeDoc, handshakeOptions, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      const response = result.result;\n      if (response.ok === 0) {\n        callback(new MongoError(response));\n        return;\n      }\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n      if (!isModernConnectionType(conn)) {\n        // resolve compression\n        if (response.compression) {\n          const agreedCompressors = handshakeDoc.compression.filter(compressor => response.compression.indexOf(compressor) !== -1);\n          if (agreedCompressors.length) {\n            conn.agreedCompressor = agreedCompressors[0];\n          }\n          if (options.compression && options.compression.zlibCompressionLevel) {\n            conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n          }\n        }\n      }\n\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        Object.assign(authContext, {\n          response\n        });\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];\n        authProvider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n      callback(undefined, conn);\n    });\n  });\n}\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compression && options.compression.compressors ? options.compression.compressors : [];\n  const handshakeDoc = {\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  };\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {\n      Object.assign(handshakeDoc, {\n        saslSupportedMechs: `${credentials.source}.${credentials.username}`\n      });\n      AUTH_PROVIDERS['scram-sha-256'].prepare(handshakeDoc, authContext, callback);\n      return;\n    }\n    const authProvider = AUTH_PROVIDERS[credentials.mechanism];\n    if (authProvider == null) {\n      return callback(new MongoError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n    authProvider.prepare(handshakeDoc, authContext, callback);\n    return;\n  }\n  callback(undefined, handshakeDoc);\n}\nconst LEGAL_SSL_SOCKET_OPTIONS = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize', 'crl', 'rejectUnauthorized'];\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n  if (host.indexOf('/') !== -1) {\n    return {\n      path: host\n    };\n  }\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n  return result;\n}\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options);\n\n  // Merge in valid SSL options\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  }\n\n  // Override checkServerIdentity behavior\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function () {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n  return result;\n}\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n  const rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n  let socket;\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n    _callback(err, ret);\n  };\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n  socket.once(connectEvent, connectHandler);\n}\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkTimeoutError(`connection timed out`);\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\nmodule.exports = connect;","map":{"version":3,"names":["net","require","tls","Connection","MongoError","MongoNetworkError","MongoNetworkTimeoutError","defaultAuthProviders","AuthContext","WIRE_CONSTANTS","makeClientMetadata","MAX_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MIN_SUPPORTED_SERVER_VERSION","AUTH_PROVIDERS","connect","options","cancellationToken","callback","undefined","ConnectionType","connectionType","bson","family","makeConnection","err","socket","performInitialHandshake","isModernConnectionType","conn","checkSupportedServer","ismaster","serverVersionHighEnough","maxWireVersion","serverVersionLowEnough","minWireVersion","message","host","port","_callback","ret","destroy","credentials","mechanism","match","authContext","prepareHandshakeDocument","handshakeDoc","handshakeOptions","Object","assign","connectTimeoutMS","connectionTimeout","socketTimeout","start","Date","getTime","command","result","response","ok","supportedServerErr","compression","agreedCompressors","filter","compressor","indexOf","length","agreedCompressor","zlibCompressionLevel","lastIsMasterMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","authProvider","auth","compressors","client","metadata","username","saslSupportedMechs","source","prepare","LEGAL_SSL_SOCKET_OPTIONS","parseConnectOptions","path","rejectUnauthorized","parseSslOptions","name","checkServerIdentity","servername","isIP","SOCKET_ERROR_EVENTS","Set","useSsl","ssl","keepAlive","keepAliveInitialDelay","noDelay","Math","round","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","removeListener","connectHandler","connectionFailureError","authorizationError","once","type","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/connection/connect.js"],"sourcesContent":["'use strict';\nconst net = require('net');\nconst tls = require('tls');\nconst Connection = require('./connection');\nconst MongoError = require('../error').MongoError;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\nconst AuthContext = require('../auth/auth_provider').AuthContext;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return !(conn instanceof Connection);\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough =\n    ismaster &&\n    typeof ismaster.maxWireVersion === 'number' &&\n    ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    ismaster &&\n    typeof ismaster.minWireVersion === 'number' &&\n    ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${\n    options.port\n  } reports maximum wire version ${ismaster.maxWireVersion ||\n    0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function(err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n  if (credentials) {\n    if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {\n      callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n    if (options.connectTimeoutMS || options.connectionTimeout) {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n    }\n\n    const start = new Date().getTime();\n    conn.command('admin.$cmd', handshakeDoc, handshakeOptions, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const response = result.result;\n      if (response.ok === 0) {\n        callback(new MongoError(response));\n        return;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (!isModernConnectionType(conn)) {\n        // resolve compression\n        if (response.compression) {\n          const agreedCompressors = handshakeDoc.compression.filter(\n            compressor => response.compression.indexOf(compressor) !== -1\n          );\n\n          if (agreedCompressors.length) {\n            conn.agreedCompressor = agreedCompressors[0];\n          }\n\n          if (options.compression && options.compression.zlibCompressionLevel) {\n            conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n          }\n        }\n      }\n\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        Object.assign(authContext, { response });\n\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];\n        authProvider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors =\n    options.compression && options.compression.compressors ? options.compression.compressors : [];\n\n  const handshakeDoc = {\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  };\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {\n      Object.assign(handshakeDoc, {\n        saslSupportedMechs: `${credentials.source}.${credentials.username}`\n      });\n\n      AUTH_PROVIDERS['scram-sha-256'].prepare(handshakeDoc, authContext, callback);\n      return;\n    }\n\n    const authProvider = AUTH_PROVIDERS[credentials.mechanism];\n    if (authProvider == null) {\n      return callback(new MongoError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n    authProvider.prepare(handshakeDoc, authContext, callback);\n    return;\n  }\n\n  callback(undefined, handshakeDoc);\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = [\n  'pfx',\n  'key',\n  'passphrase',\n  'cert',\n  'ca',\n  'ciphers',\n  'NPNProtocols',\n  'ALPNProtocols',\n  'servername',\n  'ecdhCurve',\n  'secureProtocol',\n  'secureContext',\n  'session',\n  'minDHSize',\n  'crl',\n  'rejectUnauthorized'\n];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n  if (host.indexOf('/') !== -1) {\n    return { path: host };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options);\n\n  // Merge in valid SSL options\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  }\n\n  // Override checkServerIdentity behavior\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function() {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay =\n    typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout =\n    typeof options.connectionTimeout === 'number'\n      ? options.connectionTimeout\n      : typeof options.connectTimeoutMS === 'number'\n      ? options.connectTimeoutMS\n      : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n  const rejectUnauthorized =\n    typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n  const callback = function(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkTimeoutError(`connection timed out`);\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}