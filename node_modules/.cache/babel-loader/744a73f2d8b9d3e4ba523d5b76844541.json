{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst TopologyType = require('./common').TopologyType;\nconst ReadPreference = require('../topologies/read_preference');\nconst MongoError = require('../error').MongoError;\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n  return function (topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n  };\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);\n  }\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n  }\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n  return function (topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n    }\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n    if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n    return selectedServers;\n  };\n}\nmodule.exports = {\n  writableServerSelector,\n  readPreferenceServerSelector\n};","map":{"version":3,"names":["ServerType","require","TopologyType","ReadPreference","MongoError","IDLE_WRITE_PERIOD","SMALLEST_MAX_STALENESS_SECONDS","writableServerSelector","topologyDescription","servers","latencyWindowReducer","filter","s","isWritable","maxStalenessReducer","readPreference","maxStalenessSeconds","maxStaleness","maxStalenessVariance","heartbeatFrequencyMS","type","ReplicaSetWithPrimary","primary","Array","from","values","primaryFilter","reduce","result","server","stalenessMS","lastUpdateTime","lastWriteDate","staleness","push","ReplicaSetNoPrimary","length","sMax","max","tagSetMatch","tagSet","serverTags","keys","Object","serverTagKeys","i","key","indexOf","tagSetReducer","tags","isArray","serversMatchingTagset","matched","low","min","roundTripTime","Math","high","localThresholdMS","RSPrimary","secondaryFilter","RSSecondary","nearestFilter","knownFilter","Unknown","readPreferenceServerSelector","isValid","TypeError","commonWireVersion","minWireVersion","Single","Sharded","mode","PRIMARY","PRIMARY_PREFERRED","NEAREST","selectedServers","SECONDARY_PREFERRED","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/sdam/server_selection.js"],"sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst TopologyType = require('./common').TopologyType;\nconst ReadPreference = require('../topologies/read_preference');\nconst MongoError = require('../error').MongoError;\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n  return function(topologyDescription, servers) {\n    return latencyWindowReducer(\n      topologyDescription,\n      servers.filter(s => s.isWritable)\n    );\n  };\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(\n      `maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max, s) => (s.lastWriteDate > max.lastWriteDate ? s : max));\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce(\n    (min, server) => (min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min)),\n    -1\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function(topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (\n      topologyDescription.type === TopologyType.Single ||\n      topologyDescription.type === TopologyType.Sharded\n    ) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(\n      topologyDescription,\n      tagSetReducer(\n        readPreference,\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\n      )\n    );\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nmodule.exports = {\n  writableServerSelector,\n  readPreferenceServerSelector\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}