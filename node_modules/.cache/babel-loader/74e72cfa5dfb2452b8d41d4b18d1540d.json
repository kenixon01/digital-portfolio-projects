{"ast":null,"code":"'use strict';\n\nconst maybePromise = require('../utils').maybePromise;\nconst MongoError = require('../core/error').MongoError;\nconst Aspect = require('./operation').Aspect;\nconst OperationBase = require('./operation').OperationBase;\nconst ReadPreference = require('../core/topologies/read_preference');\nconst isRetryableError = require('../core/error').isRetryableError;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {Operation} operation The operation to execute\n * @param {function} callback The command result callback\n */\nfunction executeOperation(topology, operation, cb) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n  return maybePromise(topology, cb, callback => {\n    if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {\n      // Recursive call to executeOperation after a server selection\n      return selectServerForSessionSupport(topology, operation, callback);\n    }\n\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session, owner;\n    if (topology.hasSessionSupport()) {\n      if (operation.session == null) {\n        owner = Symbol();\n        session = topology.startSession({\n          owner\n        });\n        operation.session = session;\n      } else if (operation.session.hasEnded) {\n        return callback(new MongoError('Use of expired sessions is not permitted'));\n      }\n    } else if (operation.session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return callback(new MongoError('Current topology does not support sessions'));\n    }\n    function executeCallback(err, result) {\n      if (session && session.owner === owner) {\n        session.endSession();\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n      callback(err, result);\n    }\n    try {\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n        executeWithServerSelection(topology, operation, executeCallback);\n      } else {\n        operation.execute(executeCallback);\n      }\n    } catch (error) {\n      if (session && session.owner === owner) {\n        session.endSession();\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n      callback(error);\n    }\n  });\n}\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n    if (!isRetryableError(err)) {\n      return callback(err);\n    }\n\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n      operation.execute(server, callback);\n    });\n  }\n\n  // select a server, and execute the operation against it\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n    const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n    operation.execute(server, callback);\n  });\n}\n\n// The Unified Topology runs serverSelection before executing every operation\n// Session support is determined by the result of a monitoring check triggered by this selection\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      return callback(err);\n    }\n    executeOperation(topology, operation, callback);\n  });\n}\nmodule.exports = executeOperation;","map":{"version":3,"names":["maybePromise","require","MongoError","Aspect","OperationBase","ReadPreference","isRetryableError","maxWireVersion","isUnifiedTopology","executeOperation","topology","operation","cb","TypeError","callback","shouldCheckForSessionSupport","selectServerForSessionSupport","session","owner","hasSessionSupport","Symbol","startSession","hasEnded","executeCallback","err","result","endSession","clearSession","hasAspect","EXECUTE_WITH_SELECTION","executeWithServerSelection","execute","error","supportsRetryableReads","server","readPreference","primary","inTransaction","equals","mode","serverSelectionOptions","callbackWithRetry","selectServer","shouldRetryReads","s","options","retryReads","canRetryRead","RETRYABLE","primaryPreferred","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/operations/execute_operation.js"],"sourcesContent":["'use strict';\n\nconst maybePromise = require('../utils').maybePromise;\nconst MongoError = require('../core/error').MongoError;\nconst Aspect = require('./operation').Aspect;\nconst OperationBase = require('./operation').OperationBase;\nconst ReadPreference = require('../core/topologies/read_preference');\nconst isRetryableError = require('../core/error').isRetryableError;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {Operation} operation The operation to execute\n * @param {function} callback The command result callback\n */\nfunction executeOperation(topology, operation, cb) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n\n  return maybePromise(topology, cb, callback => {\n    if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {\n      // Recursive call to executeOperation after a server selection\n      return selectServerForSessionSupport(topology, operation, callback);\n    }\n\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session, owner;\n    if (topology.hasSessionSupport()) {\n      if (operation.session == null) {\n        owner = Symbol();\n        session = topology.startSession({ owner });\n        operation.session = session;\n      } else if (operation.session.hasEnded) {\n        return callback(new MongoError('Use of expired sessions is not permitted'));\n      }\n    } else if (operation.session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return callback(new MongoError('Current topology does not support sessions'));\n    }\n\n    function executeCallback(err, result) {\n      if (session && session.owner === owner) {\n        session.endSession();\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n\n      callback(err, result);\n    }\n\n    try {\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n        executeWithServerSelection(topology, operation, executeCallback);\n      } else {\n        operation.execute(executeCallback);\n      }\n    } catch (error) {\n      if (session && session.owner === owner) {\n        session.endSession();\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n\n      callback(error);\n    }\n  });\n}\n\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(\n      new MongoError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    }\n\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n\n      operation.execute(server, callback);\n    });\n  }\n\n  // select a server, and execute the operation against it\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n    const shouldRetryReads =\n      topology.s.options.retryReads !== false &&\n      operation.session &&\n      !inTransaction &&\n      supportsRetryableReads(server) &&\n      operation.canRetryRead;\n\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n\n    operation.execute(server, callback);\n  });\n}\n\n// The Unified Topology runs serverSelection before executing every operation\n// Session support is determined by the result of a monitoring check triggered by this selection\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      return callback(err);\n    }\n\n    executeOperation(topology, operation, callback);\n  });\n}\n\nmodule.exports = executeOperation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}