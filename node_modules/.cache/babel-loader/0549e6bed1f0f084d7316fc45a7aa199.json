{"ast":null,"code":"'use strict';\n\nvar writeIEEE754 = require('../float_parser').writeIEEE754,\n  Long = require('../long').Long,\n  Map = require('../map'),\n  Binary = require('../binary').Binary;\nvar normalizedFunctionString = require('./utils').normalizedFunctionString;\n\n// try {\n//   var _Buffer = Uint8Array;\n// } catch (e) {\n//   _Buffer = Buffer;\n// }\n\nvar regexp = /\\x00/; // eslint-disable-line no-control-regex\nvar ignoreKeys = ['$db', '$ref', '$id', '$clusterTime'];\n\n// To ensure that 0.4 of node works correctly\nvar isDate = function isDate(d) {\n  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';\n};\nvar isRegExp = function isRegExp(d) {\n  return Object.prototype.toString.call(d) === '[object RegExp]';\n};\nvar serializeString = function (buffer, key, value, index, isArray) {\n  // Encode String type\n  buffer[index++] = BSON.BSON_DATA_STRING;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes + 1;\n  buffer[index - 1] = 0;\n  // Write the string\n  var size = buffer.write(value, index + 4, 'utf8');\n  // Write the size of the string to buffer\n  buffer[index + 3] = size + 1 >> 24 & 0xff;\n  buffer[index + 2] = size + 1 >> 16 & 0xff;\n  buffer[index + 1] = size + 1 >> 8 & 0xff;\n  buffer[index] = size + 1 & 0xff;\n  // Update index\n  index = index + 4 + size;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n};\nvar serializeNumber = function (buffer, key, value, index, isArray) {\n  // We have an integer value\n  if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n    // If the value fits in 32 bits encode as int, if it fits in a double\n    // encode it as a double, otherwise long\n    if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {\n      // Set int type 32 bits or less\n      buffer[index++] = BSON.BSON_DATA_INT;\n      // Number of written bytes\n      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      // Write the int value\n      buffer[index++] = value & 0xff;\n      buffer[index++] = value >> 8 & 0xff;\n      buffer[index++] = value >> 16 & 0xff;\n      buffer[index++] = value >> 24 & 0xff;\n    } else if (value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n      // Encode as double\n      buffer[index++] = BSON.BSON_DATA_NUMBER;\n      // Number of written bytes\n      numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      // Write float\n      writeIEEE754(buffer, value, index, 'little', 52, 8);\n      // Ajust index\n      index = index + 8;\n    } else {\n      // Set long type\n      buffer[index++] = BSON.BSON_DATA_LONG;\n      // Number of written bytes\n      numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      var longVal = Long.fromNumber(value);\n      var lowBits = longVal.getLowBits();\n      var highBits = longVal.getHighBits();\n      // Encode low bits\n      buffer[index++] = lowBits & 0xff;\n      buffer[index++] = lowBits >> 8 & 0xff;\n      buffer[index++] = lowBits >> 16 & 0xff;\n      buffer[index++] = lowBits >> 24 & 0xff;\n      // Encode high bits\n      buffer[index++] = highBits & 0xff;\n      buffer[index++] = highBits >> 8 & 0xff;\n      buffer[index++] = highBits >> 16 & 0xff;\n      buffer[index++] = highBits >> 24 & 0xff;\n    }\n  } else {\n    // Encode as double\n    buffer[index++] = BSON.BSON_DATA_NUMBER;\n    // Number of written bytes\n    numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Write float\n    writeIEEE754(buffer, value, index, 'little', 52, 8);\n    // Ajust index\n    index = index + 8;\n  }\n  return index;\n};\nvar serializeNull = function (buffer, key, value, index, isArray) {\n  // Set long type\n  buffer[index++] = BSON.BSON_DATA_NULL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\nvar serializeBoolean = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BOOLEAN;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Encode the boolean value\n  buffer[index++] = value ? 1 : 0;\n  return index;\n};\nvar serializeDate = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_DATE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write the date\n  var dateInMilis = Long.fromNumber(value.getTime());\n  var lowBits = dateInMilis.getLowBits();\n  var highBits = dateInMilis.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n};\nvar serializeRegExp = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw Error('value ' + value.source + ' must not contain null bytes');\n  }\n  // Adjust the index\n  index = index + buffer.write(value.source, index, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the parameters\n  if (value.global) buffer[index++] = 0x73; // s\n  if (value.ignoreCase) buffer[index++] = 0x69; // i\n  if (value.multiline) buffer[index++] = 0x6d; // m\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n};\nvar serializeBSONRegExp = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Check the pattern for 0 bytes\n  if (value.pattern.match(regexp) != null) {\n    // The BSON spec doesn't allow keys with null bytes because keys are\n    // null-terminated.\n    throw Error('pattern ' + value.pattern + ' must not contain null bytes');\n  }\n\n  // Adjust the index\n  index = index + buffer.write(value.pattern, index, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the options\n  index = index + buffer.write(value.options.split('').sort().join(''), index, 'utf8');\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n};\nvar serializeMinMax = function (buffer, key, value, index, isArray) {\n  // Write the type of either min or max key\n  if (value === null) {\n    buffer[index++] = BSON.BSON_DATA_NULL;\n  } else if (value._bsontype === 'MinKey') {\n    buffer[index++] = BSON.BSON_DATA_MIN_KEY;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_MAX_KEY;\n  }\n\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\nvar serializeObjectId = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OID;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write the objectId into the shared buffer\n  if (typeof value.id === 'string') {\n    buffer.write(value.id, index, 'binary');\n  } else if (value.id && value.id.copy) {\n    value.id.copy(buffer, index, 0, 12);\n  } else {\n    throw new Error('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n  }\n\n  // Ajust index\n  return index + 12;\n};\nvar serializeBuffer = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Get size of the buffer (current write point)\n  var size = value.length;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff;\n  // Write the default subtype\n  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;\n  // Copy the content form the binary field to the buffer\n  value.copy(buffer, index, 0, size);\n  // Adjust the index\n  index = index + size;\n  return index;\n};\nvar serializeObject = function (buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {\n  for (var i = 0; i < path.length; i++) {\n    if (path[i] === value) throw new Error('cyclic dependency detected');\n  }\n\n  // Push value to stack\n  path.push(value);\n  // Write the type\n  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n  // Pop stack\n  path.pop();\n  // Write size\n  return endIndex;\n};\nvar serializeDecimal128 = function (buffer, key, value, index, isArray) {\n  buffer[index++] = BSON.BSON_DATA_DECIMAL128;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the data from the value\n  value.bytes.copy(buffer, index, 0, 16);\n  return index + 16;\n};\nvar serializeLong = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = value._bsontype === 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the date\n  var lowBits = value.getLowBits();\n  var highBits = value.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n};\nvar serializeInt32 = function (buffer, key, value, index, isArray) {\n  // Set int type 32 bits or less\n  buffer[index++] = BSON.BSON_DATA_INT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the int value\n  buffer[index++] = value & 0xff;\n  buffer[index++] = value >> 8 & 0xff;\n  buffer[index++] = value >> 16 & 0xff;\n  buffer[index++] = value >> 24 & 0xff;\n  return index;\n};\nvar serializeDouble = function (buffer, key, value, index, isArray) {\n  // Encode as double\n  buffer[index++] = BSON.BSON_DATA_NUMBER;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write float\n  writeIEEE754(buffer, value, index, 'little', 52, 8);\n  // Ajust index\n  index = index + 8;\n  return index;\n};\nvar serializeFunction = function (buffer, key, value, index, checkKeys, depth, isArray) {\n  buffer[index++] = BSON.BSON_DATA_CODE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Function string\n  var functionString = normalizedFunctionString(value);\n\n  // Write the string\n  var size = buffer.write(functionString, index + 4, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n};\nvar serializeCode = function (buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {\n  if (value.scope && typeof value.scope === 'object') {\n    // Write the type\n    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;\n    // Number of written bytes\n    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n\n    // Starting index\n    var startIndex = index;\n\n    // Serialize the function\n    // Get the function string\n    var functionString = typeof value.code === 'string' ? value.code : value.code.toString();\n    // Index adjustment\n    index = index + 4;\n    // Write string into buffer\n    var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = codeSize & 0xff;\n    buffer[index + 1] = codeSize >> 8 & 0xff;\n    buffer[index + 2] = codeSize >> 16 & 0xff;\n    buffer[index + 3] = codeSize >> 24 & 0xff;\n    // Write end 0\n    buffer[index + 4 + codeSize - 1] = 0;\n    // Write the\n    index = index + codeSize + 4;\n\n    //\n    // Serialize the scope value\n    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);\n    index = endIndex - 1;\n\n    // Writ the total\n    var totalSize = endIndex - startIndex;\n\n    // Write the total size of the object\n    buffer[startIndex++] = totalSize & 0xff;\n    buffer[startIndex++] = totalSize >> 8 & 0xff;\n    buffer[startIndex++] = totalSize >> 16 & 0xff;\n    buffer[startIndex++] = totalSize >> 24 & 0xff;\n    // Write trailing zero\n    buffer[index++] = 0;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_CODE;\n    // Number of written bytes\n    numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Function string\n    functionString = value.code.toString();\n    // Write the string\n    var size = buffer.write(functionString, index + 4, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    // Update index\n    index = index + 4 + size - 1;\n    // Write zero\n    buffer[index++] = 0;\n  }\n  return index;\n};\nvar serializeBinary = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Extract the buffer\n  var data = value.value(true);\n  // Calculate size\n  var size = value.position;\n  // Add the deprecated 02 type 4 bytes of size to total\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff;\n  // Write the subtype to the buffer\n  buffer[index++] = value.sub_type;\n\n  // If we have binary type 2 the 4 first bytes are the size\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n  }\n\n  // Write the data to the object\n  data.copy(buffer, index, 0, value.position);\n  // Adjust the index\n  index = index + value.position;\n  return index;\n};\nvar serializeSymbol = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_SYMBOL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the string\n  var size = buffer.write(value.value, index + 4, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0x00;\n  return index;\n};\nvar serializeDBRef = function (buffer, key, value, index, depth, serializeFunctions, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var startIndex = index;\n  var endIndex;\n\n  // Serialize object\n  if (null != value.db) {\n    endIndex = serializeInto(buffer, {\n      $ref: value.namespace,\n      $id: value.oid,\n      $db: value.db\n    }, false, index, depth + 1, serializeFunctions);\n  } else {\n    endIndex = serializeInto(buffer, {\n      $ref: value.namespace,\n      $id: value.oid\n    }, false, index, depth + 1, serializeFunctions);\n  }\n\n  // Calculate object size\n  var size = endIndex - startIndex;\n  // Write the size\n  buffer[startIndex++] = size & 0xff;\n  buffer[startIndex++] = size >> 8 & 0xff;\n  buffer[startIndex++] = size >> 16 & 0xff;\n  buffer[startIndex++] = size >> 24 & 0xff;\n  // Set index\n  return endIndex;\n};\nvar serializeInto = function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n  startingIndex = startingIndex || 0;\n  path = path || [];\n\n  // Push the object to the path\n  path.push(object);\n\n  // Start place to serialize into\n  var index = startingIndex + 4;\n  // var self = this;\n\n  // Special case isArray\n  if (Array.isArray(object)) {\n    // Get object keys\n    for (var i = 0; i < object.length; i++) {\n      var key = '' + i;\n      var value = object[i];\n\n      // Is there an override value\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      }\n      var type = typeof value;\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index, true);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index, true);\n      } else if (type === 'bigint') {\n        throw new TypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index, true);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index, true);\n      } else if (value === undefined) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index, true);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index, true);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index, true);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index, true);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions, true);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index, true);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else if (object instanceof Map) {\n    var iterator = object.entries();\n    var done = false;\n    while (!done) {\n      // Unpack the next entry\n      var entry = iterator.next();\n      done = entry.done;\n      // Are we done, then skip and terminate\n      if (done) continue;\n\n      // Get the entry values\n      key = entry.value[0];\n      value = entry.value[1];\n\n      // Check the type of the value\n      type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        throw new TypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n        // } else if (value === undefined && ignoreUndefined === true) {\n      } else if (value === null || value === undefined && ignoreUndefined === false) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else {\n    // Did we provide a custom serialization method\n    if (object.toBSON) {\n      if (typeof object.toBSON !== 'function') throw new Error('toBSON is not a function');\n      object = object.toBSON();\n      if (object != null && typeof object !== 'object') throw new Error('toBSON function did not return an object');\n    }\n\n    // Iterate over all the keys\n    for (key in object) {\n      value = object[key];\n      // Is there an override value\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      }\n\n      // Check the type of the value\n      type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        throw new TypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  }\n\n  // Remove the path\n  path.pop();\n\n  // Final padding byte for object\n  buffer[index++] = 0x00;\n\n  // Final size\n  var size = index - startingIndex;\n  // Write the size of the object\n  buffer[startingIndex++] = size & 0xff;\n  buffer[startingIndex++] = size >> 8 & 0xff;\n  buffer[startingIndex++] = size >> 16 & 0xff;\n  buffer[startingIndex++] = size >> 24 & 0xff;\n  return index;\n};\nvar BSON = {};\n\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\n// var functionCache = (BSON.functionCache = {});\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\nBSON.BSON_DATA_BINARY = 5;\n/**\n * ObjectID BSON Type, deprecated\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\n\n// BSON MAX VALUES\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63);\n\n// JS MAX PRECISE VALUES\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n\n// Internal long versions\n// var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\n// var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = serializeInto;","map":{"version":3,"names":["writeIEEE754","require","Long","Map","Binary","normalizedFunctionString","regexp","ignoreKeys","isDate","d","Object","prototype","toString","call","isRegExp","serializeString","buffer","key","value","index","isArray","BSON","BSON_DATA_STRING","numberOfWrittenBytes","write","size","serializeNumber","Math","floor","JS_INT_MIN","JS_INT_MAX","BSON_INT32_MIN","BSON_INT32_MAX","BSON_DATA_INT","BSON_DATA_NUMBER","BSON_DATA_LONG","longVal","fromNumber","lowBits","getLowBits","highBits","getHighBits","serializeNull","BSON_DATA_NULL","serializeBoolean","BSON_DATA_BOOLEAN","serializeDate","BSON_DATA_DATE","dateInMilis","getTime","serializeRegExp","BSON_DATA_REGEXP","source","match","Error","global","ignoreCase","multiline","serializeBSONRegExp","pattern","options","split","sort","join","serializeMinMax","_bsontype","BSON_DATA_MIN_KEY","BSON_DATA_MAX_KEY","serializeObjectId","BSON_DATA_OID","id","copy","JSON","stringify","serializeBuffer","BSON_DATA_BINARY","length","BSON_BINARY_SUBTYPE_DEFAULT","serializeObject","checkKeys","depth","serializeFunctions","ignoreUndefined","path","i","push","Array","BSON_DATA_ARRAY","BSON_DATA_OBJECT","endIndex","serializeInto","pop","serializeDecimal128","BSON_DATA_DECIMAL128","bytes","serializeLong","BSON_DATA_TIMESTAMP","serializeInt32","serializeDouble","serializeFunction","BSON_DATA_CODE","functionString","serializeCode","scope","BSON_DATA_CODE_W_SCOPE","startIndex","code","codeSize","totalSize","serializeBinary","data","position","sub_type","SUBTYPE_BYTE_ARRAY","serializeSymbol","BSON_DATA_SYMBOL","serializeDBRef","db","$ref","namespace","$id","oid","$db","object","startingIndex","toBSON","type","TypeError","Date","undefined","Buffer","isBuffer","RegExp","iterator","entries","done","entry","next","indexOf","BSON_DATA_UNDEFINED","BSON_BINARY_SUBTYPE_FUNCTION","BSON_BINARY_SUBTYPE_BYTE_ARRAY","BSON_BINARY_SUBTYPE_UUID","BSON_BINARY_SUBTYPE_MD5","BSON_BINARY_SUBTYPE_USER_DEFINED","BSON_INT64_MAX","pow","BSON_INT64_MIN","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/bson/lib/bson/parser/serializer.js"],"sourcesContent":["'use strict';\n\nvar writeIEEE754 = require('../float_parser').writeIEEE754,\n  Long = require('../long').Long,\n  Map = require('../map'),\n  Binary = require('../binary').Binary;\n\nvar normalizedFunctionString = require('./utils').normalizedFunctionString;\n\n// try {\n//   var _Buffer = Uint8Array;\n// } catch (e) {\n//   _Buffer = Buffer;\n// }\n\nvar regexp = /\\x00/; // eslint-disable-line no-control-regex\nvar ignoreKeys = ['$db', '$ref', '$id', '$clusterTime'];\n\n// To ensure that 0.4 of node works correctly\nvar isDate = function isDate(d) {\n  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';\n};\n\nvar isRegExp = function isRegExp(d) {\n  return Object.prototype.toString.call(d) === '[object RegExp]';\n};\n\nvar serializeString = function(buffer, key, value, index, isArray) {\n  // Encode String type\n  buffer[index++] = BSON.BSON_DATA_STRING;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes + 1;\n  buffer[index - 1] = 0;\n  // Write the string\n  var size = buffer.write(value, index + 4, 'utf8');\n  // Write the size of the string to buffer\n  buffer[index + 3] = ((size + 1) >> 24) & 0xff;\n  buffer[index + 2] = ((size + 1) >> 16) & 0xff;\n  buffer[index + 1] = ((size + 1) >> 8) & 0xff;\n  buffer[index] = (size + 1) & 0xff;\n  // Update index\n  index = index + 4 + size;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeNumber = function(buffer, key, value, index, isArray) {\n  // We have an integer value\n  if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n    // If the value fits in 32 bits encode as int, if it fits in a double\n    // encode it as a double, otherwise long\n    if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {\n      // Set int type 32 bits or less\n      buffer[index++] = BSON.BSON_DATA_INT;\n      // Number of written bytes\n      var numberOfWrittenBytes = !isArray\n        ? buffer.write(key, index, 'utf8')\n        : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      // Write the int value\n      buffer[index++] = value & 0xff;\n      buffer[index++] = (value >> 8) & 0xff;\n      buffer[index++] = (value >> 16) & 0xff;\n      buffer[index++] = (value >> 24) & 0xff;\n    } else if (value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n      // Encode as double\n      buffer[index++] = BSON.BSON_DATA_NUMBER;\n      // Number of written bytes\n      numberOfWrittenBytes = !isArray\n        ? buffer.write(key, index, 'utf8')\n        : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      // Write float\n      writeIEEE754(buffer, value, index, 'little', 52, 8);\n      // Ajust index\n      index = index + 8;\n    } else {\n      // Set long type\n      buffer[index++] = BSON.BSON_DATA_LONG;\n      // Number of written bytes\n      numberOfWrittenBytes = !isArray\n        ? buffer.write(key, index, 'utf8')\n        : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      var longVal = Long.fromNumber(value);\n      var lowBits = longVal.getLowBits();\n      var highBits = longVal.getHighBits();\n      // Encode low bits\n      buffer[index++] = lowBits & 0xff;\n      buffer[index++] = (lowBits >> 8) & 0xff;\n      buffer[index++] = (lowBits >> 16) & 0xff;\n      buffer[index++] = (lowBits >> 24) & 0xff;\n      // Encode high bits\n      buffer[index++] = highBits & 0xff;\n      buffer[index++] = (highBits >> 8) & 0xff;\n      buffer[index++] = (highBits >> 16) & 0xff;\n      buffer[index++] = (highBits >> 24) & 0xff;\n    }\n  } else {\n    // Encode as double\n    buffer[index++] = BSON.BSON_DATA_NUMBER;\n    // Number of written bytes\n    numberOfWrittenBytes = !isArray\n      ? buffer.write(key, index, 'utf8')\n      : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Write float\n    writeIEEE754(buffer, value, index, 'little', 52, 8);\n    // Ajust index\n    index = index + 8;\n  }\n\n  return index;\n};\n\nvar serializeNull = function(buffer, key, value, index, isArray) {\n  // Set long type\n  buffer[index++] = BSON.BSON_DATA_NULL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeBoolean = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BOOLEAN;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Encode the boolean value\n  buffer[index++] = value ? 1 : 0;\n  return index;\n};\n\nvar serializeDate = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_DATE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write the date\n  var dateInMilis = Long.fromNumber(value.getTime());\n  var lowBits = dateInMilis.getLowBits();\n  var highBits = dateInMilis.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = (lowBits >> 8) & 0xff;\n  buffer[index++] = (lowBits >> 16) & 0xff;\n  buffer[index++] = (lowBits >> 24) & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = (highBits >> 8) & 0xff;\n  buffer[index++] = (highBits >> 16) & 0xff;\n  buffer[index++] = (highBits >> 24) & 0xff;\n  return index;\n};\n\nvar serializeRegExp = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw Error('value ' + value.source + ' must not contain null bytes');\n  }\n  // Adjust the index\n  index = index + buffer.write(value.source, index, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the parameters\n  if (value.global) buffer[index++] = 0x73; // s\n  if (value.ignoreCase) buffer[index++] = 0x69; // i\n  if (value.multiline) buffer[index++] = 0x6d; // m\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeBSONRegExp = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Check the pattern for 0 bytes\n  if (value.pattern.match(regexp) != null) {\n    // The BSON spec doesn't allow keys with null bytes because keys are\n    // null-terminated.\n    throw Error('pattern ' + value.pattern + ' must not contain null bytes');\n  }\n\n  // Adjust the index\n  index = index + buffer.write(value.pattern, index, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the options\n  index =\n    index +\n    buffer.write(\n      value.options\n        .split('')\n        .sort()\n        .join(''),\n      index,\n      'utf8'\n    );\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeMinMax = function(buffer, key, value, index, isArray) {\n  // Write the type of either min or max key\n  if (value === null) {\n    buffer[index++] = BSON.BSON_DATA_NULL;\n  } else if (value._bsontype === 'MinKey') {\n    buffer[index++] = BSON.BSON_DATA_MIN_KEY;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_MAX_KEY;\n  }\n\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeObjectId = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OID;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write the objectId into the shared buffer\n  if (typeof value.id === 'string') {\n    buffer.write(value.id, index, 'binary');\n  } else if (value.id && value.id.copy) {\n    value.id.copy(buffer, index, 0, 12);\n  } else {\n    throw new Error('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n  }\n\n  // Ajust index\n  return index + 12;\n};\n\nvar serializeBuffer = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Get size of the buffer (current write point)\n  var size = value.length;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = (size >> 8) & 0xff;\n  buffer[index++] = (size >> 16) & 0xff;\n  buffer[index++] = (size >> 24) & 0xff;\n  // Write the default subtype\n  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;\n  // Copy the content form the binary field to the buffer\n  value.copy(buffer, index, 0, size);\n  // Adjust the index\n  index = index + size;\n  return index;\n};\n\nvar serializeObject = function(\n  buffer,\n  key,\n  value,\n  index,\n  checkKeys,\n  depth,\n  serializeFunctions,\n  ignoreUndefined,\n  isArray,\n  path\n) {\n  for (var i = 0; i < path.length; i++) {\n    if (path[i] === value) throw new Error('cyclic dependency detected');\n  }\n\n  // Push value to stack\n  path.push(value);\n  // Write the type\n  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var endIndex = serializeInto(\n    buffer,\n    value,\n    checkKeys,\n    index,\n    depth + 1,\n    serializeFunctions,\n    ignoreUndefined,\n    path\n  );\n  // Pop stack\n  path.pop();\n  // Write size\n  return endIndex;\n};\n\nvar serializeDecimal128 = function(buffer, key, value, index, isArray) {\n  buffer[index++] = BSON.BSON_DATA_DECIMAL128;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the data from the value\n  value.bytes.copy(buffer, index, 0, 16);\n  return index + 16;\n};\n\nvar serializeLong = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = value._bsontype === 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the date\n  var lowBits = value.getLowBits();\n  var highBits = value.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = (lowBits >> 8) & 0xff;\n  buffer[index++] = (lowBits >> 16) & 0xff;\n  buffer[index++] = (lowBits >> 24) & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = (highBits >> 8) & 0xff;\n  buffer[index++] = (highBits >> 16) & 0xff;\n  buffer[index++] = (highBits >> 24) & 0xff;\n  return index;\n};\n\nvar serializeInt32 = function(buffer, key, value, index, isArray) {\n  // Set int type 32 bits or less\n  buffer[index++] = BSON.BSON_DATA_INT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the int value\n  buffer[index++] = value & 0xff;\n  buffer[index++] = (value >> 8) & 0xff;\n  buffer[index++] = (value >> 16) & 0xff;\n  buffer[index++] = (value >> 24) & 0xff;\n  return index;\n};\n\nvar serializeDouble = function(buffer, key, value, index, isArray) {\n  // Encode as double\n  buffer[index++] = BSON.BSON_DATA_NUMBER;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write float\n  writeIEEE754(buffer, value, index, 'little', 52, 8);\n  // Ajust index\n  index = index + 8;\n  return index;\n};\n\nvar serializeFunction = function(buffer, key, value, index, checkKeys, depth, isArray) {\n  buffer[index++] = BSON.BSON_DATA_CODE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Function string\n  var functionString = normalizedFunctionString(value);\n\n  // Write the string\n  var size = buffer.write(functionString, index + 4, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = (size >> 8) & 0xff;\n  buffer[index + 2] = (size >> 16) & 0xff;\n  buffer[index + 3] = (size >> 24) & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeCode = function(\n  buffer,\n  key,\n  value,\n  index,\n  checkKeys,\n  depth,\n  serializeFunctions,\n  ignoreUndefined,\n  isArray\n) {\n  if (value.scope && typeof value.scope === 'object') {\n    // Write the type\n    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;\n    // Number of written bytes\n    var numberOfWrittenBytes = !isArray\n      ? buffer.write(key, index, 'utf8')\n      : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n\n    // Starting index\n    var startIndex = index;\n\n    // Serialize the function\n    // Get the function string\n    var functionString = typeof value.code === 'string' ? value.code : value.code.toString();\n    // Index adjustment\n    index = index + 4;\n    // Write string into buffer\n    var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = codeSize & 0xff;\n    buffer[index + 1] = (codeSize >> 8) & 0xff;\n    buffer[index + 2] = (codeSize >> 16) & 0xff;\n    buffer[index + 3] = (codeSize >> 24) & 0xff;\n    // Write end 0\n    buffer[index + 4 + codeSize - 1] = 0;\n    // Write the\n    index = index + codeSize + 4;\n\n    //\n    // Serialize the scope value\n    var endIndex = serializeInto(\n      buffer,\n      value.scope,\n      checkKeys,\n      index,\n      depth + 1,\n      serializeFunctions,\n      ignoreUndefined\n    );\n    index = endIndex - 1;\n\n    // Writ the total\n    var totalSize = endIndex - startIndex;\n\n    // Write the total size of the object\n    buffer[startIndex++] = totalSize & 0xff;\n    buffer[startIndex++] = (totalSize >> 8) & 0xff;\n    buffer[startIndex++] = (totalSize >> 16) & 0xff;\n    buffer[startIndex++] = (totalSize >> 24) & 0xff;\n    // Write trailing zero\n    buffer[index++] = 0;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_CODE;\n    // Number of written bytes\n    numberOfWrittenBytes = !isArray\n      ? buffer.write(key, index, 'utf8')\n      : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Function string\n    functionString = value.code.toString();\n    // Write the string\n    var size = buffer.write(functionString, index + 4, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = (size >> 8) & 0xff;\n    buffer[index + 2] = (size >> 16) & 0xff;\n    buffer[index + 3] = (size >> 24) & 0xff;\n    // Update index\n    index = index + 4 + size - 1;\n    // Write zero\n    buffer[index++] = 0;\n  }\n\n  return index;\n};\n\nvar serializeBinary = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Extract the buffer\n  var data = value.value(true);\n  // Calculate size\n  var size = value.position;\n  // Add the deprecated 02 type 4 bytes of size to total\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = (size >> 8) & 0xff;\n  buffer[index++] = (size >> 16) & 0xff;\n  buffer[index++] = (size >> 24) & 0xff;\n  // Write the subtype to the buffer\n  buffer[index++] = value.sub_type;\n\n  // If we have binary type 2 the 4 first bytes are the size\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = (size >> 8) & 0xff;\n    buffer[index++] = (size >> 16) & 0xff;\n    buffer[index++] = (size >> 24) & 0xff;\n  }\n\n  // Write the data to the object\n  data.copy(buffer, index, 0, value.position);\n  // Adjust the index\n  index = index + value.position;\n  return index;\n};\n\nvar serializeSymbol = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_SYMBOL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the string\n  var size = buffer.write(value.value, index + 4, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = (size >> 8) & 0xff;\n  buffer[index + 2] = (size >> 16) & 0xff;\n  buffer[index + 3] = (size >> 24) & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  var startIndex = index;\n  var endIndex;\n\n  // Serialize object\n  if (null != value.db) {\n    endIndex = serializeInto(\n      buffer,\n      {\n        $ref: value.namespace,\n        $id: value.oid,\n        $db: value.db\n      },\n      false,\n      index,\n      depth + 1,\n      serializeFunctions\n    );\n  } else {\n    endIndex = serializeInto(\n      buffer,\n      {\n        $ref: value.namespace,\n        $id: value.oid\n      },\n      false,\n      index,\n      depth + 1,\n      serializeFunctions\n    );\n  }\n\n  // Calculate object size\n  var size = endIndex - startIndex;\n  // Write the size\n  buffer[startIndex++] = size & 0xff;\n  buffer[startIndex++] = (size >> 8) & 0xff;\n  buffer[startIndex++] = (size >> 16) & 0xff;\n  buffer[startIndex++] = (size >> 24) & 0xff;\n  // Set index\n  return endIndex;\n};\n\nvar serializeInto = function serializeInto(\n  buffer,\n  object,\n  checkKeys,\n  startingIndex,\n  depth,\n  serializeFunctions,\n  ignoreUndefined,\n  path\n) {\n  startingIndex = startingIndex || 0;\n  path = path || [];\n\n  // Push the object to the path\n  path.push(object);\n\n  // Start place to serialize into\n  var index = startingIndex + 4;\n  // var self = this;\n\n  // Special case isArray\n  if (Array.isArray(object)) {\n    // Get object keys\n    for (var i = 0; i < object.length; i++) {\n      var key = '' + i;\n      var value = object[i];\n\n      // Is there an override value\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      }\n\n      var type = typeof value;\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index, true);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index, true);\n      } else  if(type === 'bigint') {\n        throw new TypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index, true);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index, true);\n      } else if (value === undefined) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index, true);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index, true);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index, true);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          true,\n          path\n        );\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index, true);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          true\n        );\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          true\n        );\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index, true);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else if (object instanceof Map) {\n    var iterator = object.entries();\n    var done = false;\n\n    while (!done) {\n      // Unpack the next entry\n      var entry = iterator.next();\n      done = entry.done;\n      // Are we done, then skip and terminate\n      if (done) continue;\n\n      // Get the entry values\n      key = entry.value[0];\n      value = entry.value[1];\n\n      // Check the type of the value\n      type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if(type === 'bigint') {\n        throw new TypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n        // } else if (value === undefined && ignoreUndefined === true) {\n      } else if (value === null || (value === undefined && ignoreUndefined === false)) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          false,\n          path\n        );\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined\n        );\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else {\n    // Did we provide a custom serialization method\n    if (object.toBSON) {\n      if (typeof object.toBSON !== 'function') throw new Error('toBSON is not a function');\n      object = object.toBSON();\n      if (object != null && typeof object !== 'object')\n        throw new Error('toBSON function did not return an object');\n    }\n\n    // Iterate over all the keys\n    for (key in object) {\n      value = object[key];\n      // Is there an override value\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      }\n\n      // Check the type of the value\n      type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if(type === 'bigint') {\n        throw new TypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          false,\n          path\n        );\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined\n        );\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  }\n\n  // Remove the path\n  path.pop();\n\n  // Final padding byte for object\n  buffer[index++] = 0x00;\n\n  // Final size\n  var size = index - startingIndex;\n  // Write the size of the object\n  buffer[startingIndex++] = size & 0xff;\n  buffer[startingIndex++] = (size >> 8) & 0xff;\n  buffer[startingIndex++] = (size >> 16) & 0xff;\n  buffer[startingIndex++] = (size >> 24) & 0xff;\n  return index;\n};\n\nvar BSON = {};\n\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\n// var functionCache = (BSON.functionCache = {});\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\nBSON.BSON_DATA_BINARY = 5;\n/**\n * ObjectID BSON Type, deprecated\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\n\n// BSON MAX VALUES\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\n\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63);\n\n// JS MAX PRECISE VALUES\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n\n// Internal long versions\n// var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\n// var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = serializeInto;\n"],"mappings":"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AAC4G,aAAa,EAAE,CAAC,GAAInG,IAAI,IAAI,EAAE,GAAI,IAAI;EAC7C,OAAON,KAAK;AACd,CAAC;AAED,IAAIE,IAAI,GAAG,CAAC,CAAC;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACAA,IAAI,CAACa,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACAb,IAAI,CAACC,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACAD,IAAI,CAACmE,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACAnE,IAAI,CAACkE,eAAe,GAAG,CAAC;AACxB;AACA;AACA;AACA;AACA;AACAlE,IAAI,CAACsD,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACAtD,IAAI,CAACsH,mBAAmB,GAAG,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACAtH,IAAI,CAACgD,aAAa,GAAG,CAAC;AACtB;AACA;AACA;AACA;AACA;AACAhD,IAAI,CAACwB,iBAAiB,GAAG,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACAxB,IAAI,CAAC0B,cAAc,GAAG,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA1B,IAAI,CAACsB,cAAc,GAAG,EAAE;AACxB;AACA;AACA;AACA;AACA;AACAtB,IAAI,CAAC8B,gBAAgB,GAAG,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA9B,IAAI,CAAC+E,cAAc,GAAG,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA/E,IAAI,CAAC8F,gBAAgB,GAAG,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA9F,IAAI,CAACmF,sBAAsB,GAAG,EAAE;AAChC;AACA;AACA;AACA;AACA;AACAnF,IAAI,CAACY,aAAa,GAAG,EAAE;AACvB;AACA;AACA;AACA;AACA;AACAZ,IAAI,CAAC2E,mBAAmB,GAAG,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA3E,IAAI,CAACc,cAAc,GAAG,EAAE;AACxB;AACA;AACA;AACA;AACA;AACAd,IAAI,CAACwE,oBAAoB,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACAxE,IAAI,CAAC6C,iBAAiB,GAAG,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA7C,IAAI,CAAC8C,iBAAiB,GAAG,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA9C,IAAI,CAACwD,2BAA2B,GAAG,CAAC;AACpC;AACA;AACA;AACA;AACA;AACAxD,IAAI,CAACuH,4BAA4B,GAAG,CAAC;AACrC;AACA;AACA;AACA;AACA;AACAvH,IAAI,CAACwH,8BAA8B,GAAG,CAAC;AACvC;AACA;AACA;AACA;AACA;AACAxH,IAAI,CAACyH,wBAAwB,GAAG,CAAC;AACjC;AACA;AACA;AACA;AACA;AACAzH,IAAI,CAAC0H,uBAAuB,GAAG,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA1H,IAAI,CAAC2H,gCAAgC,GAAG,GAAG;;AAE3C;AACA3H,IAAI,CAACW,cAAc,GAAG,UAAU;AAChCX,IAAI,CAACU,cAAc,GAAG,CAAC,UAAU;AAEjCV,IAAI,CAAC4H,cAAc,GAAGtH,IAAI,CAACuH,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;AACzC7H,IAAI,CAAC8H,cAAc,GAAG,CAACxH,IAAI,CAACuH,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;;AAEtC;AACA7H,IAAI,CAACS,UAAU,GAAG,gBAAgB,CAAC,CAAC;AACpCT,IAAI,CAACQ,UAAU,GAAG,CAAC,gBAAgB,CAAC,CAAC;;AAErC;AACA;AACA;;AAEAuH,MAAM,CAACC,OAAO,GAAG3D,aAAa"},"metadata":{},"sourceType":"script"}