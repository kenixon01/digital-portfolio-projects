{"ast":null,"code":"/**\n * Module dependencies.\n * @ignore\n */\n\n// Test if we're in Node via presence of \"global\" not absence of \"window\"\n// to support hybrid environments like Electron\nif (typeof global !== 'undefined') {\n  var Buffer = require('buffer').Buffer; // TODO just use global Buffer\n}\n\nvar utils = require('./parser/utils');\n\n/**\n * A class representation of the BSON Binary type.\n *\n * Sub types\n *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.\n *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.\n *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.\n *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.\n *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.\n *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.\n *\n * @class\n * @param {Buffer} buffer a buffer object containing the binary data.\n * @param {Number} [subType] the option binary type.\n * @return {Binary}\n */\nfunction Binary(buffer, subType) {\n  if (!(this instanceof Binary)) return new Binary(buffer, subType);\n  if (buffer != null && !(typeof buffer === 'string') && !Buffer.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {\n    throw new Error('only String, Buffer, Uint8Array or Array accepted');\n  }\n  this._bsontype = 'Binary';\n  if (buffer instanceof Number) {\n    this.sub_type = buffer;\n    this.position = 0;\n  } else {\n    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;\n    this.position = 0;\n  }\n  if (buffer != null && !(buffer instanceof Number)) {\n    // Only accept Buffer, Uint8Array or Arrays\n    if (typeof buffer === 'string') {\n      // Different ways of writing the length of the string for the different types\n      if (typeof Buffer !== 'undefined') {\n        this.buffer = utils.toBuffer(buffer);\n      } else if (typeof Uint8Array !== 'undefined' || Object.prototype.toString.call(buffer) === '[object Array]') {\n        this.buffer = writeStringToArray(buffer);\n      } else {\n        throw new Error('only String, Buffer, Uint8Array or Array accepted');\n      }\n    } else {\n      this.buffer = buffer;\n    }\n    this.position = buffer.length;\n  } else {\n    if (typeof Buffer !== 'undefined') {\n      this.buffer = utils.allocBuffer(Binary.BUFFER_SIZE);\n    } else if (typeof Uint8Array !== 'undefined') {\n      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));\n    } else {\n      this.buffer = new Array(Binary.BUFFER_SIZE);\n    }\n    // Set position to start of buffer\n    this.position = 0;\n  }\n}\n\n/**\n * Updates this binary with byte_value.\n *\n * @method\n * @param {string} byte_value a single byte we wish to write.\n */\nBinary.prototype.put = function put(byte_value) {\n  // If it's a string and a has more than one character throw an error\n  if (byte_value['length'] != null && typeof byte_value !== 'number' && byte_value.length !== 1) throw new Error('only accepts single character String, Uint8Array or Array');\n  if (typeof byte_value !== 'number' && byte_value < 0 || byte_value > 255) throw new Error('only accepts number in a valid unsigned byte range 0-255');\n\n  // Decode the byte value once\n  var decoded_byte = null;\n  if (typeof byte_value === 'string') {\n    decoded_byte = byte_value.charCodeAt(0);\n  } else if (byte_value['length'] != null) {\n    decoded_byte = byte_value[0];\n  } else {\n    decoded_byte = byte_value;\n  }\n  if (this.buffer.length > this.position) {\n    this.buffer[this.position++] = decoded_byte;\n  } else {\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      // Create additional overflow buffer\n      var buffer = utils.allocBuffer(Binary.BUFFER_SIZE + this.buffer.length);\n      // Combine the two buffers together\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n      this.buffer = buffer;\n      this.buffer[this.position++] = decoded_byte;\n    } else {\n      buffer = null;\n      // Create a new buffer (typed or normal array)\n      if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {\n        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));\n      } else {\n        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);\n      }\n\n      // We need to copy all the content to the new array\n      for (var i = 0; i < this.buffer.length; i++) {\n        buffer[i] = this.buffer[i];\n      }\n\n      // Reassign the buffer\n      this.buffer = buffer;\n      // Write the byte\n      this.buffer[this.position++] = decoded_byte;\n    }\n  }\n};\n\n/**\n * Writes a buffer or string to the binary.\n *\n * @method\n * @param {(Buffer|string)} string a string or buffer to be written to the Binary BSON object.\n * @param {number} offset specify the binary of where to write the content.\n * @return {null}\n */\nBinary.prototype.write = function write(string, offset) {\n  offset = typeof offset === 'number' ? offset : this.position;\n\n  // If the buffer is to small let's extend the buffer\n  if (this.buffer.length < offset + string.length) {\n    var buffer = null;\n    // If we are in node.js\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      buffer = utils.allocBuffer(this.buffer.length + string.length);\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n    } else if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {\n      // Create a new buffer\n      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));\n      // Copy the content\n      for (var i = 0; i < this.position; i++) {\n        buffer[i] = this.buffer[i];\n      }\n    }\n\n    // Assign the new buffer\n    this.buffer = buffer;\n  }\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {\n    string.copy(this.buffer, offset, 0, string.length);\n    this.position = offset + string.length > this.position ? offset + string.length : this.position;\n    // offset = string.length\n  } else if (typeof Buffer !== 'undefined' && typeof string === 'string' && Buffer.isBuffer(this.buffer)) {\n    this.buffer.write(string, offset, 'binary');\n    this.position = offset + string.length > this.position ? offset + string.length : this.position;\n    // offset = string.length;\n  } else if (Object.prototype.toString.call(string) === '[object Uint8Array]' || Object.prototype.toString.call(string) === '[object Array]' && typeof string !== 'string') {\n    for (i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string[i];\n    }\n    this.position = offset > this.position ? offset : this.position;\n  } else if (typeof string === 'string') {\n    for (i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string.charCodeAt(i);\n    }\n    this.position = offset > this.position ? offset : this.position;\n  }\n};\n\n/**\n * Reads **length** bytes starting at **position**.\n *\n * @method\n * @param {number} position read from the given position in the Binary.\n * @param {number} length the number of bytes to read.\n * @return {Buffer}\n */\nBinary.prototype.read = function read(position, length) {\n  length = length && length > 0 ? length : this.position;\n\n  // Let's return the data based on the type we have\n  if (this.buffer['slice']) {\n    return this.buffer.slice(position, position + length);\n  } else {\n    // Create a buffer to keep the result\n    var buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);\n    for (var i = 0; i < length; i++) {\n      buffer[i] = this.buffer[position++];\n    }\n  }\n  // Return the buffer\n  return buffer;\n};\n\n/**\n * Returns the value of this binary as a string.\n *\n * @method\n * @return {string}\n */\nBinary.prototype.value = function value(asRaw) {\n  asRaw = asRaw == null ? false : asRaw;\n\n  // Optimize to serialize for the situation where the data == size of buffer\n  if (asRaw && typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length === this.position) return this.buffer;\n\n  // If it's a node.js buffer object\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);\n  } else {\n    if (asRaw) {\n      // we support the slice command use it\n      if (this.buffer['slice'] != null) {\n        return this.buffer.slice(0, this.position);\n      } else {\n        // Create a new buffer to copy content to\n        var newBuffer = Object.prototype.toString.call(this.buffer) === '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);\n        // Copy content\n        for (var i = 0; i < this.position; i++) {\n          newBuffer[i] = this.buffer[i];\n        }\n        // Return the buffer\n        return newBuffer;\n      }\n    } else {\n      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);\n    }\n  }\n};\n\n/**\n * Length.\n *\n * @method\n * @return {number} the length of the binary.\n */\nBinary.prototype.length = function length() {\n  return this.position;\n};\n\n/**\n * @ignore\n */\nBinary.prototype.toJSON = function () {\n  return this.buffer != null ? this.buffer.toString('base64') : '';\n};\n\n/**\n * @ignore\n */\nBinary.prototype.toString = function (format) {\n  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';\n};\n\n/**\n * Binary default subtype\n * @ignore\n */\nvar BSON_BINARY_SUBTYPE_DEFAULT = 0;\n\n/**\n * @ignore\n */\nvar writeStringToArray = function (data) {\n  // Create a buffer\n  var buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);\n  // Write the content to the buffer\n  for (var i = 0; i < data.length; i++) {\n    buffer[i] = data.charCodeAt(i);\n  }\n  // Write the string to the buffer\n  return buffer;\n};\n\n/**\n * Convert Array ot Uint8Array to Binary String\n *\n * @ignore\n */\nvar convertArraytoUtf8BinaryString = function (byteArray, startIndex, endIndex) {\n  var result = '';\n  for (var i = startIndex; i < endIndex; i++) {\n    result = result + String.fromCharCode(byteArray[i]);\n  }\n  return result;\n};\nBinary.BUFFER_SIZE = 256;\n\n/**\n * Default BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_DEFAULT = 0;\n/**\n * Function BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_FUNCTION = 1;\n/**\n * Byte Array BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_BYTE_ARRAY = 2;\n/**\n * OLD UUID BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID_OLD = 3;\n/**\n * UUID BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID = 4;\n/**\n * MD5 BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_MD5 = 5;\n/**\n * User BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_USER_DEFINED = 128;\n\n/**\n * Expose.\n */\nmodule.exports = Binary;\nmodule.exports.Binary = Binary;","map":{"version":3,"names":["global","Buffer","require","utils","Binary","buffer","subType","isBuffer","Uint8Array","Array","isArray","Error","_bsontype","Number","sub_type","position","BSON_BINARY_SUBTYPE_DEFAULT","toBuffer","Object","prototype","toString","call","writeStringToArray","length","allocBuffer","BUFFER_SIZE","ArrayBuffer","put","byte_value","decoded_byte","charCodeAt","copy","i","write","string","offset","read","slice","value","asRaw","newBuffer","convertArraytoUtf8BinaryString","toJSON","format","data","byteArray","startIndex","endIndex","result","String","fromCharCode","SUBTYPE_DEFAULT","SUBTYPE_FUNCTION","SUBTYPE_BYTE_ARRAY","SUBTYPE_UUID_OLD","SUBTYPE_UUID","SUBTYPE_MD5","SUBTYPE_USER_DEFINED","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/bson/lib/bson/binary.js"],"sourcesContent":["/**\n * Module dependencies.\n * @ignore\n */\n\n// Test if we're in Node via presence of \"global\" not absence of \"window\"\n// to support hybrid environments like Electron\nif (typeof global !== 'undefined') {\n  var Buffer = require('buffer').Buffer; // TODO just use global Buffer\n}\n\nvar utils = require('./parser/utils');\n\n/**\n * A class representation of the BSON Binary type.\n *\n * Sub types\n *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.\n *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.\n *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.\n *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.\n *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.\n *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.\n *\n * @class\n * @param {Buffer} buffer a buffer object containing the binary data.\n * @param {Number} [subType] the option binary type.\n * @return {Binary}\n */\nfunction Binary(buffer, subType) {\n  if (!(this instanceof Binary)) return new Binary(buffer, subType);\n\n  if (\n    buffer != null &&\n    !(typeof buffer === 'string') &&\n    !Buffer.isBuffer(buffer) &&\n    !(buffer instanceof Uint8Array) &&\n    !Array.isArray(buffer)\n  ) {\n    throw new Error('only String, Buffer, Uint8Array or Array accepted');\n  }\n\n  this._bsontype = 'Binary';\n\n  if (buffer instanceof Number) {\n    this.sub_type = buffer;\n    this.position = 0;\n  } else {\n    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;\n    this.position = 0;\n  }\n\n  if (buffer != null && !(buffer instanceof Number)) {\n    // Only accept Buffer, Uint8Array or Arrays\n    if (typeof buffer === 'string') {\n      // Different ways of writing the length of the string for the different types\n      if (typeof Buffer !== 'undefined') {\n        this.buffer = utils.toBuffer(buffer);\n      } else if (\n        typeof Uint8Array !== 'undefined' ||\n        Object.prototype.toString.call(buffer) === '[object Array]'\n      ) {\n        this.buffer = writeStringToArray(buffer);\n      } else {\n        throw new Error('only String, Buffer, Uint8Array or Array accepted');\n      }\n    } else {\n      this.buffer = buffer;\n    }\n    this.position = buffer.length;\n  } else {\n    if (typeof Buffer !== 'undefined') {\n      this.buffer = utils.allocBuffer(Binary.BUFFER_SIZE);\n    } else if (typeof Uint8Array !== 'undefined') {\n      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));\n    } else {\n      this.buffer = new Array(Binary.BUFFER_SIZE);\n    }\n    // Set position to start of buffer\n    this.position = 0;\n  }\n}\n\n/**\n * Updates this binary with byte_value.\n *\n * @method\n * @param {string} byte_value a single byte we wish to write.\n */\nBinary.prototype.put = function put(byte_value) {\n  // If it's a string and a has more than one character throw an error\n  if (byte_value['length'] != null && typeof byte_value !== 'number' && byte_value.length !== 1)\n    throw new Error('only accepts single character String, Uint8Array or Array');\n  if ((typeof byte_value !== 'number' && byte_value < 0) || byte_value > 255)\n    throw new Error('only accepts number in a valid unsigned byte range 0-255');\n\n  // Decode the byte value once\n  var decoded_byte = null;\n  if (typeof byte_value === 'string') {\n    decoded_byte = byte_value.charCodeAt(0);\n  } else if (byte_value['length'] != null) {\n    decoded_byte = byte_value[0];\n  } else {\n    decoded_byte = byte_value;\n  }\n\n  if (this.buffer.length > this.position) {\n    this.buffer[this.position++] = decoded_byte;\n  } else {\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      // Create additional overflow buffer\n      var buffer = utils.allocBuffer(Binary.BUFFER_SIZE + this.buffer.length);\n      // Combine the two buffers together\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n      this.buffer = buffer;\n      this.buffer[this.position++] = decoded_byte;\n    } else {\n      buffer = null;\n      // Create a new buffer (typed or normal array)\n      if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {\n        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));\n      } else {\n        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);\n      }\n\n      // We need to copy all the content to the new array\n      for (var i = 0; i < this.buffer.length; i++) {\n        buffer[i] = this.buffer[i];\n      }\n\n      // Reassign the buffer\n      this.buffer = buffer;\n      // Write the byte\n      this.buffer[this.position++] = decoded_byte;\n    }\n  }\n};\n\n/**\n * Writes a buffer or string to the binary.\n *\n * @method\n * @param {(Buffer|string)} string a string or buffer to be written to the Binary BSON object.\n * @param {number} offset specify the binary of where to write the content.\n * @return {null}\n */\nBinary.prototype.write = function write(string, offset) {\n  offset = typeof offset === 'number' ? offset : this.position;\n\n  // If the buffer is to small let's extend the buffer\n  if (this.buffer.length < offset + string.length) {\n    var buffer = null;\n    // If we are in node.js\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      buffer = utils.allocBuffer(this.buffer.length + string.length);\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n    } else if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {\n      // Create a new buffer\n      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));\n      // Copy the content\n      for (var i = 0; i < this.position; i++) {\n        buffer[i] = this.buffer[i];\n      }\n    }\n\n    // Assign the new buffer\n    this.buffer = buffer;\n  }\n\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {\n    string.copy(this.buffer, offset, 0, string.length);\n    this.position = offset + string.length > this.position ? offset + string.length : this.position;\n    // offset = string.length\n  } else if (\n    typeof Buffer !== 'undefined' &&\n    typeof string === 'string' &&\n    Buffer.isBuffer(this.buffer)\n  ) {\n    this.buffer.write(string, offset, 'binary');\n    this.position = offset + string.length > this.position ? offset + string.length : this.position;\n    // offset = string.length;\n  } else if (\n    Object.prototype.toString.call(string) === '[object Uint8Array]' ||\n    (Object.prototype.toString.call(string) === '[object Array]' && typeof string !== 'string')\n  ) {\n    for (i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string[i];\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  } else if (typeof string === 'string') {\n    for (i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string.charCodeAt(i);\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  }\n};\n\n/**\n * Reads **length** bytes starting at **position**.\n *\n * @method\n * @param {number} position read from the given position in the Binary.\n * @param {number} length the number of bytes to read.\n * @return {Buffer}\n */\nBinary.prototype.read = function read(position, length) {\n  length = length && length > 0 ? length : this.position;\n\n  // Let's return the data based on the type we have\n  if (this.buffer['slice']) {\n    return this.buffer.slice(position, position + length);\n  } else {\n    // Create a buffer to keep the result\n    var buffer =\n      typeof Uint8Array !== 'undefined'\n        ? new Uint8Array(new ArrayBuffer(length))\n        : new Array(length);\n    for (var i = 0; i < length; i++) {\n      buffer[i] = this.buffer[position++];\n    }\n  }\n  // Return the buffer\n  return buffer;\n};\n\n/**\n * Returns the value of this binary as a string.\n *\n * @method\n * @return {string}\n */\nBinary.prototype.value = function value(asRaw) {\n  asRaw = asRaw == null ? false : asRaw;\n\n  // Optimize to serialize for the situation where the data == size of buffer\n  if (\n    asRaw &&\n    typeof Buffer !== 'undefined' &&\n    Buffer.isBuffer(this.buffer) &&\n    this.buffer.length === this.position\n  )\n    return this.buffer;\n\n  // If it's a node.js buffer object\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n    return asRaw\n      ? this.buffer.slice(0, this.position)\n      : this.buffer.toString('binary', 0, this.position);\n  } else {\n    if (asRaw) {\n      // we support the slice command use it\n      if (this.buffer['slice'] != null) {\n        return this.buffer.slice(0, this.position);\n      } else {\n        // Create a new buffer to copy content to\n        var newBuffer =\n          Object.prototype.toString.call(this.buffer) === '[object Uint8Array]'\n            ? new Uint8Array(new ArrayBuffer(this.position))\n            : new Array(this.position);\n        // Copy content\n        for (var i = 0; i < this.position; i++) {\n          newBuffer[i] = this.buffer[i];\n        }\n        // Return the buffer\n        return newBuffer;\n      }\n    } else {\n      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);\n    }\n  }\n};\n\n/**\n * Length.\n *\n * @method\n * @return {number} the length of the binary.\n */\nBinary.prototype.length = function length() {\n  return this.position;\n};\n\n/**\n * @ignore\n */\nBinary.prototype.toJSON = function() {\n  return this.buffer != null ? this.buffer.toString('base64') : '';\n};\n\n/**\n * @ignore\n */\nBinary.prototype.toString = function(format) {\n  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';\n};\n\n/**\n * Binary default subtype\n * @ignore\n */\nvar BSON_BINARY_SUBTYPE_DEFAULT = 0;\n\n/**\n * @ignore\n */\nvar writeStringToArray = function(data) {\n  // Create a buffer\n  var buffer =\n    typeof Uint8Array !== 'undefined'\n      ? new Uint8Array(new ArrayBuffer(data.length))\n      : new Array(data.length);\n  // Write the content to the buffer\n  for (var i = 0; i < data.length; i++) {\n    buffer[i] = data.charCodeAt(i);\n  }\n  // Write the string to the buffer\n  return buffer;\n};\n\n/**\n * Convert Array ot Uint8Array to Binary String\n *\n * @ignore\n */\nvar convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {\n  var result = '';\n  for (var i = startIndex; i < endIndex; i++) {\n    result = result + String.fromCharCode(byteArray[i]);\n  }\n  return result;\n};\n\nBinary.BUFFER_SIZE = 256;\n\n/**\n * Default BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_DEFAULT = 0;\n/**\n * Function BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_FUNCTION = 1;\n/**\n * Byte Array BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_BYTE_ARRAY = 2;\n/**\n * OLD UUID BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID_OLD = 3;\n/**\n * UUID BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID = 4;\n/**\n * MD5 BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_MD5 = 5;\n/**\n * User BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_USER_DEFINED = 128;\n\n/**\n * Expose.\n */\nmodule.exports = Binary;\nmodule.exports.Binary = Binary;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,OAAOA,MAAM,KAAK,WAAW,EAAE;EACjC,IAAIC,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAACD,MAAM,CAAC,CAAC;AACzC;;AAEA,IAAIE,KAAK,GAAGD,OAAO,CAAC,gBAAgB,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,MAAM,CAACC,MAAM,EAAEC,OAAO,EAAE;EAC/B,IAAI,EAAE,IAAI,YAAYF,MAAM,CAAC,EAAE,OAAO,IAAIA,MAAM,CAACC,MAAM,EAAEC,OAAO,CAAC;EAEjE,IACED,MAAM,IAAI,IAAI,IACd,EAAE,OAAOA,MAAM,KAAK,QAAQ,CAAC,IAC7B,CAACJ,MAAM,CAACM,QAAQ,CAACF,MAAM,CAAC,IACxB,EAAEA,MAAM,YAAYG,UAAU,CAAC,IAC/B,CAACC,KAAK,CAACC,OAAO,CAACL,MAAM,CAAC,EACtB;IACA,MAAM,IAAIM,KAAK,CAAC,mDAAmD,CAAC;EACtE;EAEA,IAAI,CAACC,SAAS,GAAG,QAAQ;EAEzB,IAAIP,MAAM,YAAYQ,MAAM,EAAE;IAC5B,IAAI,CAACC,QAAQ,GAAGT,MAAM;IACtB,IAAI,CAACU,QAAQ,GAAG,CAAC;EACnB,CAAC,MAAM;IACL,IAAI,CAACD,QAAQ,GAAGR,OAAO,IAAI,IAAI,GAAGU,2BAA2B,GAAGV,OAAO;IACvE,IAAI,CAACS,QAAQ,GAAG,CAAC;EACnB;EAEA,IAAIV,MAAM,IAAI,IAAI,IAAI,EAAEA,MAAM,YAAYQ,MAAM,CAAC,EAAE;IACjD;IACA,IAAI,OAAOR,MAAM,KAAK,QAAQ,EAAE;MAC9B;MACA,IAAI,OAAOJ,MAAM,KAAK,WAAW,EAAE;QACjC,IAAI,CAACI,MAAM,GAAGF,KAAK,CAACc,QAAQ,CAACZ,MAAM,CAAC;MACtC,CAAC,MAAM,IACL,OAAOG,UAAU,KAAK,WAAW,IACjCU,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAAChB,MAAM,CAAC,KAAK,gBAAgB,EAC3D;QACA,IAAI,CAACA,MAAM,GAAGiB,kBAAkB,CAACjB,MAAM,CAAC;MAC1C,CAAC,MAAM;QACL,MAAM,IAAIM,KAAK,CAAC,mDAAmD,CAAC;MACtE;IACF,CAAC,MAAM;MACL,IAAI,CAACN,MAAM,GAAGA,MAAM;IACtB;IACA,IAAI,CAACU,QAAQ,GAAGV,MAAM,CAACkB,MAAM;EAC/B,CAAC,MAAM;IACL,IAAI,OAAOtB,MAAM,KAAK,WAAW,EAAE;MACjC,IAAI,CAACI,MAAM,GAAGF,KAAK,CAACqB,WAAW,CAACpB,MAAM,CAACqB,WAAW,CAAC;IACrD,CAAC,MAAM,IAAI,OAAOjB,UAAU,KAAK,WAAW,EAAE;MAC5C,IAAI,CAACH,MAAM,GAAG,IAAIG,UAAU,CAAC,IAAIkB,WAAW,CAACtB,MAAM,CAACqB,WAAW,CAAC,CAAC;IACnE,CAAC,MAAM;MACL,IAAI,CAACpB,MAAM,GAAG,IAAII,KAAK,CAACL,MAAM,CAACqB,WAAW,CAAC;IAC7C;IACA;IACA,IAAI,CAACV,QAAQ,GAAG,CAAC;EACnB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAX,MAAM,CAACe,SAAS,CAACQ,GAAG,GAAG,SAASA,GAAG,CAACC,UAAU,EAAE;EAC9C;EACA,IAAIA,UAAU,CAAC,QAAQ,CAAC,IAAI,IAAI,IAAI,OAAOA,UAAU,KAAK,QAAQ,IAAIA,UAAU,CAACL,MAAM,KAAK,CAAC,EAC3F,MAAM,IAAIZ,KAAK,CAAC,2DAA2D,CAAC;EAC9E,IAAK,OAAOiB,UAAU,KAAK,QAAQ,IAAIA,UAAU,GAAG,CAAC,IAAKA,UAAU,GAAG,GAAG,EACxE,MAAM,IAAIjB,KAAK,CAAC,0DAA0D,CAAC;;EAE7E;EACA,IAAIkB,YAAY,GAAG,IAAI;EACvB,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;IAClCC,YAAY,GAAGD,UAAU,CAACE,UAAU,CAAC,CAAC,CAAC;EACzC,CAAC,MAAM,IAAIF,UAAU,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAE;IACvCC,YAAY,GAAGD,UAAU,CAAC,CAAC,CAAC;EAC9B,CAAC,MAAM;IACLC,YAAY,GAAGD,UAAU;EAC3B;EAEA,IAAI,IAAI,CAACvB,MAAM,CAACkB,MAAM,GAAG,IAAI,CAACR,QAAQ,EAAE;IACtC,IAAI,CAACV,MAAM,CAAC,IAAI,CAACU,QAAQ,EAAE,CAAC,GAAGc,YAAY;EAC7C,CAAC,MAAM;IACL,IAAI,OAAO5B,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACM,QAAQ,CAAC,IAAI,CAACF,MAAM,CAAC,EAAE;MACjE;MACA,IAAIA,MAAM,GAAGF,KAAK,CAACqB,WAAW,CAACpB,MAAM,CAACqB,WAAW,GAAG,IAAI,CAACpB,MAAM,CAACkB,MAAM,CAAC;MACvE;MACA,IAAI,CAAClB,MAAM,CAAC0B,IAAI,CAAC1B,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAACA,MAAM,CAACkB,MAAM,CAAC;MAClD,IAAI,CAAClB,MAAM,GAAGA,MAAM;MACpB,IAAI,CAACA,MAAM,CAAC,IAAI,CAACU,QAAQ,EAAE,CAAC,GAAGc,YAAY;IAC7C,CAAC,MAAM;MACLxB,MAAM,GAAG,IAAI;MACb;MACA,IAAIa,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAAC,IAAI,CAAChB,MAAM,CAAC,KAAK,qBAAqB,EAAE;QACzEA,MAAM,GAAG,IAAIG,UAAU,CAAC,IAAIkB,WAAW,CAACtB,MAAM,CAACqB,WAAW,GAAG,IAAI,CAACpB,MAAM,CAACkB,MAAM,CAAC,CAAC;MACnF,CAAC,MAAM;QACLlB,MAAM,GAAG,IAAII,KAAK,CAACL,MAAM,CAACqB,WAAW,GAAG,IAAI,CAACpB,MAAM,CAACkB,MAAM,CAAC;MAC7D;;MAEA;MACA,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC3B,MAAM,CAACkB,MAAM,EAAES,CAAC,EAAE,EAAE;QAC3C3B,MAAM,CAAC2B,CAAC,CAAC,GAAG,IAAI,CAAC3B,MAAM,CAAC2B,CAAC,CAAC;MAC5B;;MAEA;MACA,IAAI,CAAC3B,MAAM,GAAGA,MAAM;MACpB;MACA,IAAI,CAACA,MAAM,CAAC,IAAI,CAACU,QAAQ,EAAE,CAAC,GAAGc,YAAY;IAC7C;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzB,MAAM,CAACe,SAAS,CAACc,KAAK,GAAG,SAASA,KAAK,CAACC,MAAM,EAAEC,MAAM,EAAE;EACtDA,MAAM,GAAG,OAAOA,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAG,IAAI,CAACpB,QAAQ;;EAE5D;EACA,IAAI,IAAI,CAACV,MAAM,CAACkB,MAAM,GAAGY,MAAM,GAAGD,MAAM,CAACX,MAAM,EAAE;IAC/C,IAAIlB,MAAM,GAAG,IAAI;IACjB;IACA,IAAI,OAAOJ,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACM,QAAQ,CAAC,IAAI,CAACF,MAAM,CAAC,EAAE;MACjEA,MAAM,GAAGF,KAAK,CAACqB,WAAW,CAAC,IAAI,CAACnB,MAAM,CAACkB,MAAM,GAAGW,MAAM,CAACX,MAAM,CAAC;MAC9D,IAAI,CAAClB,MAAM,CAAC0B,IAAI,CAAC1B,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAACA,MAAM,CAACkB,MAAM,CAAC;IACpD,CAAC,MAAM,IAAIL,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAAC,IAAI,CAAChB,MAAM,CAAC,KAAK,qBAAqB,EAAE;MAChF;MACAA,MAAM,GAAG,IAAIG,UAAU,CAAC,IAAIkB,WAAW,CAAC,IAAI,CAACrB,MAAM,CAACkB,MAAM,GAAGW,MAAM,CAACX,MAAM,CAAC,CAAC;MAC5E;MACA,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACjB,QAAQ,EAAEiB,CAAC,EAAE,EAAE;QACtC3B,MAAM,CAAC2B,CAAC,CAAC,GAAG,IAAI,CAAC3B,MAAM,CAAC2B,CAAC,CAAC;MAC5B;IACF;;IAEA;IACA,IAAI,CAAC3B,MAAM,GAAGA,MAAM;EACtB;EAEA,IAAI,OAAOJ,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACM,QAAQ,CAAC2B,MAAM,CAAC,IAAIjC,MAAM,CAACM,QAAQ,CAAC,IAAI,CAACF,MAAM,CAAC,EAAE;IAC5F6B,MAAM,CAACH,IAAI,CAAC,IAAI,CAAC1B,MAAM,EAAE8B,MAAM,EAAE,CAAC,EAAED,MAAM,CAACX,MAAM,CAAC;IAClD,IAAI,CAACR,QAAQ,GAAGoB,MAAM,GAAGD,MAAM,CAACX,MAAM,GAAG,IAAI,CAACR,QAAQ,GAAGoB,MAAM,GAAGD,MAAM,CAACX,MAAM,GAAG,IAAI,CAACR,QAAQ;IAC/F;EACF,CAAC,MAAM,IACL,OAAOd,MAAM,KAAK,WAAW,IAC7B,OAAOiC,MAAM,KAAK,QAAQ,IAC1BjC,MAAM,CAACM,QAAQ,CAAC,IAAI,CAACF,MAAM,CAAC,EAC5B;IACA,IAAI,CAACA,MAAM,CAAC4B,KAAK,CAACC,MAAM,EAAEC,MAAM,EAAE,QAAQ,CAAC;IAC3C,IAAI,CAACpB,QAAQ,GAAGoB,MAAM,GAAGD,MAAM,CAACX,MAAM,GAAG,IAAI,CAACR,QAAQ,GAAGoB,MAAM,GAAGD,MAAM,CAACX,MAAM,GAAG,IAAI,CAACR,QAAQ;IAC/F;EACF,CAAC,MAAM,IACLG,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACa,MAAM,CAAC,KAAK,qBAAqB,IAC/DhB,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACa,MAAM,CAAC,KAAK,gBAAgB,IAAI,OAAOA,MAAM,KAAK,QAAS,EAC3F;IACA,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAACX,MAAM,EAAES,CAAC,EAAE,EAAE;MAClC,IAAI,CAAC3B,MAAM,CAAC8B,MAAM,EAAE,CAAC,GAAGD,MAAM,CAACF,CAAC,CAAC;IACnC;IAEA,IAAI,CAACjB,QAAQ,GAAGoB,MAAM,GAAG,IAAI,CAACpB,QAAQ,GAAGoB,MAAM,GAAG,IAAI,CAACpB,QAAQ;EACjE,CAAC,MAAM,IAAI,OAAOmB,MAAM,KAAK,QAAQ,EAAE;IACrC,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAACX,MAAM,EAAES,CAAC,EAAE,EAAE;MAClC,IAAI,CAAC3B,MAAM,CAAC8B,MAAM,EAAE,CAAC,GAAGD,MAAM,CAACJ,UAAU,CAACE,CAAC,CAAC;IAC9C;IAEA,IAAI,CAACjB,QAAQ,GAAGoB,MAAM,GAAG,IAAI,CAACpB,QAAQ,GAAGoB,MAAM,GAAG,IAAI,CAACpB,QAAQ;EACjE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,MAAM,CAACe,SAAS,CAACiB,IAAI,GAAG,SAASA,IAAI,CAACrB,QAAQ,EAAEQ,MAAM,EAAE;EACtDA,MAAM,GAAGA,MAAM,IAAIA,MAAM,GAAG,CAAC,GAAGA,MAAM,GAAG,IAAI,CAACR,QAAQ;;EAEtD;EACA,IAAI,IAAI,CAACV,MAAM,CAAC,OAAO,CAAC,EAAE;IACxB,OAAO,IAAI,CAACA,MAAM,CAACgC,KAAK,CAACtB,QAAQ,EAAEA,QAAQ,GAAGQ,MAAM,CAAC;EACvD,CAAC,MAAM;IACL;IACA,IAAIlB,MAAM,GACR,OAAOG,UAAU,KAAK,WAAW,GAC7B,IAAIA,UAAU,CAAC,IAAIkB,WAAW,CAACH,MAAM,CAAC,CAAC,GACvC,IAAId,KAAK,CAACc,MAAM,CAAC;IACvB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,EAAES,CAAC,EAAE,EAAE;MAC/B3B,MAAM,CAAC2B,CAAC,CAAC,GAAG,IAAI,CAAC3B,MAAM,CAACU,QAAQ,EAAE,CAAC;IACrC;EACF;EACA;EACA,OAAOV,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAD,MAAM,CAACe,SAAS,CAACmB,KAAK,GAAG,SAASA,KAAK,CAACC,KAAK,EAAE;EAC7CA,KAAK,GAAGA,KAAK,IAAI,IAAI,GAAG,KAAK,GAAGA,KAAK;;EAErC;EACA,IACEA,KAAK,IACL,OAAOtC,MAAM,KAAK,WAAW,IAC7BA,MAAM,CAACM,QAAQ,CAAC,IAAI,CAACF,MAAM,CAAC,IAC5B,IAAI,CAACA,MAAM,CAACkB,MAAM,KAAK,IAAI,CAACR,QAAQ,EAEpC,OAAO,IAAI,CAACV,MAAM;;EAEpB;EACA,IAAI,OAAOJ,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACM,QAAQ,CAAC,IAAI,CAACF,MAAM,CAAC,EAAE;IACjE,OAAOkC,KAAK,GACR,IAAI,CAAClC,MAAM,CAACgC,KAAK,CAAC,CAAC,EAAE,IAAI,CAACtB,QAAQ,CAAC,GACnC,IAAI,CAACV,MAAM,CAACe,QAAQ,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAACL,QAAQ,CAAC;EACtD,CAAC,MAAM;IACL,IAAIwB,KAAK,EAAE;MACT;MACA,IAAI,IAAI,CAAClC,MAAM,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE;QAChC,OAAO,IAAI,CAACA,MAAM,CAACgC,KAAK,CAAC,CAAC,EAAE,IAAI,CAACtB,QAAQ,CAAC;MAC5C,CAAC,MAAM;QACL;QACA,IAAIyB,SAAS,GACXtB,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAAC,IAAI,CAAChB,MAAM,CAAC,KAAK,qBAAqB,GACjE,IAAIG,UAAU,CAAC,IAAIkB,WAAW,CAAC,IAAI,CAACX,QAAQ,CAAC,CAAC,GAC9C,IAAIN,KAAK,CAAC,IAAI,CAACM,QAAQ,CAAC;QAC9B;QACA,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACjB,QAAQ,EAAEiB,CAAC,EAAE,EAAE;UACtCQ,SAAS,CAACR,CAAC,CAAC,GAAG,IAAI,CAAC3B,MAAM,CAAC2B,CAAC,CAAC;QAC/B;QACA;QACA,OAAOQ,SAAS;MAClB;IACF,CAAC,MAAM;MACL,OAAOC,8BAA8B,CAAC,IAAI,CAACpC,MAAM,EAAE,CAAC,EAAE,IAAI,CAACU,QAAQ,CAAC;IACtE;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAX,MAAM,CAACe,SAAS,CAACI,MAAM,GAAG,SAASA,MAAM,GAAG;EAC1C,OAAO,IAAI,CAACR,QAAQ;AACtB,CAAC;;AAED;AACA;AACA;AACAX,MAAM,CAACe,SAAS,CAACuB,MAAM,GAAG,YAAW;EACnC,OAAO,IAAI,CAACrC,MAAM,IAAI,IAAI,GAAG,IAAI,CAACA,MAAM,CAACe,QAAQ,CAAC,QAAQ,CAAC,GAAG,EAAE;AAClE,CAAC;;AAED;AACA;AACA;AACAhB,MAAM,CAACe,SAAS,CAACC,QAAQ,GAAG,UAASuB,MAAM,EAAE;EAC3C,OAAO,IAAI,CAACtC,MAAM,IAAI,IAAI,GAAG,IAAI,CAACA,MAAM,CAACgC,KAAK,CAAC,CAAC,EAAE,IAAI,CAACtB,QAAQ,CAAC,CAACK,QAAQ,CAACuB,MAAM,CAAC,GAAG,EAAE;AACxF,CAAC;;AAED;AACA;AACA;AACA;AACA,IAAI3B,2BAA2B,GAAG,CAAC;;AAEnC;AACA;AACA;AACA,IAAIM,kBAAkB,GAAG,UAASsB,IAAI,EAAE;EACtC;EACA,IAAIvC,MAAM,GACR,OAAOG,UAAU,KAAK,WAAW,GAC7B,IAAIA,UAAU,CAAC,IAAIkB,WAAW,CAACkB,IAAI,CAACrB,MAAM,CAAC,CAAC,GAC5C,IAAId,KAAK,CAACmC,IAAI,CAACrB,MAAM,CAAC;EAC5B;EACA,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACrB,MAAM,EAAES,CAAC,EAAE,EAAE;IACpC3B,MAAM,CAAC2B,CAAC,CAAC,GAAGY,IAAI,CAACd,UAAU,CAACE,CAAC,CAAC;EAChC;EACA;EACA,OAAO3B,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,IAAIoC,8BAA8B,GAAG,UAASI,SAAS,EAAEC,UAAU,EAAEC,QAAQ,EAAE;EAC7E,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,IAAIhB,CAAC,GAAGc,UAAU,EAAEd,CAAC,GAAGe,QAAQ,EAAEf,CAAC,EAAE,EAAE;IAC1CgB,MAAM,GAAGA,MAAM,GAAGC,MAAM,CAACC,YAAY,CAACL,SAAS,CAACb,CAAC,CAAC,CAAC;EACrD;EACA,OAAOgB,MAAM;AACf,CAAC;AAED5C,MAAM,CAACqB,WAAW,GAAG,GAAG;;AAExB;AACA;AACA;AACA;AACA;AACArB,MAAM,CAAC+C,eAAe,GAAG,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA/C,MAAM,CAACgD,gBAAgB,GAAG,CAAC;AAC3B;AACA;AACA;AACA;AACA;AACAhD,MAAM,CAACiD,kBAAkB,GAAG,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACAjD,MAAM,CAACkD,gBAAgB,GAAG,CAAC;AAC3B;AACA;AACA;AACA;AACA;AACAlD,MAAM,CAACmD,YAAY,GAAG,CAAC;AACvB;AACA;AACA;AACA;AACA;AACAnD,MAAM,CAACoD,WAAW,GAAG,CAAC;AACtB;AACA;AACA;AACA;AACA;AACApD,MAAM,CAACqD,oBAAoB,GAAG,GAAG;;AAEjC;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAGvD,MAAM;AACvBsD,MAAM,CAACC,OAAO,CAACvD,MAAM,GAAGA,MAAM"},"metadata":{},"sourceType":"script"}