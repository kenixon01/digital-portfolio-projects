{"ast":null,"code":"'use strict';\n\nvar Long = require('../long').Long,\n  Double = require('../double').Double,\n  Timestamp = require('../timestamp').Timestamp,\n  ObjectID = require('../objectid').ObjectID,\n  Symbol = require('../symbol').Symbol,\n  Code = require('../code').Code,\n  MinKey = require('../min_key').MinKey,\n  MaxKey = require('../max_key').MaxKey,\n  Decimal128 = require('../decimal128'),\n  Int32 = require('../int_32'),\n  DBRef = require('../db_ref').DBRef,\n  BSONRegExp = require('../regexp').BSONRegExp,\n  Binary = require('../binary').Binary;\nvar utils = require('./utils');\nvar deserialize = function (buffer, options, isArray) {\n  options = options == null ? {} : options;\n  var index = options && options.index ? options.index : 0;\n  // Read the document size\n  var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n\n  // Ensure buffer is valid size\n  if (size < 5 || buffer.length < size || size + index > buffer.length) {\n    throw new Error('corrupt bson message');\n  }\n\n  // Illegal end value\n  if (buffer[index + size - 1] !== 0) {\n    throw new Error(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  }\n\n  // Start deserializtion\n  return deserializeObject(buffer, index, options, isArray);\n};\nvar deserializeObject = function (buffer, index, options, isArray) {\n  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\n  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\n  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];\n  if (!cacheFunctionsCrc32) var crc32 = null;\n  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n\n  // Return raw bson buffer instead of parsing it\n  var raw = options['raw'] == null ? false : options['raw'];\n\n  // Return BSONRegExp objects instead of native regular expressions\n  var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n\n  // Controls the promotion of values vs wrapper classes\n  var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\n  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\n  var promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];\n\n  // Set the start index\n  var startIndex = index;\n\n  // Validate that we have at least 4 bytes of buffer\n  if (buffer.length < 5) throw new Error('corrupt bson message < 5 bytes long');\n\n  // Read the document size\n  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\n  // Ensure buffer is valid size\n  if (size < 5 || size > buffer.length) throw new Error('corrupt bson message');\n\n  // Create holding object\n  var object = isArray ? [] : {};\n  // Used for arrays to skip having to perform utf8 decoding\n  var arrayIndex = 0;\n  var done = false;\n\n  // While we have more left data left keep parsing\n  // while (buffer[index + 1] !== 0) {\n  while (!done) {\n    // Read the type\n    var elementType = buffer[index++];\n    // If we get a zero it's the last byte, exit\n    if (elementType === 0) break;\n\n    // Get the start search index\n    var i = index;\n    // Locate the end of the c string\n    while (buffer[i] !== 0x00 && i < buffer.length) {\n      i++;\n    }\n\n    // If are at the end of the buffer there is a problem with the document\n    if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n    var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\n    index = i + 1;\n    if (elementType === BSON.BSON_DATA_STRING) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n      object[name] = buffer.toString('utf8', index, index + stringSize - 1);\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_OID) {\n      var oid = utils.allocBuffer(12);\n      buffer.copy(oid, 0, index, index + 12);\n      object[name] = new ObjectID(oid);\n      index = index + 12;\n    } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {\n      object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n    } else if (elementType === BSON.BSON_DATA_INT) {\n      object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {\n      object[name] = new Double(buffer.readDoubleLE(index));\n      index = index + 8;\n    } else if (elementType === BSON.BSON_DATA_NUMBER) {\n      object[name] = buffer.readDoubleLE(index);\n      index = index + 8;\n    } else if (elementType === BSON.BSON_DATA_DATE) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType === BSON.BSON_DATA_BOOLEAN) {\n      if (buffer[index] !== 0 && buffer[index] !== 1) throw new Error('illegal boolean type value');\n      object[name] = buffer[index++] === 1;\n    } else if (elementType === BSON.BSON_DATA_OBJECT) {\n      var _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      if (objectSize <= 0 || objectSize > buffer.length - index) throw new Error('bad embedded document length in bson');\n\n      // We have a raw value\n      if (raw) {\n        object[name] = buffer.slice(index, index + objectSize);\n      } else {\n        object[name] = deserializeObject(buffer, _index, options, false);\n      }\n      index = index + objectSize;\n    } else if (elementType === BSON.BSON_DATA_ARRAY) {\n      _index = index;\n      objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      var arrayOptions = options;\n\n      // Stop index\n      var stopIndex = index + objectSize;\n\n      // All elements of array to be returned as raw bson\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {};\n        for (var n in options) arrayOptions[n] = options[n];\n        arrayOptions['raw'] = true;\n      }\n      object[name] = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n      if (buffer[index - 1] !== 0) throw new Error('invalid array terminator byte');\n      if (index !== stopIndex) throw new Error('corrupted array bson');\n    } else if (elementType === BSON.BSON_DATA_UNDEFINED) {\n      object[name] = undefined;\n    } else if (elementType === BSON.BSON_DATA_NULL) {\n      object[name] = null;\n    } else if (elementType === BSON.BSON_DATA_LONG) {\n      // Unpack the low and high bits\n      lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var long = new Long(lowBits, highBits);\n      // Promote the long if possible\n      if (promoteLongs && promoteValues === true) {\n        object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        object[name] = long;\n      }\n    } else if (elementType === BSON.BSON_DATA_DECIMAL128) {\n      // Buffer to contain the decimal bytes\n      var bytes = utils.allocBuffer(16);\n      // Copy the next 16 bytes into the bytes buffer\n      buffer.copy(bytes, 0, index, index + 16);\n      // Update index\n      index = index + 16;\n      // Assign the new Decimal128 value\n      var decimal128 = new Decimal128(bytes);\n      // If we have an alternative mapper use that\n      object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;\n    } else if (elementType === BSON.BSON_DATA_BINARY) {\n      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var totalBinarySize = binarySize;\n      var subType = buffer[index++];\n\n      // Did we have a negative binary size, throw\n      if (binarySize < 0) throw new Error('Negative binary type element size found');\n\n      // Is the length longer than the document\n      if (binarySize > buffer.length) throw new Error('Binary type size larger than document size');\n\n      // Decode as raw Buffer object if options specifies it\n      if (buffer['slice'] != null) {\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n        if (promoteBuffers && promoteValues) {\n          object[name] = buffer.slice(index, index + binarySize);\n        } else {\n          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);\n        }\n      } else {\n        var _buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n\n        // Copy the data\n        for (i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer[index + i];\n        }\n        if (promoteBuffers && promoteValues) {\n          object[name] = _buffer;\n        } else {\n          object[name] = new Binary(_buffer, subType);\n        }\n      }\n\n      // Update the index\n      index = index + binarySize;\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      var source = buffer.toString('utf8', index, i);\n      // Create the regexp\n      index = i + 1;\n\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      var regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n      // For each option add the corresponding one for javascript\n      var optionsArray = new Array(regExpOptions.length);\n\n      // Parse options\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n      object[name] = new RegExp(source, optionsArray.join(''));\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      source = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n      // Set the object\n      object[name] = new BSONRegExp(source, regExpOptions);\n    } else if (elementType === BSON.BSON_DATA_SYMBOL) {\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {\n      lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Timestamp(lowBits, highBits);\n    } else if (elementType === BSON.BSON_DATA_MIN_KEY) {\n      object[name] = new MinKey();\n    } else if (elementType === BSON.BSON_DATA_MAX_KEY) {\n      object[name] = new MaxKey();\n    } else if (elementType === BSON.BSON_DATA_CODE) {\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1);\n\n      // If we are evaluating the functions\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n      } else {\n        object[name] = new Code(functionString);\n      }\n\n      // Update parse index position\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {\n      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\n      // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new Error('code_w_scope total size shorter minimum expected length');\n      }\n\n      // Get the code string size\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      // Check if we have a valid string\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n\n      // Javascript function\n      functionString = buffer.toString('utf8', index, index + stringSize - 1);\n      // Update parse index position\n      index = index + stringSize;\n      // Parse the element\n      _index = index;\n      // Decode the size of the object document\n      objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      // Decode the scope object\n      var scopeObject = deserializeObject(buffer, _index, options, false);\n      // Adjust the index\n      index = index + objectSize;\n\n      // Check if field length is to short\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to short, truncating scope');\n      }\n\n      // Check if totalSize field is to long\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to long, clips outer document');\n      }\n\n      // If we are evaluating the functions\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n        object[name].scope = scopeObject;\n      } else {\n        object[name] = new Code(functionString, scopeObject);\n      }\n    } else if (elementType === BSON.BSON_DATA_DBPOINTER) {\n      // Get the code string size\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      // Check if we have a valid string\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n      // Namespace\n      var namespace = buffer.toString('utf8', index, index + stringSize - 1);\n      // Update parse index position\n      index = index + stringSize;\n\n      // Read the oid\n      var oidBuffer = utils.allocBuffer(12);\n      buffer.copy(oidBuffer, 0, index, index + 12);\n      oid = new ObjectID(oidBuffer);\n\n      // Update the index\n      index = index + 12;\n\n      // Split the namespace\n      var parts = namespace.split('.');\n      var db = parts.shift();\n      var collection = parts.join('.');\n      // Upgrade to DBRef type\n      object[name] = new DBRef(collection, oid, db);\n    } else {\n      throw new Error('Detected unknown BSON type ' + elementType.toString(16) + ' for fieldname \"' + name + '\", are you using the latest BSON parser');\n    }\n  }\n\n  // Check if the deserialization was against a valid array/object\n  if (size !== index - startIndex) {\n    if (isArray) throw new Error('corrupt array bson');\n    throw new Error('corrupt object bson');\n  }\n\n  // Check if we have a db ref object\n  if (object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);\n  return object;\n};\n\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\nvar isolateEvalWithHash = function (functionCache, hash, functionString, object) {\n  // Contains the value we are going to set\n  var value = null;\n\n  // Check for cache hit, eval if missing and return cached function\n  if (functionCache[hash] == null) {\n    eval('value = ' + functionString);\n    functionCache[hash] = value;\n  }\n  // Set the object\n  return functionCache[hash].bind(object);\n};\n\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\nvar isolateEval = function (functionString) {\n  // Contains the value we are going to set\n  var value = null;\n  // Eval the function\n  eval('value = ' + functionString);\n  return value;\n};\nvar BSON = {};\n\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\nvar functionCache = BSON.functionCache = {};\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\nBSON.BSON_DATA_BINARY = 5;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_DBPOINTER\n **/\nBSON.BSON_DATA_DBPOINTER = 12;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\n\n// BSON MAX VALUES\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63);\n\n// JS MAX PRECISE VALUES\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n\n// Internal long versions\nvar JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\nvar JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = deserialize;","map":{"version":3,"names":["Long","require","Double","Timestamp","ObjectID","Symbol","Code","MinKey","MaxKey","Decimal128","Int32","DBRef","BSONRegExp","Binary","utils","deserialize","buffer","options","isArray","index","size","length","Error","deserializeObject","evalFunctions","cacheFunctions","cacheFunctionsCrc32","crc32","fieldsAsRaw","raw","bsonRegExp","promoteBuffers","promoteLongs","promoteValues","startIndex","object","arrayIndex","done","elementType","i","name","toString","BSON","BSON_DATA_STRING","stringSize","BSON_DATA_OID","oid","allocBuffer","copy","BSON_DATA_INT","BSON_DATA_NUMBER","readDoubleLE","BSON_DATA_DATE","lowBits","highBits","Date","toNumber","BSON_DATA_BOOLEAN","BSON_DATA_OBJECT","_index","objectSize","slice","BSON_DATA_ARRAY","arrayOptions","stopIndex","n","BSON_DATA_UNDEFINED","undefined","BSON_DATA_NULL","BSON_DATA_LONG","long","lessThanOrEqual","JS_INT_MAX_LONG","greaterThanOrEqual","JS_INT_MIN_LONG","BSON_DATA_DECIMAL128","bytes","decimal128","toObject","BSON_DATA_BINARY","binarySize","totalBinarySize","subType","SUBTYPE_BYTE_ARRAY","_buffer","Uint8Array","ArrayBuffer","Array","BSON_DATA_REGEXP","source","regExpOptions","optionsArray","RegExp","join","BSON_DATA_SYMBOL","BSON_DATA_TIMESTAMP","BSON_DATA_MIN_KEY","BSON_DATA_MAX_KEY","BSON_DATA_CODE","functionString","hash","isolateEvalWithHash","functionCache","isolateEval","BSON_DATA_CODE_W_SCOPE","totalSize","scopeObject","scope","BSON_DATA_DBPOINTER","namespace","oidBuffer","parts","split","db","shift","collection","value","eval","bind","BSON_BINARY_SUBTYPE_DEFAULT","BSON_BINARY_SUBTYPE_FUNCTION","BSON_BINARY_SUBTYPE_BYTE_ARRAY","BSON_BINARY_SUBTYPE_UUID","BSON_BINARY_SUBTYPE_MD5","BSON_BINARY_SUBTYPE_USER_DEFINED","BSON_INT32_MAX","BSON_INT32_MIN","BSON_INT64_MAX","Math","pow","BSON_INT64_MIN","JS_INT_MAX","JS_INT_MIN","fromNumber","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/bson/lib/bson/parser/deserializer.js"],"sourcesContent":["'use strict';\n\nvar Long = require('../long').Long,\n  Double = require('../double').Double,\n  Timestamp = require('../timestamp').Timestamp,\n  ObjectID = require('../objectid').ObjectID,\n  Symbol = require('../symbol').Symbol,\n  Code = require('../code').Code,\n  MinKey = require('../min_key').MinKey,\n  MaxKey = require('../max_key').MaxKey,\n  Decimal128 = require('../decimal128'),\n  Int32 = require('../int_32'),\n  DBRef = require('../db_ref').DBRef,\n  BSONRegExp = require('../regexp').BSONRegExp,\n  Binary = require('../binary').Binary;\n\nvar utils = require('./utils');\n\nvar deserialize = function(buffer, options, isArray) {\n  options = options == null ? {} : options;\n  var index = options && options.index ? options.index : 0;\n  // Read the document size\n  var size =\n    buffer[index] |\n    (buffer[index + 1] << 8) |\n    (buffer[index + 2] << 16) |\n    (buffer[index + 3] << 24);\n\n  // Ensure buffer is valid size\n  if (size < 5 || buffer.length < size || size + index > buffer.length) {\n    throw new Error('corrupt bson message');\n  }\n\n  // Illegal end value\n  if (buffer[index + size - 1] !== 0) {\n    throw new Error(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  }\n\n  // Start deserializtion\n  return deserializeObject(buffer, index, options, isArray);\n};\n\nvar deserializeObject = function(buffer, index, options, isArray) {\n  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\n  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\n  var cacheFunctionsCrc32 =\n    options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];\n\n  if (!cacheFunctionsCrc32) var crc32 = null;\n\n  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n\n  // Return raw bson buffer instead of parsing it\n  var raw = options['raw'] == null ? false : options['raw'];\n\n  // Return BSONRegExp objects instead of native regular expressions\n  var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n\n  // Controls the promotion of values vs wrapper classes\n  var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\n  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\n  var promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];\n\n  // Set the start index\n  var startIndex = index;\n\n  // Validate that we have at least 4 bytes of buffer\n  if (buffer.length < 5) throw new Error('corrupt bson message < 5 bytes long');\n\n  // Read the document size\n  var size =\n    buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n\n  // Ensure buffer is valid size\n  if (size < 5 || size > buffer.length) throw new Error('corrupt bson message');\n\n  // Create holding object\n  var object = isArray ? [] : {};\n  // Used for arrays to skip having to perform utf8 decoding\n  var arrayIndex = 0;\n\n  var done = false;\n\n  // While we have more left data left keep parsing\n  // while (buffer[index + 1] !== 0) {\n  while (!done) {\n    // Read the type\n    var elementType = buffer[index++];\n    // If we get a zero it's the last byte, exit\n    if (elementType === 0) break;\n\n    // Get the start search index\n    var i = index;\n    // Locate the end of the c string\n    while (buffer[i] !== 0x00 && i < buffer.length) {\n      i++;\n    }\n\n    // If are at the end of the buffer there is a problem with the document\n    if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n    var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\n\n    index = i + 1;\n\n    if (elementType === BSON.BSON_DATA_STRING) {\n      var stringSize =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      )\n        throw new Error('bad string length in bson');\n      object[name] = buffer.toString('utf8', index, index + stringSize - 1);\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_OID) {\n      var oid = utils.allocBuffer(12);\n      buffer.copy(oid, 0, index, index + 12);\n      object[name] = new ObjectID(oid);\n      index = index + 12;\n    } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {\n      object[name] = new Int32(\n        buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24)\n      );\n    } else if (elementType === BSON.BSON_DATA_INT) {\n      object[name] =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n    } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {\n      object[name] = new Double(buffer.readDoubleLE(index));\n      index = index + 8;\n    } else if (elementType === BSON.BSON_DATA_NUMBER) {\n      object[name] = buffer.readDoubleLE(index);\n      index = index + 8;\n    } else if (elementType === BSON.BSON_DATA_DATE) {\n      var lowBits =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      var highBits =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      object[name] = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType === BSON.BSON_DATA_BOOLEAN) {\n      if (buffer[index] !== 0 && buffer[index] !== 1) throw new Error('illegal boolean type value');\n      object[name] = buffer[index++] === 1;\n    } else if (elementType === BSON.BSON_DATA_OBJECT) {\n      var _index = index;\n      var objectSize =\n        buffer[index] |\n        (buffer[index + 1] << 8) |\n        (buffer[index + 2] << 16) |\n        (buffer[index + 3] << 24);\n      if (objectSize <= 0 || objectSize > buffer.length - index)\n        throw new Error('bad embedded document length in bson');\n\n      // We have a raw value\n      if (raw) {\n        object[name] = buffer.slice(index, index + objectSize);\n      } else {\n        object[name] = deserializeObject(buffer, _index, options, false);\n      }\n\n      index = index + objectSize;\n    } else if (elementType === BSON.BSON_DATA_ARRAY) {\n      _index = index;\n      objectSize =\n        buffer[index] |\n        (buffer[index + 1] << 8) |\n        (buffer[index + 2] << 16) |\n        (buffer[index + 3] << 24);\n      var arrayOptions = options;\n\n      // Stop index\n      var stopIndex = index + objectSize;\n\n      // All elements of array to be returned as raw bson\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {};\n        for (var n in options) arrayOptions[n] = options[n];\n        arrayOptions['raw'] = true;\n      }\n\n      object[name] = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n\n      if (buffer[index - 1] !== 0) throw new Error('invalid array terminator byte');\n      if (index !== stopIndex) throw new Error('corrupted array bson');\n    } else if (elementType === BSON.BSON_DATA_UNDEFINED) {\n      object[name] = undefined;\n    } else if (elementType === BSON.BSON_DATA_NULL) {\n      object[name] = null;\n    } else if (elementType === BSON.BSON_DATA_LONG) {\n      // Unpack the low and high bits\n      lowBits =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      highBits =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      var long = new Long(lowBits, highBits);\n      // Promote the long if possible\n      if (promoteLongs && promoteValues === true) {\n        object[name] =\n          long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\n            ? long.toNumber()\n            : long;\n      } else {\n        object[name] = long;\n      }\n    } else if (elementType === BSON.BSON_DATA_DECIMAL128) {\n      // Buffer to contain the decimal bytes\n      var bytes = utils.allocBuffer(16);\n      // Copy the next 16 bytes into the bytes buffer\n      buffer.copy(bytes, 0, index, index + 16);\n      // Update index\n      index = index + 16;\n      // Assign the new Decimal128 value\n      var decimal128 = new Decimal128(bytes);\n      // If we have an alternative mapper use that\n      object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;\n    } else if (elementType === BSON.BSON_DATA_BINARY) {\n      var binarySize =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      var totalBinarySize = binarySize;\n      var subType = buffer[index++];\n\n      // Did we have a negative binary size, throw\n      if (binarySize < 0) throw new Error('Negative binary type element size found');\n\n      // Is the length longer than the document\n      if (binarySize > buffer.length) throw new Error('Binary type size larger than document size');\n\n      // Decode as raw Buffer object if options specifies it\n      if (buffer['slice'] != null) {\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize =\n            buffer[index++] |\n            (buffer[index++] << 8) |\n            (buffer[index++] << 16) |\n            (buffer[index++] << 24);\n          if (binarySize < 0)\n            throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4)\n            throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4)\n            throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n\n        if (promoteBuffers && promoteValues) {\n          object[name] = buffer.slice(index, index + binarySize);\n        } else {\n          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);\n        }\n      } else {\n        var _buffer =\n          typeof Uint8Array !== 'undefined'\n            ? new Uint8Array(new ArrayBuffer(binarySize))\n            : new Array(binarySize);\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize =\n            buffer[index++] |\n            (buffer[index++] << 8) |\n            (buffer[index++] << 16) |\n            (buffer[index++] << 24);\n          if (binarySize < 0)\n            throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4)\n            throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4)\n            throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n\n        // Copy the data\n        for (i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer[index + i];\n        }\n\n        if (promoteBuffers && promoteValues) {\n          object[name] = _buffer;\n        } else {\n          object[name] = new Binary(_buffer, subType);\n        }\n      }\n\n      // Update the index\n      index = index + binarySize;\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      var source = buffer.toString('utf8', index, i);\n      // Create the regexp\n      index = i + 1;\n\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      var regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n      // For each option add the corresponding one for javascript\n      var optionsArray = new Array(regExpOptions.length);\n\n      // Parse options\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n\n      object[name] = new RegExp(source, optionsArray.join(''));\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      source = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n      // Return the C string\n      regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n      // Set the object\n      object[name] = new BSONRegExp(source, regExpOptions);\n    } else if (elementType === BSON.BSON_DATA_SYMBOL) {\n      stringSize =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      )\n        throw new Error('bad string length in bson');\n      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {\n      lowBits =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      highBits =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      object[name] = new Timestamp(lowBits, highBits);\n    } else if (elementType === BSON.BSON_DATA_MIN_KEY) {\n      object[name] = new MinKey();\n    } else if (elementType === BSON.BSON_DATA_MAX_KEY) {\n      object[name] = new MaxKey();\n    } else if (elementType === BSON.BSON_DATA_CODE) {\n      stringSize =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      )\n        throw new Error('bad string length in bson');\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1);\n\n      // If we are evaluating the functions\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n      } else {\n        object[name] = new Code(functionString);\n      }\n\n      // Update parse index position\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {\n      var totalSize =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n\n      // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new Error('code_w_scope total size shorter minimum expected length');\n      }\n\n      // Get the code string size\n      stringSize =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      // Check if we have a valid string\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      )\n        throw new Error('bad string length in bson');\n\n      // Javascript function\n      functionString = buffer.toString('utf8', index, index + stringSize - 1);\n      // Update parse index position\n      index = index + stringSize;\n      // Parse the element\n      _index = index;\n      // Decode the size of the object document\n      objectSize =\n        buffer[index] |\n        (buffer[index + 1] << 8) |\n        (buffer[index + 2] << 16) |\n        (buffer[index + 3] << 24);\n      // Decode the scope object\n      var scopeObject = deserializeObject(buffer, _index, options, false);\n      // Adjust the index\n      index = index + objectSize;\n\n      // Check if field length is to short\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to short, truncating scope');\n      }\n\n      // Check if totalSize field is to long\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to long, clips outer document');\n      }\n\n      // If we are evaluating the functions\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n\n        object[name].scope = scopeObject;\n      } else {\n        object[name] = new Code(functionString, scopeObject);\n      }\n    } else if (elementType === BSON.BSON_DATA_DBPOINTER) {\n      // Get the code string size\n      stringSize =\n        buffer[index++] |\n        (buffer[index++] << 8) |\n        (buffer[index++] << 16) |\n        (buffer[index++] << 24);\n      // Check if we have a valid string\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      )\n        throw new Error('bad string length in bson');\n      // Namespace\n      var namespace = buffer.toString('utf8', index, index + stringSize - 1);\n      // Update parse index position\n      index = index + stringSize;\n\n      // Read the oid\n      var oidBuffer = utils.allocBuffer(12);\n      buffer.copy(oidBuffer, 0, index, index + 12);\n      oid = new ObjectID(oidBuffer);\n\n      // Update the index\n      index = index + 12;\n\n      // Split the namespace\n      var parts = namespace.split('.');\n      var db = parts.shift();\n      var collection = parts.join('.');\n      // Upgrade to DBRef type\n      object[name] = new DBRef(collection, oid, db);\n    } else {\n      throw new Error(\n        'Detected unknown BSON type ' +\n          elementType.toString(16) +\n          ' for fieldname \"' +\n          name +\n          '\", are you using the latest BSON parser'\n      );\n    }\n  }\n\n  // Check if the deserialization was against a valid array/object\n  if (size !== index - startIndex) {\n    if (isArray) throw new Error('corrupt array bson');\n    throw new Error('corrupt object bson');\n  }\n\n  // Check if we have a db ref object\n  if (object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);\n  return object;\n};\n\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\nvar isolateEvalWithHash = function(functionCache, hash, functionString, object) {\n  // Contains the value we are going to set\n  var value = null;\n\n  // Check for cache hit, eval if missing and return cached function\n  if (functionCache[hash] == null) {\n    eval('value = ' + functionString);\n    functionCache[hash] = value;\n  }\n  // Set the object\n  return functionCache[hash].bind(object);\n};\n\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\nvar isolateEval = function(functionString) {\n  // Contains the value we are going to set\n  var value = null;\n  // Eval the function\n  eval('value = ' + functionString);\n  return value;\n};\n\nvar BSON = {};\n\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\nvar functionCache = (BSON.functionCache = {});\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\nBSON.BSON_DATA_BINARY = 5;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_DBPOINTER\n **/\nBSON.BSON_DATA_DBPOINTER = 12;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\n\n// BSON MAX VALUES\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\n\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63);\n\n// JS MAX PRECISE VALUES\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n\n// Internal long versions\nvar JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\nvar JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = deserialize;\n"],"mappings":"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AC;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,IAAI4D,aAAa,GAAI5D,IAAI,CAAC4D,aAAa,GAAG,CAAC,CAAE;;AAE7C;AACA;AACA;AACA;AACA;AACA5D,IAAI,CAACQ,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACAR,IAAI,CAACC,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACAD,IAAI,CAACgB,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACAhB,IAAI,CAACoB,eAAe,GAAG,CAAC;AACxB;AACA;AACA;AACA;AACA;AACApB,IAAI,CAACqC,gBAAgB,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACArC,IAAI,CAACwB,mBAAmB,GAAG,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACAxB,IAAI,CAACG,aAAa,GAAG,CAAC;AACtB;AACA;AACA;AACA;AACA;AACAH,IAAI,CAACe,iBAAiB,GAAG,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACAf,IAAI,CAACU,cAAc,GAAG,CAAC;AACvB;AACA;AACA;AACA;AACA;AACAV,IAAI,CAAC0B,cAAc,GAAG,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA1B,IAAI,CAAC8C,gBAAgB,GAAG,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA9C,IAAI,CAACkE,mBAAmB,GAAG,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACAlE,IAAI,CAACwD,cAAc,GAAG,EAAE;AACxB;AACA;AACA;AACA;AACA;AACAxD,IAAI,CAACoD,gBAAgB,GAAG,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACApD,IAAI,CAAC8D,sBAAsB,GAAG,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA9D,IAAI,CAACO,aAAa,GAAG,EAAE;AACvB;AACA;AACA;AACA;AACA;AACAP,IAAI,CAACqD,mBAAmB,GAAG,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACArD,IAAI,CAAC2B,cAAc,GAAG,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA3B,IAAI,CAACiC,oBAAoB,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACAjC,IAAI,CAACsD,iBAAiB,GAAG,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACAtD,IAAI,CAACuD,iBAAiB,GAAG,IAAI;;AAE7B;AACA;AACA;AACA;AACA;AACAvD,IAAI,CAAC6E,2BAA2B,GAAG,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA7E,IAAI,CAAC8E,4BAA4B,GAAG,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA9E,IAAI,CAAC+E,8BAA8B,GAAG,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA/E,IAAI,CAACgF,wBAAwB,GAAG,CAAC;AACjC;AACA;AACA;AACA;AACA;AACAhF,IAAI,CAACiF,uBAAuB,GAAG,CAAC;AAChC;AACA;AACA;AACA;AACA;AACAjF,IAAI,CAACkF,gCAAgC,GAAG,GAAG;;AAE3C;AACAlF,IAAI,CAACmF,cAAc,GAAG,UAAU;AAChCnF,IAAI,CAACoF,cAAc,GAAG,CAAC,UAAU;AAEjCpF,IAAI,CAACqF,cAAc,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;AACzCvF,IAAI,CAACwF,cAAc,GAAG,CAACF,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;;AAEtC;AACAvF,IAAI,CAACyF,UAAU,GAAG,gBAAgB,CAAC,CAAC;AACpCzF,IAAI,CAAC0F,UAAU,GAAG,CAAC,gBAAgB,CAAC,CAAC;;AAErC;AACA,IAAI5D,eAAe,GAAGxE,IAAI,CAACqI,UAAU,CAAC,gBAAgB,CAAC,CAAC,CAAC;AACzD,IAAI3D,eAAe,GAAG1E,IAAI,CAACqI,UAAU,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;;AAE1DC,MAAM,CAACC,OAAO,GAAGxH,WAAW"},"metadata":{},"sourceType":"script"}