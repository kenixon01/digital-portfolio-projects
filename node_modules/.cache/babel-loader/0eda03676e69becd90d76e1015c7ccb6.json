{"ast":null,"code":"'use strict';\n\nconst os = require('os');\nconst crypto = require('crypto');\nconst requireOptional = require('optional-require')(require);\n\n/**\n * Generate a UUIDv4\n */\nconst uuidV4 = () => {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n};\n\n/**\n * Relays events for a given listener and emitter\n *\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\n */\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\n}\nfunction retrieveKerberos() {\n  let kerberos;\n  try {\n    // Ensure you always wrap an optional require in the try block NODE-3199\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n    throw err;\n  }\n  return kerberos;\n}\n\n// Throw an error if an attempt to use EJSON is made when it is not installed\nconst noEJSONError = function () {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n};\n\n// Facilitate loading EJSON optionally\nfunction retrieveEJSON() {\n  let EJSON = requireOptional('mongodb-extjson');\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n  return EJSON;\n}\n\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology\n * instances\n *\n * @private\n * @param {(Topology|Server)} topologyOrServer\n */\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n    if (topologyOrServer.description) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n  return 0;\n}\n\n/*\n * Checks that collation is supported by server.\n *\n * @param {Server} [server] to check against\n * @param {object} [cmd] object where collation may be specified\n * @param {function} [callback] callback function\n * @return true if server does not support collation\n */\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n *\n * @param {array} arr an array of items to asynchronusly iterate over\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param {function} callback The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n  function eachCallback(err) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n    eachFn(arr[idx], eachCallback);\n  }\n  eachFn(arr[idx], eachCallback);\n}\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n  return true;\n}\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\nfunction makeClientMetadata(options) {\n  options = options || {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: require('../../package.json').version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `'Node.js ${process.version}, ${os.endianness} (${options.useUnifiedTopology ? 'unified' : 'legacy'})`\n  };\n\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n  if (options.appname) {\n    // MongoDB requires the appname not exceed a byte length of 128\n    const buffer = Buffer.from(options.appname);\n    metadata.application = {\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\n    };\n  }\n  return metadata;\n}\nconst noop = () => {};\nmodule.exports = {\n  uuidV4,\n  relayEvents,\n  collationNotSupported,\n  retrieveEJSON,\n  retrieveKerberos,\n  maxWireVersion,\n  isPromiseLike,\n  eachAsync,\n  eachAsyncSeries,\n  isUnifiedTopology,\n  arrayStrictEqual,\n  tagsStrictEqual,\n  errorStrictEqual,\n  makeStateMachine,\n  makeClientMetadata,\n  noop\n};","map":{"version":3,"names":["os","require","crypto","requireOptional","uuidV4","result","randomBytes","relayEvents","listener","emitter","events","forEach","eventName","on","event","emit","retrieveKerberos","kerberos","err","code","Error","noEJSONError","retrieveEJSON","EJSON","parse","deserialize","serialize","stringify","setBSONModule","BSON","maxWireVersion","topologyOrServer","ismaster","lastIsMaster","description","collationNotSupported","server","cmd","collation","isPromiseLike","maybePromise","then","eachAsync","arr","eachFn","callback","idx","awaiting","length","eachCallback","eachAsyncSeries","isUnifiedTopology","topology","arrayStrictEqual","arr2","Array","isArray","every","elt","tagsStrictEqual","tags","tags2","tagsKeys","Object","keys","tags2Keys","key","errorStrictEqual","lhs","rhs","constructor","name","message","makeStateMachine","stateTable","stateTransition","target","newState","legalStates","s","state","indexOf","TypeError","makeClientMetadata","options","metadata","driver","version","type","process","platform","architecture","arch","release","endianness","useUnifiedTopology","driverInfo","appname","buffer","Buffer","from","application","slice","toString","noop","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/utils.js"],"sourcesContent":["'use strict';\nconst os = require('os');\nconst crypto = require('crypto');\nconst requireOptional = require('optional-require')(require);\n\n/**\n * Generate a UUIDv4\n */\nconst uuidV4 = () => {\n  const result = crypto.randomBytes(16);\n  result[6] = (result[6] & 0x0f) | 0x40;\n  result[8] = (result[8] & 0x3f) | 0x80;\n  return result;\n};\n\n/**\n * Relays events for a given listener and emitter\n *\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\n */\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\n}\n\nfunction retrieveKerberos() {\n  let kerberos;\n\n  try {\n    // Ensure you always wrap an optional require in the try block NODE-3199\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n\n    throw err;\n  }\n\n  return kerberos;\n}\n\n// Throw an error if an attempt to use EJSON is made when it is not installed\nconst noEJSONError = function() {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n};\n\n// Facilitate loading EJSON optionally\nfunction retrieveEJSON() {\n  let EJSON = requireOptional('mongodb-extjson');\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n\n  return EJSON;\n}\n\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology\n * instances\n *\n * @private\n * @param {(Topology|Server)} topologyOrServer\n */\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\n/*\n * Checks that collation is supported by server.\n *\n * @param {Server} [server] to check against\n * @param {object} [cmd] object where collation may be specified\n * @param {function} [callback] callback function\n * @return true if server does not support collation\n */\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n *\n * @param {array} arr an array of items to asynchronusly iterate over\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param {function} callback The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = arr.length;\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new TypeError(\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\n      );\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nfunction makeClientMetadata(options) {\n  options = options || {};\n\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: require('../../package.json').version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `'Node.js ${process.version}, ${os.endianness} (${\n      options.useUnifiedTopology ? 'unified' : 'legacy'\n    })`\n  };\n\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appname) {\n    // MongoDB requires the appname not exceed a byte length of 128\n    const buffer = Buffer.from(options.appname);\n    metadata.application = {\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\n    };\n  }\n\n  return metadata;\n}\n\nconst noop = () => {};\n\nmodule.exports = {\n  uuidV4,\n  relayEvents,\n  collationNotSupported,\n  retrieveEJSON,\n  retrieveKerberos,\n  maxWireVersion,\n  isPromiseLike,\n  eachAsync,\n  eachAsyncSeries,\n  isUnifiedTopology,\n  arrayStrictEqual,\n  tagsStrictEqual,\n  errorStrictEqual,\n  makeStateMachine,\n  makeClientMetadata,\n  noop\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}