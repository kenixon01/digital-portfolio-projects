{"ast":null,"code":"'use strict';\n\nconst inherits = require('util').inherits;\nconst EventEmitter = require('events').EventEmitter;\nconst MongoError = require('../error').MongoError;\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\nconst Logger = require('./logger');\nconst f = require('util').format;\nconst Msg = require('./msg').Msg;\nconst CommandResult = require('./command_result');\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../wireprotocol/shared').opcodes;\nconst compress = require('../wireprotocol/compression').compress;\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\nconst apm = require('./apm');\nconst Buffer = require('safe-buffer').Buffer;\nconst connect = require('./connect');\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\nconst eachAsync = require('../utils').eachAsync;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst now = require('../../utils').now;\nconst DISCONNECTED = 'disconnected';\nconst CONNECTING = 'connecting';\nconst CONNECTED = 'connected';\nconst DRAINING = 'draining';\nconst DESTROYING = 'destroying';\nconst DESTROYED = 'destroyed';\nconst stateTransition = makeStateMachine({\n  [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],\n  [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],\n  [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],\n  [DRAINING]: [DRAINING, DESTROYING, DESTROYED],\n  [DESTROYING]: [DESTROYING, DESTROYED],\n  [DESTROYED]: [DESTROYED]\n});\nconst CONNECTION_EVENTS = new Set(['error', 'close', 'timeout', 'parseError', 'connect', 'message']);\nvar _id = 0;\n\n/**\n * Creates a new Pool instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Max server connection pool size\n * @param {number} [options.minSize=0] Minimum server connection pool size\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=0] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.bsonRegExp=false] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Pool#connect\n * @fires Pool#close\n * @fires Pool#error\n * @fires Pool#timeout\n * @fires Pool#parseError\n * @return {Pool} A cursor instance\n */\nvar Pool = function (topology, options) {\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Store topology for later use\n  this.topology = topology;\n  this.s = {\n    state: DISCONNECTED,\n    cancellationToken: new EventEmitter()\n  };\n\n  // we don't care how many connections are listening for cancellation\n  this.s.cancellationToken.setMaxListeners(Infinity);\n\n  // Add the options\n  this.options = Object.assign({\n    // Host and port settings\n    host: 'localhost',\n    port: 27017,\n    // Pool default max size\n    size: 5,\n    // Pool default min size\n    minSize: 0,\n    // socket settings\n    connectionTimeout: 30000,\n    socketTimeout: 0,\n    keepAlive: true,\n    keepAliveInitialDelay: 120000,\n    noDelay: true,\n    // SSL Settings\n    ssl: false,\n    checkServerIdentity: true,\n    ca: null,\n    crl: null,\n    cert: null,\n    key: null,\n    passphrase: null,\n    rejectUnauthorized: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    bsonRegExp: false,\n    // Reconnection options\n    reconnect: true,\n    reconnectInterval: 1000,\n    reconnectTries: 30,\n    // Enable domains\n    domainsEnabled: false,\n    // feature flag for determining if we are running with the unified topology or not\n    legacyCompatMode: true\n  }, options);\n\n  // Identification information\n  this.id = _id++;\n  // Current reconnect retries\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null;\n  this.reconnectError = null;\n  // No bson parser passed in\n  if (!options.bson || options.bson && (typeof options.bson.serialize !== 'function' || typeof options.bson.deserialize !== 'function')) {\n    throw new Error('must pass in valid bson parser');\n  }\n\n  // Logger instance\n  this.logger = Logger('Pool', options);\n  // Connections\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = 0;\n  // Currently executing\n  this.executing = false;\n  // Operation work queue\n  this.queue = [];\n\n  // Number of consecutive timeouts caught\n  this.numberOfConsecutiveTimeouts = 0;\n  // Current pool Index\n  this.connectionIndex = 0;\n\n  // event handlers\n  const pool = this;\n  this._messageHandler = messageHandler(this);\n  this._connectionCloseHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'close', err, connection);\n  };\n  this._connectionErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'error', err, connection);\n  };\n  this._connectionTimeoutHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'timeout', err, connection);\n  };\n  this._connectionParseErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'parseError', err, connection);\n  };\n};\ninherits(Pool, EventEmitter);\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable: true,\n  get: function () {\n    return this.options.size;\n  }\n});\nObject.defineProperty(Pool.prototype, 'minSize', {\n  enumerable: true,\n  get: function () {\n    return this.options.minSize;\n  }\n});\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.connectionTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.socketTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'state', {\n  enumerable: true,\n  get: function () {\n    return this.s.state;\n  }\n});\n\n// clears all pool state\nfunction resetPoolState(pool) {\n  pool.inUseConnections = [];\n  pool.availableConnections = [];\n  pool.connectingConnections = 0;\n  pool.executing = false;\n  pool.numberOfConsecutiveTimeouts = 0;\n  pool.connectionIndex = 0;\n  pool.retriesLeft = pool.options.reconnectTries;\n  pool.reconnectId = null;\n}\nfunction connectionFailureHandler(pool, event, err, conn) {\n  if (conn) {\n    if (conn._connectionFailHandled) {\n      return;\n    }\n    conn._connectionFailHandled = true;\n    conn.destroy();\n\n    // Remove the connection\n    removeConnection(pool, conn);\n\n    // flush remaining work items\n    conn.flush(err);\n  }\n\n  // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n  if (event === 'timeout') {\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;\n\n    // Have we timed out more than reconnectTries in a row ?\n    // Force close the pool as we are trying to connect to tcp sink hole\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\n      pool.numberOfConsecutiveTimeouts = 0;\n      // Destroy all connections and pool\n      pool.destroy(true);\n      // Emit close event\n      return pool.emit('close', pool);\n    }\n  }\n\n  // No more socket available propegate the event\n  if (pool.socketCount() === 0) {\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {\n      if (pool.options.reconnect) {\n        stateTransition(pool, DISCONNECTED);\n      }\n    }\n\n    // Do not emit error events, they are always close events\n    // do not trigger the low level error handler in node\n    event = event === 'error' ? 'close' : event;\n    pool.emit(event, err);\n  }\n\n  // Start reconnection attempts\n  if (!pool.reconnectId && pool.options.reconnect) {\n    pool.reconnectError = err;\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\n  }\n\n  // Do we need to do anything to maintain the minimum pool size\n  const totalConnections = totalConnectionCount(pool);\n  if (totalConnections < pool.minSize) {\n    createConnection(pool);\n  }\n}\nfunction attemptReconnect(pool, callback) {\n  return function () {\n    pool.emit('attemptReconnect', pool);\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Cannot create connection when pool is destroyed'));\n      }\n      return;\n    }\n    pool.retriesLeft = pool.retriesLeft - 1;\n    if (pool.retriesLeft <= 0) {\n      pool.destroy();\n      const error = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);\n      pool.emit('reconnectFailed', error);\n      if (typeof callback === 'function') {\n        callback(error);\n      }\n      return;\n    }\n\n    // clear the reconnect id on retry\n    pool.reconnectId = null;\n\n    // now retry creating a connection\n    createConnection(pool, (err, conn) => {\n      if (err == null) {\n        pool.reconnectId = null;\n        pool.retriesLeft = pool.options.reconnectTries;\n        pool.emit('reconnect', pool);\n      }\n      if (typeof callback === 'function') {\n        callback(err, conn);\n      }\n    });\n  };\n}\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection);\n  // Move the connection from connecting to available\n  if (index !== -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\nfunction messageHandler(self) {\n  return function (message, connection) {\n    // workItem to execute\n    var workItem = null;\n\n    // Locate the workItem\n    for (var i = 0; i < connection.workItems.length; i++) {\n      if (connection.workItems[i].requestId === message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i];\n        // Remove from list of workItems\n        connection.workItems.splice(i, 1);\n      }\n    }\n    if (workItem && workItem.monitoring) {\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n    }\n\n    // Reset timeout counter\n    self.numberOfConsecutiveTimeouts = 0;\n\n    // Reset the connection timeout if we modified it for\n    // this operation\n    if (workItem && workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    }\n\n    // Log if debug enabled\n    if (self.logger.isDebug()) {\n      self.logger.debug(f('message [ %s ] received from %s:%s', message.raw.length, self.options.host, self.options.port));\n    }\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if (!self.options.domainsEnabled) {\n        return process.nextTick(function () {\n          return cb(err, result);\n        });\n      }\n\n      // Domain enabled just call the callback\n      cb(err, result);\n    }\n\n    // Keep executing, ensure current message handler does not stop execution\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    }\n\n    // Time to dispatch the message if we have a callback\n    if (workItem && !workItem.immediateRelease) {\n      try {\n        // Parse the message according to the provided options\n        message.parse(workItem);\n      } catch (err) {\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\n      }\n      if (message.documents[0]) {\n        const document = message.documents[0];\n        const session = workItem.session;\n        if (session) {\n          updateSessionFromResponse(session, document);\n        }\n        if (self.topology && document.$clusterTime) {\n          self.topology.clusterTime = document.$clusterTime;\n        }\n      }\n\n      // Establish if we have an error\n      if (workItem.command && message.documents[0]) {\n        const responseDoc = message.documents[0];\n        if (responseDoc.writeConcernError) {\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\n          return handleOperationCallback(self, workItem.cb, err);\n        }\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\n        }\n      }\n\n      // Add the connection details\n      message.hashedName = connection.hashedName;\n\n      // Return the documents\n      handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));\n    }\n  };\n}\n\n/**\n * Return the total socket count in the pool.\n * @method\n * @return {Number} The number of socket available.\n */\nPool.prototype.socketCount = function () {\n  return this.availableConnections.length + this.inUseConnections.length;\n  // + this.connectingConnections.length;\n};\n\nfunction totalConnectionCount(pool) {\n  return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;\n}\n\n/**\n * Return all pool connections\n * @method\n * @return {Connection[]} The pool connections\n */\nPool.prototype.allConnections = function () {\n  return this.availableConnections.concat(this.inUseConnections);\n};\n\n/**\n * Get a pool connection (round-robin)\n * @method\n * @return {Connection}\n */\nPool.prototype.get = function () {\n  return this.allConnections()[0];\n};\n\n/**\n * Is the pool connected\n * @method\n * @return {boolean}\n */\nPool.prototype.isConnected = function () {\n  // We are in a destroyed state\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    return false;\n  }\n\n  // Get connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n\n  // Check if we have any connected connections\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i].isConnected()) return true;\n  }\n\n  // Not connected\n  return false;\n};\n\n/**\n * Was the pool destroyed\n * @method\n * @return {boolean}\n */\nPool.prototype.isDestroyed = function () {\n  return this.state === DESTROYED || this.state === DESTROYING;\n};\n\n/**\n * Is the pool in a disconnected state\n * @method\n * @return {boolean}\n */\nPool.prototype.isDisconnected = function () {\n  return this.state === DISCONNECTED;\n};\n\n/**\n * Connect pool\n */\nPool.prototype.connect = function (callback) {\n  if (this.state !== DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n  stateTransition(this, CONNECTING);\n  createConnection(this, (err, conn) => {\n    if (err) {\n      if (typeof callback === 'function') {\n        this.destroy();\n        callback(err);\n        return;\n      }\n      if (this.state === CONNECTING) {\n        this.emit('error', err);\n      }\n      this.destroy();\n      return;\n    }\n    stateTransition(this, CONNECTED);\n\n    // create min connections\n    if (this.minSize) {\n      for (let i = 0; i < this.minSize; i++) {\n        createConnection(this);\n      }\n    }\n    if (typeof callback === 'function') {\n      callback(null, conn);\n    } else {\n      this.emit('connect', this, conn);\n    }\n  });\n};\n\n/**\n * Authenticate using a specified mechanism\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Logout all users against a database\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.logout = function (dbName, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Unref the pool\n * @method\n * @deprecated This function is deprecated and will be removed in the next major version.\n */\nPool.prototype.unref = function () {\n  // Get all the known connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n  connections.forEach(function (c) {\n    c.unref();\n  });\n};\n\n// Destroy the connections\nfunction destroy(self, connections, options, callback) {\n  stateTransition(self, DESTROYING);\n\n  // indicate that in-flight connections should cancel\n  self.s.cancellationToken.emit('cancel');\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    }\n\n    // ignore any errors during destruction\n    conn.on('error', () => {});\n    conn.destroy(options, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') callback(err, null);\n      return;\n    }\n    resetPoolState(self);\n    self.queue = [];\n    stateTransition(self, DESTROYED);\n    if (typeof callback === 'function') callback(null, null);\n  });\n}\n\n/**\n * Destroy pool\n * @method\n */\nPool.prototype.destroy = function (force, callback) {\n  var self = this;\n  if (typeof force === 'function') {\n    callback = force;\n    force = false;\n  }\n\n  // Do not try again if the pool is already dead\n  if (this.state === DESTROYED || self.state === DESTROYING) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  // Set state to draining\n  stateTransition(this, DRAINING);\n\n  // Are we force closing\n  if (force) {\n    // Get all the known connections\n    var connections = self.availableConnections.concat(self.inUseConnections);\n\n    // Flush any remaining work items with\n    // an error\n    while (self.queue.length > 0) {\n      var workItem = self.queue.shift();\n      if (typeof workItem.cb === 'function') {\n        workItem.cb(new MongoError('Pool was force destroyed'));\n      }\n    }\n\n    // Destroy the topology\n    return destroy(self, connections, {\n      force: true\n    }, callback);\n  }\n\n  // Clear out the reconnect if set\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  }\n\n  // Wait for the operations to drain before we close the pool\n  function checkStatus() {\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    flushMonitoringOperations(self.queue);\n    if (self.queue.length === 0) {\n      // Get all the known connections\n      var connections = self.availableConnections.concat(self.inUseConnections);\n\n      // Check if we have any in flight operations\n      for (var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if (connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n      destroy(self, connections, {\n        force: false\n      }, callback);\n    } else {\n      // Ensure we empty the queue\n      _execute(self)();\n      // Set timeout\n      setTimeout(checkStatus, 1);\n    }\n  }\n\n  // Initiate drain of operations\n  checkStatus();\n};\n\n/**\n * Reset all connections of this pool\n *\n * @param {function} [callback]\n */\nPool.prototype.reset = function (callback) {\n  if (this.s.state !== CONNECTED) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('pool is not connected, reset aborted'));\n    }\n    return;\n  }\n\n  // signal in-flight connections should be cancelled\n  this.s.cancellationToken.emit('cancel');\n\n  // destroy existing connections\n  const connections = this.availableConnections.concat(this.inUseConnections);\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    }\n    conn.destroy({\n      force: true\n    }, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') {\n        callback(err, null);\n        return;\n      }\n    }\n    resetPoolState(this);\n\n    // create a new connection, this will ultimately trigger execution\n    createConnection(this, () => {\n      if (typeof callback === 'function') {\n        callback(null, null);\n      }\n    });\n  });\n};\n\n// Prepare the buffer that Pool.prototype.write() uses to send to the server\nfunction serializeCommand(self, command, callback) {\n  const originalCommandBuffer = command.toBin();\n\n  // Check whether we and the server have agreed to use a compressor\n  const shouldCompress = !!self.options.agreedCompressor;\n  if (!shouldCompress || !canCompress(command)) {\n    return callback(null, originalCommandBuffer);\n  }\n\n  // Transform originalCommandBuffer into OP_COMPRESSED\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n  // Extract information needed for OP_COMPRESSED from the uncompressed message\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n  // Compress the message body\n  compress(self, messageToBeCompressed, function (err, compressedMessage) {\n    if (err) return callback(err, null);\n\n    // Create the msgHeader of OP_COMPRESSED\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n    msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n    // Create the compression details of OP_COMPRESSED\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\n\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\n  });\n}\n\n/**\n * Write a message to MongoDB\n * @method\n * @return {Connection}\n */\nPool.prototype.write = function (command, options, cb) {\n  var self = this;\n  // Ensure we have a callback\n  if (typeof options === 'function') {\n    cb = options;\n  }\n\n  // Always have options\n  options = options || {};\n\n  // We need to have a callback function unless the message returns no response\n  if (!(typeof cb === 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  }\n\n  // Pool was destroyed error out\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    cb(new MongoError('pool destroyed'));\n    return;\n  }\n  if (this.state === DRAINING) {\n    cb(new MongoError('pool is draining, new operations prohibited'));\n    return;\n  }\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function () {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length);\n      for (var i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n      // bounce off event loop so domain switch takes place\n      process.nextTick(function () {\n        oldCb.apply(null, args);\n      });\n    });\n  }\n\n  // Do we have an operation\n  var operation = {\n    cb: cb,\n    raw: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    bsonRegExp: false,\n    fullResult: false\n  };\n\n  // Set the options for the parsing\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues = typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers = typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\n  operation.bsonRegExp = typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false;\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\n  operation.immediateRelease = typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\n  operation.session = options.session || null;\n\n  // Optional per operation socketTimeout\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring;\n\n  // Get the requestId\n  operation.requestId = command.requestId;\n\n  // If command monitoring is enabled we need to modify the callback here\n  if (self.options.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operation.started = now();\n    operation.cb = (err, reply) => {\n      if (err) {\n        self.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operation.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          self.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operation.started));\n        } else {\n          self.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operation.started));\n        }\n      }\n      if (typeof cb === 'function') cb(err, reply);\n    };\n  }\n\n  // Prepare the operation buffer\n  serializeCommand(self, command, (err, serializedBuffers) => {\n    if (err) throw err;\n\n    // Set the operation's buffer to the serialization of the commands\n    operation.buffer = serializedBuffers;\n\n    // If we have a monitoring operation schedule as the very first operation\n    // Otherwise add to back of queue\n    if (options.monitoring) {\n      self.queue.unshift(operation);\n    } else {\n      self.queue.push(operation);\n    }\n\n    // Attempt to execute the operation\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    }\n  });\n};\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\n// Remove connection method\nfunction remove(connection, connections) {\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\nfunction removeConnection(self, connection) {\n  if (remove(connection, self.availableConnections)) return;\n  if (remove(connection, self.inUseConnections)) return;\n}\nfunction createConnection(pool, callback) {\n  if (pool.state === DESTROYED || pool.state === DESTROYING) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('Cannot create connection when pool is destroyed'));\n    }\n    return;\n  }\n  pool.connectingConnections++;\n  connect(pool.options, pool.s.cancellationToken, (err, connection) => {\n    pool.connectingConnections--;\n    if (err) {\n      if (pool.logger.isDebug()) {\n        pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      }\n\n      // check if reconnect is enabled, and attempt retry if so\n      if (!pool.reconnectId && pool.options.reconnect) {\n        if (pool.state === CONNECTING && pool.options.legacyCompatMode) {\n          callback(err);\n          return;\n        }\n        pool.reconnectError = err;\n        pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);\n        return;\n      }\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n      return;\n    }\n\n    // the pool might have been closed since we started creating the connection\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Pool was destroyed after connection creation'));\n      }\n      connection.destroy();\n      return;\n    }\n\n    // otherwise, connect relevant event handlers and add it to our available connections\n    connection.on('error', pool._connectionErrorHandler);\n    connection.on('close', pool._connectionCloseHandler);\n    connection.on('timeout', pool._connectionTimeoutHandler);\n    connection.on('parseError', pool._connectionParseErrorHandler);\n    connection.on('message', pool._messageHandler);\n    pool.availableConnections.push(connection);\n\n    // if a callback was provided, return the connection\n    if (typeof callback === 'function') {\n      callback(null, connection);\n    }\n\n    // immediately execute any waiting work\n    _execute(pool)();\n  });\n}\nfunction flushMonitoringOperations(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    if (queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(new MongoError({\n        message: 'no connection available for monitoring',\n        driver: true\n      }));\n    }\n  }\n}\nfunction _execute(self) {\n  return function () {\n    if (self.state === DESTROYED) return;\n    // Already executing, skip\n    if (self.executing) return;\n    // Set pool as executing\n    self.executing = true;\n\n    // New pool connections are in progress, wait them to finish\n    // before executing any more operation to ensure distribution of\n    // operations\n    if (self.connectingConnections > 0) {\n      self.executing = false;\n      return;\n    }\n\n    // As long as we have available connections\n    // eslint-disable-next-line\n    while (true) {\n      // Total availble connections\n      const totalConnections = totalConnectionCount(self);\n\n      // No available connections available, flush any monitoring ops\n      if (self.availableConnections.length === 0) {\n        // Flush any monitoring operations\n        flushMonitoringOperations(self.queue);\n\n        // Try to create a new connection to execute stuck operation\n        if (totalConnections < self.options.size && self.queue.length > 0) {\n          createConnection(self);\n        }\n        break;\n      }\n\n      // No queue break\n      if (self.queue.length === 0) {\n        break;\n      }\n      var connection = null;\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0);\n\n      // No connection found that has no work on it, just pick one for pipelining\n      if (connections.length === 0) {\n        connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n      } else {\n        connection = connections[self.connectionIndex++ % connections.length];\n      }\n\n      // Is the connection connected\n      if (!connection.isConnected()) {\n        // Remove the disconnected connection\n        removeConnection(self, connection);\n        // Flush any monitoring operations in the queue, failing fast\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n\n      // Get the next work item\n      var workItem = self.queue.shift();\n\n      // If we are monitoring we need to use a connection that is not\n      // running another operation to avoid socket timeout changes\n      // affecting an existing operation\n      if (workItem.monitoring) {\n        var foundValidConnection = false;\n        for (let i = 0; i < self.availableConnections.length; i++) {\n          // If the connection is connected\n          // And there are no pending workItems on it\n          // Then we can safely use it for monitoring.\n          if (self.availableConnections[i].isConnected() && self.availableConnections[i].workItems.length === 0) {\n            foundValidConnection = true;\n            connection = self.availableConnections[i];\n            break;\n          }\n        }\n\n        // No safe connection found, attempt to grow the connections\n        // if possible and break from the loop\n        if (!foundValidConnection) {\n          // Put workItem back on the queue\n          self.queue.unshift(workItem);\n\n          // Attempt to grow the pool if it's not yet maxsize\n          if (totalConnections < self.options.size && self.queue.length > 0) {\n            // Create a new connection\n            createConnection(self);\n          }\n\n          // Re-execute the operation\n          setTimeout(() => _execute(self)(), 10);\n          break;\n        }\n      }\n\n      // Don't execute operation until we have a full pool\n      if (totalConnections < self.options.size) {\n        // Connection has work items, then put it back on the queue\n        // and create a new connection\n        if (connection.workItems.length > 0) {\n          // Lets put the workItem back on the list\n          self.queue.unshift(workItem);\n          // Create a new connection\n          createConnection(self);\n          // Break from the loop\n          break;\n        }\n      }\n\n      // Get actual binary commands\n      var buffer = workItem.buffer;\n\n      // If we are monitoring take the connection of the availableConnections\n      if (workItem.monitoring) {\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n      }\n\n      // Track the executing commands on the mongo server\n      // as long as there is an expected response\n      if (!workItem.noResponse) {\n        connection.workItems.push(workItem);\n      }\n\n      // We have a custom socketTimeout\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\n        connection.setSocketTimeout(workItem.socketTimeout);\n      }\n\n      // Capture if write was successful\n      var writeSuccessful = true;\n\n      // Put operation on the wire\n      if (Array.isArray(buffer)) {\n        for (let i = 0; i < buffer.length; i++) {\n          writeSuccessful = connection.write(buffer[i]);\n        }\n      } else {\n        writeSuccessful = connection.write(buffer);\n      }\n\n      // if the command is designated noResponse, call the callback immeditely\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\n        workItem.cb(null, null);\n      }\n      if (writeSuccessful === false) {\n        // If write not successful put back on queue\n        self.queue.unshift(workItem);\n        // Remove the disconnected connection\n        removeConnection(self, connection);\n        // Flush any monitoring operations in the queue, failing fast\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n    }\n    self.executing = false;\n  };\n}\n\n// Make execution loop available for testing\nPool._execute = _execute;\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Pool#connect\n * @type {Pool}\n */\n\n/**\n * A server reconnect event, used to verify that pool reconnected.\n *\n * @event Pool#reconnect\n * @type {Pool}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Pool#close\n * @type {Pool}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Pool#error\n * @type {Pool}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Pool#timeout\n * @type {Pool}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Pool#parseError\n * @type {Pool}\n */\n\n/**\n * The driver attempted to reconnect\n *\n * @event Pool#attemptReconnect\n * @type {Pool}\n */\n\n/**\n * The driver exhausted all reconnect attempts\n *\n * @event Pool#reconnectFailed\n * @type {Pool}\n */\n\nmodule.exports = Pool;","map":{"version":3,"names":["inherits","require","EventEmitter","MongoError","MongoTimeoutError","MongoWriteConcernError","Logger","f","format","Msg","CommandResult","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","opcodes","compress","compressorIDs","uncompressibleCommands","apm","Buffer","connect","updateSessionFromResponse","eachAsync","makeStateMachine","now","DISCONNECTED","CONNECTING","CONNECTED","DRAINING","DESTROYING","DESTROYED","stateTransition","CONNECTION_EVENTS","Set","_id","Pool","topology","options","call","s","state","cancellationToken","setMaxListeners","Infinity","Object","assign","host","port","size","minSize","connectionTimeout","socketTimeout","keepAlive","keepAliveInitialDelay","noDelay","ssl","checkServerIdentity","ca","crl","cert","key","passphrase","rejectUnauthorized","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","reconnect","reconnectInterval","reconnectTries","domainsEnabled","legacyCompatMode","id","retriesLeft","reconnectId","reconnectError","bson","serialize","deserialize","Error","logger","availableConnections","inUseConnections","connectingConnections","executing","queue","numberOfConsecutiveTimeouts","connectionIndex","pool","_messageHandler","messageHandler","_connectionCloseHandler","err","connection","connectionFailureHandler","_connectionErrorHandler","_connectionTimeoutHandler","_connectionParseErrorHandler","defineProperty","prototype","enumerable","get","resetPoolState","event","conn","_connectionFailHandled","destroy","removeConnection","flush","emit","socketCount","setTimeout","attemptReconnect","totalConnections","totalConnectionCount","createConnection","callback","error","moveConnectionBetween","from","to","index","indexOf","splice","push","self","message","workItem","i","workItems","length","requestId","responseTo","monitoring","resetSocketTimeout","isDebug","debug","raw","handleOperationCallback","cb","result","process","nextTick","_execute","immediateRelease","parse","documents","document","session","$clusterTime","clusterTime","command","responseDoc","writeConcernError","ok","$err","errmsg","code","hashedName","fullResult","allConnections","concat","isConnected","connections","isDestroyed","isDisconnected","auth","credentials","logout","dbName","unref","forEach","c","eventName","removeAllListeners","on","force","shift","clearTimeout","checkStatus","flushMonitoringOperations","reset","serializeCommand","originalCommandBuffer","toBin","shouldCompress","agreedCompressor","canCompress","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","compressedMessage","msgHeader","alloc","writeInt32LE","OP_COMPRESSED","compressionDetails","writeUInt8","write","noResponse","domain","oldCb","bind","args","Array","arguments","apply","operation","documentsReturnedIn","monitorCommands","CommandStartedEvent","started","reply","CommandFailedEvent","CommandSucceededEvent","serializedBuffers","buffer","unshift","commandDoc","query","commandName","keys","has","remove","JSON","stringify","driver","filter","foundValidConnection","setSocketTimeout","writeSuccessful","isArray","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/connection/pool.js"],"sourcesContent":["'use strict';\n\nconst inherits = require('util').inherits;\nconst EventEmitter = require('events').EventEmitter;\nconst MongoError = require('../error').MongoError;\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\nconst Logger = require('./logger');\nconst f = require('util').format;\nconst Msg = require('./msg').Msg;\nconst CommandResult = require('./command_result');\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../wireprotocol/shared').opcodes;\nconst compress = require('../wireprotocol/compression').compress;\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\nconst apm = require('./apm');\nconst Buffer = require('safe-buffer').Buffer;\nconst connect = require('./connect');\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\nconst eachAsync = require('../utils').eachAsync;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst now = require('../../utils').now;\n\nconst DISCONNECTED = 'disconnected';\nconst CONNECTING = 'connecting';\nconst CONNECTED = 'connected';\nconst DRAINING = 'draining';\nconst DESTROYING = 'destroying';\nconst DESTROYED = 'destroyed';\nconst stateTransition = makeStateMachine({\n  [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],\n  [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],\n  [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],\n  [DRAINING]: [DRAINING, DESTROYING, DESTROYED],\n  [DESTROYING]: [DESTROYING, DESTROYED],\n  [DESTROYED]: [DESTROYED]\n});\n\nconst CONNECTION_EVENTS = new Set([\n  'error',\n  'close',\n  'timeout',\n  'parseError',\n  'connect',\n  'message'\n]);\n\nvar _id = 0;\n\n/**\n * Creates a new Pool instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Max server connection pool size\n * @param {number} [options.minSize=0] Minimum server connection pool size\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=0] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.bsonRegExp=false] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Pool#connect\n * @fires Pool#close\n * @fires Pool#error\n * @fires Pool#timeout\n * @fires Pool#parseError\n * @return {Pool} A cursor instance\n */\nvar Pool = function(topology, options) {\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Store topology for later use\n  this.topology = topology;\n\n  this.s = {\n    state: DISCONNECTED,\n    cancellationToken: new EventEmitter()\n  };\n\n  // we don't care how many connections are listening for cancellation\n  this.s.cancellationToken.setMaxListeners(Infinity);\n\n  // Add the options\n  this.options = Object.assign(\n    {\n      // Host and port settings\n      host: 'localhost',\n      port: 27017,\n      // Pool default max size\n      size: 5,\n      // Pool default min size\n      minSize: 0,\n      // socket settings\n      connectionTimeout: 30000,\n      socketTimeout: 0,\n      keepAlive: true,\n      keepAliveInitialDelay: 120000,\n      noDelay: true,\n      // SSL Settings\n      ssl: false,\n      checkServerIdentity: true,\n      ca: null,\n      crl: null,\n      cert: null,\n      key: null,\n      passphrase: null,\n      rejectUnauthorized: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      bsonRegExp: false,\n      // Reconnection options\n      reconnect: true,\n      reconnectInterval: 1000,\n      reconnectTries: 30,\n      // Enable domains\n      domainsEnabled: false,\n      // feature flag for determining if we are running with the unified topology or not\n      legacyCompatMode: true\n    },\n    options\n  );\n\n  // Identification information\n  this.id = _id++;\n  // Current reconnect retries\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null;\n  this.reconnectError = null;\n  // No bson parser passed in\n  if (\n    !options.bson ||\n    (options.bson &&\n      (typeof options.bson.serialize !== 'function' ||\n        typeof options.bson.deserialize !== 'function'))\n  ) {\n    throw new Error('must pass in valid bson parser');\n  }\n\n  // Logger instance\n  this.logger = Logger('Pool', options);\n  // Connections\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = 0;\n  // Currently executing\n  this.executing = false;\n  // Operation work queue\n  this.queue = [];\n\n  // Number of consecutive timeouts caught\n  this.numberOfConsecutiveTimeouts = 0;\n  // Current pool Index\n  this.connectionIndex = 0;\n\n  // event handlers\n  const pool = this;\n  this._messageHandler = messageHandler(this);\n  this._connectionCloseHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'close', err, connection);\n  };\n\n  this._connectionErrorHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'error', err, connection);\n  };\n\n  this._connectionTimeoutHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'timeout', err, connection);\n  };\n\n  this._connectionParseErrorHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'parseError', err, connection);\n  };\n};\n\ninherits(Pool, EventEmitter);\n\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable: true,\n  get: function() {\n    return this.options.size;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'minSize', {\n  enumerable: true,\n  get: function() {\n    return this.options.minSize;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable: true,\n  get: function() {\n    return this.options.connectionTimeout;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable: true,\n  get: function() {\n    return this.options.socketTimeout;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'state', {\n  enumerable: true,\n  get: function() {\n    return this.s.state;\n  }\n});\n\n// clears all pool state\nfunction resetPoolState(pool) {\n  pool.inUseConnections = [];\n  pool.availableConnections = [];\n  pool.connectingConnections = 0;\n  pool.executing = false;\n  pool.numberOfConsecutiveTimeouts = 0;\n  pool.connectionIndex = 0;\n  pool.retriesLeft = pool.options.reconnectTries;\n  pool.reconnectId = null;\n}\n\nfunction connectionFailureHandler(pool, event, err, conn) {\n  if (conn) {\n    if (conn._connectionFailHandled) {\n      return;\n    }\n\n    conn._connectionFailHandled = true;\n    conn.destroy();\n\n    // Remove the connection\n    removeConnection(pool, conn);\n\n    // flush remaining work items\n    conn.flush(err);\n  }\n\n  // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n  if (event === 'timeout') {\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;\n\n    // Have we timed out more than reconnectTries in a row ?\n    // Force close the pool as we are trying to connect to tcp sink hole\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\n      pool.numberOfConsecutiveTimeouts = 0;\n      // Destroy all connections and pool\n      pool.destroy(true);\n      // Emit close event\n      return pool.emit('close', pool);\n    }\n  }\n\n  // No more socket available propegate the event\n  if (pool.socketCount() === 0) {\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {\n      if (pool.options.reconnect) {\n        stateTransition(pool, DISCONNECTED);\n      }\n    }\n\n    // Do not emit error events, they are always close events\n    // do not trigger the low level error handler in node\n    event = event === 'error' ? 'close' : event;\n    pool.emit(event, err);\n  }\n\n  // Start reconnection attempts\n  if (!pool.reconnectId && pool.options.reconnect) {\n    pool.reconnectError = err;\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\n  }\n\n  // Do we need to do anything to maintain the minimum pool size\n  const totalConnections = totalConnectionCount(pool);\n  if (totalConnections < pool.minSize) {\n    createConnection(pool);\n  }\n}\n\nfunction attemptReconnect(pool, callback) {\n  return function() {\n    pool.emit('attemptReconnect', pool);\n\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Cannot create connection when pool is destroyed'));\n      }\n\n      return;\n    }\n\n    pool.retriesLeft = pool.retriesLeft - 1;\n    if (pool.retriesLeft <= 0) {\n      pool.destroy();\n\n      const error = new MongoTimeoutError(\n        `failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`,\n        pool.reconnectError\n      );\n\n      pool.emit('reconnectFailed', error);\n      if (typeof callback === 'function') {\n        callback(error);\n      }\n\n      return;\n    }\n\n    // clear the reconnect id on retry\n    pool.reconnectId = null;\n\n    // now retry creating a connection\n    createConnection(pool, (err, conn) => {\n      if (err == null) {\n        pool.reconnectId = null;\n        pool.retriesLeft = pool.options.reconnectTries;\n        pool.emit('reconnect', pool);\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, conn);\n      }\n    });\n  };\n}\n\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection);\n  // Move the connection from connecting to available\n  if (index !== -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\n\nfunction messageHandler(self) {\n  return function(message, connection) {\n    // workItem to execute\n    var workItem = null;\n\n    // Locate the workItem\n    for (var i = 0; i < connection.workItems.length; i++) {\n      if (connection.workItems[i].requestId === message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i];\n        // Remove from list of workItems\n        connection.workItems.splice(i, 1);\n      }\n    }\n\n    if (workItem && workItem.monitoring) {\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n    }\n\n    // Reset timeout counter\n    self.numberOfConsecutiveTimeouts = 0;\n\n    // Reset the connection timeout if we modified it for\n    // this operation\n    if (workItem && workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    }\n\n    // Log if debug enabled\n    if (self.logger.isDebug()) {\n      self.logger.debug(\n        f(\n          'message [ %s ] received from %s:%s',\n          message.raw.length,\n          self.options.host,\n          self.options.port\n        )\n      );\n    }\n\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if (!self.options.domainsEnabled) {\n        return process.nextTick(function() {\n          return cb(err, result);\n        });\n      }\n\n      // Domain enabled just call the callback\n      cb(err, result);\n    }\n\n    // Keep executing, ensure current message handler does not stop execution\n    if (!self.executing) {\n      process.nextTick(function() {\n        _execute(self)();\n      });\n    }\n\n    // Time to dispatch the message if we have a callback\n    if (workItem && !workItem.immediateRelease) {\n      try {\n        // Parse the message according to the provided options\n        message.parse(workItem);\n      } catch (err) {\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\n      }\n\n      if (message.documents[0]) {\n        const document = message.documents[0];\n        const session = workItem.session;\n        if (session) {\n          updateSessionFromResponse(session, document);\n        }\n\n        if (self.topology && document.$clusterTime) {\n          self.topology.clusterTime = document.$clusterTime;\n        }\n      }\n\n      // Establish if we have an error\n      if (workItem.command && message.documents[0]) {\n        const responseDoc = message.documents[0];\n\n        if (responseDoc.writeConcernError) {\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\n          return handleOperationCallback(self, workItem.cb, err);\n        }\n\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\n        }\n      }\n\n      // Add the connection details\n      message.hashedName = connection.hashedName;\n\n      // Return the documents\n      handleOperationCallback(\n        self,\n        workItem.cb,\n        null,\n        new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message)\n      );\n    }\n  };\n}\n\n/**\n * Return the total socket count in the pool.\n * @method\n * @return {Number} The number of socket available.\n */\nPool.prototype.socketCount = function() {\n  return this.availableConnections.length + this.inUseConnections.length;\n  // + this.connectingConnections.length;\n};\n\nfunction totalConnectionCount(pool) {\n  return (\n    pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections\n  );\n}\n\n/**\n * Return all pool connections\n * @method\n * @return {Connection[]} The pool connections\n */\nPool.prototype.allConnections = function() {\n  return this.availableConnections.concat(this.inUseConnections);\n};\n\n/**\n * Get a pool connection (round-robin)\n * @method\n * @return {Connection}\n */\nPool.prototype.get = function() {\n  return this.allConnections()[0];\n};\n\n/**\n * Is the pool connected\n * @method\n * @return {boolean}\n */\nPool.prototype.isConnected = function() {\n  // We are in a destroyed state\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    return false;\n  }\n\n  // Get connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n\n  // Check if we have any connected connections\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i].isConnected()) return true;\n  }\n\n  // Not connected\n  return false;\n};\n\n/**\n * Was the pool destroyed\n * @method\n * @return {boolean}\n */\nPool.prototype.isDestroyed = function() {\n  return this.state === DESTROYED || this.state === DESTROYING;\n};\n\n/**\n * Is the pool in a disconnected state\n * @method\n * @return {boolean}\n */\nPool.prototype.isDisconnected = function() {\n  return this.state === DISCONNECTED;\n};\n\n/**\n * Connect pool\n */\nPool.prototype.connect = function(callback) {\n  if (this.state !== DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n\n  stateTransition(this, CONNECTING);\n  createConnection(this, (err, conn) => {\n    if (err) {\n      if (typeof callback === 'function') {\n        this.destroy();\n        callback(err);\n        return;\n      }\n\n      if (this.state === CONNECTING) {\n        this.emit('error', err);\n      }\n\n      this.destroy();\n      return;\n    }\n\n    stateTransition(this, CONNECTED);\n\n    // create min connections\n    if (this.minSize) {\n      for (let i = 0; i < this.minSize; i++) {\n        createConnection(this);\n      }\n    }\n\n    if (typeof callback === 'function') {\n      callback(null, conn);\n    } else {\n      this.emit('connect', this, conn);\n    }\n  });\n};\n\n/**\n * Authenticate using a specified mechanism\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.auth = function(credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Logout all users against a database\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.logout = function(dbName, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Unref the pool\n * @method\n * @deprecated This function is deprecated and will be removed in the next major version.\n */\nPool.prototype.unref = function() {\n  // Get all the known connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n\n  connections.forEach(function(c) {\n    c.unref();\n  });\n};\n\n// Destroy the connections\nfunction destroy(self, connections, options, callback) {\n  stateTransition(self, DESTROYING);\n\n  // indicate that in-flight connections should cancel\n  self.s.cancellationToken.emit('cancel');\n\n  eachAsync(\n    connections,\n    (conn, cb) => {\n      for (const eventName of CONNECTION_EVENTS) {\n        conn.removeAllListeners(eventName);\n      }\n\n      // ignore any errors during destruction\n      conn.on('error', () => {});\n\n      conn.destroy(options, cb);\n    },\n    err => {\n      if (err) {\n        if (typeof callback === 'function') callback(err, null);\n        return;\n      }\n\n      resetPoolState(self);\n      self.queue = [];\n\n      stateTransition(self, DESTROYED);\n      if (typeof callback === 'function') callback(null, null);\n    }\n  );\n}\n\n/**\n * Destroy pool\n * @method\n */\nPool.prototype.destroy = function(force, callback) {\n  var self = this;\n  if (typeof force === 'function') {\n    callback = force;\n    force = false;\n  }\n\n  // Do not try again if the pool is already dead\n  if (this.state === DESTROYED || self.state === DESTROYING) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  // Set state to draining\n  stateTransition(this, DRAINING);\n\n  // Are we force closing\n  if (force) {\n    // Get all the known connections\n    var connections = self.availableConnections.concat(self.inUseConnections);\n\n    // Flush any remaining work items with\n    // an error\n    while (self.queue.length > 0) {\n      var workItem = self.queue.shift();\n      if (typeof workItem.cb === 'function') {\n        workItem.cb(new MongoError('Pool was force destroyed'));\n      }\n    }\n\n    // Destroy the topology\n    return destroy(self, connections, { force: true }, callback);\n  }\n\n  // Clear out the reconnect if set\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  }\n\n  // Wait for the operations to drain before we close the pool\n  function checkStatus() {\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    flushMonitoringOperations(self.queue);\n\n    if (self.queue.length === 0) {\n      // Get all the known connections\n      var connections = self.availableConnections.concat(self.inUseConnections);\n\n      // Check if we have any in flight operations\n      for (var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if (connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n\n      destroy(self, connections, { force: false }, callback);\n    } else {\n      // Ensure we empty the queue\n      _execute(self)();\n      // Set timeout\n      setTimeout(checkStatus, 1);\n    }\n  }\n\n  // Initiate drain of operations\n  checkStatus();\n};\n\n/**\n * Reset all connections of this pool\n *\n * @param {function} [callback]\n */\nPool.prototype.reset = function(callback) {\n  if (this.s.state !== CONNECTED) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('pool is not connected, reset aborted'));\n    }\n\n    return;\n  }\n\n  // signal in-flight connections should be cancelled\n  this.s.cancellationToken.emit('cancel');\n\n  // destroy existing connections\n  const connections = this.availableConnections.concat(this.inUseConnections);\n  eachAsync(\n    connections,\n    (conn, cb) => {\n      for (const eventName of CONNECTION_EVENTS) {\n        conn.removeAllListeners(eventName);\n      }\n\n      conn.destroy({ force: true }, cb);\n    },\n    err => {\n      if (err) {\n        if (typeof callback === 'function') {\n          callback(err, null);\n          return;\n        }\n      }\n\n      resetPoolState(this);\n\n      // create a new connection, this will ultimately trigger execution\n      createConnection(this, () => {\n        if (typeof callback === 'function') {\n          callback(null, null);\n        }\n      });\n    }\n  );\n};\n\n// Prepare the buffer that Pool.prototype.write() uses to send to the server\nfunction serializeCommand(self, command, callback) {\n  const originalCommandBuffer = command.toBin();\n\n  // Check whether we and the server have agreed to use a compressor\n  const shouldCompress = !!self.options.agreedCompressor;\n  if (!shouldCompress || !canCompress(command)) {\n    return callback(null, originalCommandBuffer);\n  }\n\n  // Transform originalCommandBuffer into OP_COMPRESSED\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n  // Extract information needed for OP_COMPRESSED from the uncompressed message\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n  // Compress the message body\n  compress(self, messageToBeCompressed, function(err, compressedMessage) {\n    if (err) return callback(err, null);\n\n    // Create the msgHeader of OP_COMPRESSED\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n    msgHeader.writeInt32LE(\n      MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n      0\n    ); // messageLength\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n    // Create the compression details of OP_COMPRESSED\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\n\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\n  });\n}\n\n/**\n * Write a message to MongoDB\n * @method\n * @return {Connection}\n */\nPool.prototype.write = function(command, options, cb) {\n  var self = this;\n  // Ensure we have a callback\n  if (typeof options === 'function') {\n    cb = options;\n  }\n\n  // Always have options\n  options = options || {};\n\n  // We need to have a callback function unless the message returns no response\n  if (!(typeof cb === 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  }\n\n  // Pool was destroyed error out\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    cb(new MongoError('pool destroyed'));\n    return;\n  }\n\n  if (this.state === DRAINING) {\n    cb(new MongoError('pool is draining, new operations prohibited'));\n    return;\n  }\n\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function() {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length);\n      for (var i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n      // bounce off event loop so domain switch takes place\n      process.nextTick(function() {\n        oldCb.apply(null, args);\n      });\n    });\n  }\n\n  // Do we have an operation\n  var operation = {\n    cb: cb,\n    raw: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    bsonRegExp: false,\n    fullResult: false\n  };\n\n  // Set the options for the parsing\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues =\n    typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers =\n    typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\n  operation.bsonRegExp = typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false;\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\n  operation.immediateRelease =\n    typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\n  operation.session = options.session || null;\n\n  // Optional per operation socketTimeout\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring;\n\n  // Get the requestId\n  operation.requestId = command.requestId;\n\n  // If command monitoring is enabled we need to modify the callback here\n  if (self.options.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operation.started = now();\n    operation.cb = (err, reply) => {\n      if (err) {\n        self.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operation.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          self.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operation.started)\n          );\n        } else {\n          self.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operation.started)\n          );\n        }\n      }\n\n      if (typeof cb === 'function') cb(err, reply);\n    };\n  }\n\n  // Prepare the operation buffer\n  serializeCommand(self, command, (err, serializedBuffers) => {\n    if (err) throw err;\n\n    // Set the operation's buffer to the serialization of the commands\n    operation.buffer = serializedBuffers;\n\n    // If we have a monitoring operation schedule as the very first operation\n    // Otherwise add to back of queue\n    if (options.monitoring) {\n      self.queue.unshift(operation);\n    } else {\n      self.queue.push(operation);\n    }\n\n    // Attempt to execute the operation\n    if (!self.executing) {\n      process.nextTick(function() {\n        _execute(self)();\n      });\n    }\n  });\n};\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\n// Remove connection method\nfunction remove(connection, connections) {\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\n\nfunction removeConnection(self, connection) {\n  if (remove(connection, self.availableConnections)) return;\n  if (remove(connection, self.inUseConnections)) return;\n}\n\nfunction createConnection(pool, callback) {\n  if (pool.state === DESTROYED || pool.state === DESTROYING) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('Cannot create connection when pool is destroyed'));\n    }\n\n    return;\n  }\n\n  pool.connectingConnections++;\n  connect(pool.options, pool.s.cancellationToken, (err, connection) => {\n    pool.connectingConnections--;\n\n    if (err) {\n      if (pool.logger.isDebug()) {\n        pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      }\n\n      // check if reconnect is enabled, and attempt retry if so\n      if (!pool.reconnectId && pool.options.reconnect) {\n        if (pool.state === CONNECTING && pool.options.legacyCompatMode) {\n          callback(err);\n          return;\n        }\n\n        pool.reconnectError = err;\n        pool.reconnectId = setTimeout(\n          attemptReconnect(pool, callback),\n          pool.options.reconnectInterval\n        );\n\n        return;\n      }\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return;\n    }\n\n    // the pool might have been closed since we started creating the connection\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Pool was destroyed after connection creation'));\n      }\n\n      connection.destroy();\n      return;\n    }\n\n    // otherwise, connect relevant event handlers and add it to our available connections\n    connection.on('error', pool._connectionErrorHandler);\n    connection.on('close', pool._connectionCloseHandler);\n    connection.on('timeout', pool._connectionTimeoutHandler);\n    connection.on('parseError', pool._connectionParseErrorHandler);\n    connection.on('message', pool._messageHandler);\n\n    pool.availableConnections.push(connection);\n\n    // if a callback was provided, return the connection\n    if (typeof callback === 'function') {\n      callback(null, connection);\n    }\n\n    // immediately execute any waiting work\n    _execute(pool)();\n  });\n}\n\nfunction flushMonitoringOperations(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    if (queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(\n        new MongoError({ message: 'no connection available for monitoring', driver: true })\n      );\n    }\n  }\n}\n\nfunction _execute(self) {\n  return function() {\n    if (self.state === DESTROYED) return;\n    // Already executing, skip\n    if (self.executing) return;\n    // Set pool as executing\n    self.executing = true;\n\n    // New pool connections are in progress, wait them to finish\n    // before executing any more operation to ensure distribution of\n    // operations\n    if (self.connectingConnections > 0) {\n      self.executing = false;\n      return;\n    }\n\n    // As long as we have available connections\n    // eslint-disable-next-line\n    while (true) {\n      // Total availble connections\n      const totalConnections = totalConnectionCount(self);\n\n      // No available connections available, flush any monitoring ops\n      if (self.availableConnections.length === 0) {\n        // Flush any monitoring operations\n        flushMonitoringOperations(self.queue);\n\n        // Try to create a new connection to execute stuck operation\n        if (totalConnections < self.options.size && self.queue.length > 0) {\n          createConnection(self);\n        }\n\n        break;\n      }\n\n      // No queue break\n      if (self.queue.length === 0) {\n        break;\n      }\n\n      var connection = null;\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0);\n\n      // No connection found that has no work on it, just pick one for pipelining\n      if (connections.length === 0) {\n        connection =\n          self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n      } else {\n        connection = connections[self.connectionIndex++ % connections.length];\n      }\n\n      // Is the connection connected\n      if (!connection.isConnected()) {\n        // Remove the disconnected connection\n        removeConnection(self, connection);\n        // Flush any monitoring operations in the queue, failing fast\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n\n      // Get the next work item\n      var workItem = self.queue.shift();\n\n      // If we are monitoring we need to use a connection that is not\n      // running another operation to avoid socket timeout changes\n      // affecting an existing operation\n      if (workItem.monitoring) {\n        var foundValidConnection = false;\n\n        for (let i = 0; i < self.availableConnections.length; i++) {\n          // If the connection is connected\n          // And there are no pending workItems on it\n          // Then we can safely use it for monitoring.\n          if (\n            self.availableConnections[i].isConnected() &&\n            self.availableConnections[i].workItems.length === 0\n          ) {\n            foundValidConnection = true;\n            connection = self.availableConnections[i];\n            break;\n          }\n        }\n\n        // No safe connection found, attempt to grow the connections\n        // if possible and break from the loop\n        if (!foundValidConnection) {\n          // Put workItem back on the queue\n          self.queue.unshift(workItem);\n\n          // Attempt to grow the pool if it's not yet maxsize\n          if (totalConnections < self.options.size && self.queue.length > 0) {\n            // Create a new connection\n            createConnection(self);\n          }\n\n          // Re-execute the operation\n          setTimeout(() => _execute(self)(), 10);\n          break;\n        }\n      }\n\n      // Don't execute operation until we have a full pool\n      if (totalConnections < self.options.size) {\n        // Connection has work items, then put it back on the queue\n        // and create a new connection\n        if (connection.workItems.length > 0) {\n          // Lets put the workItem back on the list\n          self.queue.unshift(workItem);\n          // Create a new connection\n          createConnection(self);\n          // Break from the loop\n          break;\n        }\n      }\n\n      // Get actual binary commands\n      var buffer = workItem.buffer;\n\n      // If we are monitoring take the connection of the availableConnections\n      if (workItem.monitoring) {\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n      }\n\n      // Track the executing commands on the mongo server\n      // as long as there is an expected response\n      if (!workItem.noResponse) {\n        connection.workItems.push(workItem);\n      }\n\n      // We have a custom socketTimeout\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\n        connection.setSocketTimeout(workItem.socketTimeout);\n      }\n\n      // Capture if write was successful\n      var writeSuccessful = true;\n\n      // Put operation on the wire\n      if (Array.isArray(buffer)) {\n        for (let i = 0; i < buffer.length; i++) {\n          writeSuccessful = connection.write(buffer[i]);\n        }\n      } else {\n        writeSuccessful = connection.write(buffer);\n      }\n\n      // if the command is designated noResponse, call the callback immeditely\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\n        workItem.cb(null, null);\n      }\n\n      if (writeSuccessful === false) {\n        // If write not successful put back on queue\n        self.queue.unshift(workItem);\n        // Remove the disconnected connection\n        removeConnection(self, connection);\n        // Flush any monitoring operations in the queue, failing fast\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n    }\n\n    self.executing = false;\n  };\n}\n\n// Make execution loop available for testing\nPool._execute = _execute;\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Pool#connect\n * @type {Pool}\n */\n\n/**\n * A server reconnect event, used to verify that pool reconnected.\n *\n * @event Pool#reconnect\n * @type {Pool}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Pool#close\n * @type {Pool}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Pool#error\n * @type {Pool}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Pool#timeout\n * @type {Pool}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Pool#parseError\n * @type {Pool}\n */\n\n/**\n * The driver attempted to reconnect\n *\n * @event Pool#attemptReconnect\n * @type {Pool}\n */\n\n/**\n * The driver exhausted all reconnect attempts\n *\n * @event Pool#reconnectFailed\n * @type {Pool}\n */\n\nmodule.exports = Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}