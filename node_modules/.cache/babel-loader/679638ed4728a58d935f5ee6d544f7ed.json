{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;\nconst CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\nconst MongoError = require('../error').MongoError;\nconst relayEvents = require('../utils').relayEvents;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst Logger = require('../connection/logger');\nconst ServerDescription = require('./server_description').ServerDescription;\nconst compareTopologyVersion = require('./server_description').compareTopologyVersion;\nconst ReadPreference = require('../topologies/read_preference');\nconst Monitor = require('./monitor').Monitor;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst collationNotSupported = require('../utils').collationNotSupported;\nconst debugOptions = require('../connection/utils').debugOptions;\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\nconst isNodeShuttingDownError = require('../error').isNodeShuttingDownError;\nconst isNetworkErrorBeforeHandshake = require('../error').isNetworkErrorBeforeHandshake;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst extractCommand = require('../../command_utils').extractCommand;\nconst common = require('./common');\nconst ServerType = common.ServerType;\nconst isTransactionCommand = require('../transactions').isTransactionCommand;\n\n// Used for filtering out fields for logging\nconst DEBUG_FIELDS = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'servername'];\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\nconst kMonitor = Symbol('monitor');\n\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\nclass Server extends EventEmitter {\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  constructor(description, options, topology) {\n    super();\n    this.s = {\n      // the server description\n      description,\n      // a saved copy of the incoming options\n      options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology\n    };\n\n    // create the connection pool\n    // NOTE: this used to happen in `connect`, we supported overriding pool options there\n    const poolOptions = Object.assign({\n      host: this.description.host,\n      port: this.description.port,\n      bson: this.s.bson\n    }, options);\n    this.s.pool = new ConnectionPool(poolOptions);\n    relayEvents(this.s.pool, this, ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES));\n    this.s.pool.on('clusterTimeReceived', clusterTime => {\n      this.clusterTime = clusterTime;\n    });\n\n    // create the monitor\n    this[kMonitor] = new Monitor(this, this.s.options);\n    relayEvents(this[kMonitor], this, ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed',\n    // legacy events\n    'monitoring']);\n    this[kMonitor].on('resetConnectionPool', () => {\n      this.s.pool.clear();\n    });\n    this[kMonitor].on('resetServer', error => markServerUnknown(this, error));\n    this[kMonitor].on('serverHeartbeatSucceeded', event => {\n      this.emit('descriptionReceived', new ServerDescription(this.description.address, event.reply, {\n        roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)\n      }));\n      if (this.s.state === STATE_CONNECTING) {\n        stateTransition(this, STATE_CONNECTED);\n        this.emit('connect', this);\n      }\n    });\n  }\n  get description() {\n    return this.s.description;\n  }\n  get supportsRetryableWrites() {\n    return supportsRetryableWrites(this);\n  }\n  get name() {\n    return this.s.description.address;\n  }\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n    return null;\n  }\n\n  /**\n   * Initiate server connect\n   */\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n    stateTransition(this, STATE_CONNECTING);\n    this[kMonitor].connect();\n  }\n\n  /**\n   * Destroy the server connection\n   *\n   * @param {object} [options] Optional settings\n   * @param {Boolean} [options.force=false] Force destroy the pool\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = Object.assign({}, {\n      force: false\n    }, options);\n    if (this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    stateTransition(this, STATE_CLOSING);\n    this[kMonitor].close();\n    this.s.pool.close(options, err => {\n      stateTransition(this, STATE_CLOSED);\n      this.emit('closed');\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n  requestCheck() {\n    this[kMonitor].requestCheck();\n  }\n\n  /**\n   * Execute a command\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {object} [options] Optional settings\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      callback = options, options = {}, options = options || {};\n    }\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n    const error = basicReadValidations(this, options);\n    if (error) {\n      return callback(error);\n    }\n\n    // Clone the options\n    options = Object.assign({}, options, {\n      wireProtocolCommand: false\n    });\n\n    // Debug log\n    if (this.s.logger.isDebug()) {\n      const extractedCommand = extractCommand(cmd);\n      this.s.logger.debug(`executing command [${JSON.stringify({\n        ns,\n        cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,\n        options: debugOptions(DEBUG_FIELDS, options)\n      })}] against ${this.name}`);\n    }\n\n    // error if collation not supported\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoError(`server ${this.name} does not support collation`));\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a query against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command document for the query\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  query(ns, cmd, cursorState, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a `getMore` against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  getMore(ns, cursorState, batchSize, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(this, conn, null, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a `killCursors` command against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {function} callback\n   */\n  killCursors(ns, cursorState, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('server is closed'));\n      }\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, undefined, cb));\n    }, callback);\n  }\n\n  /**\n   * Insert one or more documents\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of documents to insert\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'insert',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n  /**\n   * Perform one or more update operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  update(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'update',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n  /**\n   * Perform one or more remove operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'remove',\n      ns,\n      ops\n    }, options, callback);\n  }\n}\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function () {\n    return this.s.topology.clusterTime;\n  },\n  set: function (clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\nfunction supportsRetryableWrites(server) {\n  return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;\n}\nfunction calculateRoundTripTime(oldRtt, duration) {\n  if (oldRtt === -1) {\n    return duration;\n  }\n  const alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\nfunction basicReadValidations(server, options) {\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const server = args.server;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(`server ${server.name} does not support collation`));\n    return;\n  }\n  const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;\n  if (unacknowledgedWrite || maxWireVersion(server) < 5) {\n    if ((op === 'update' || op === 'remove') && ops.find(o => o.hint)) {\n      callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));\n      return;\n    }\n  }\n  server.s.pool.withConnection((err, conn, cb) => {\n    if (err) {\n      markServerUnknown(server, err);\n      return cb(err);\n    }\n    conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));\n  }, callback);\n}\nfunction markServerUnknown(server, error) {\n  if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {\n    server[kMonitor].reset();\n  }\n  server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {\n    error,\n    topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion\n  }));\n}\nfunction connectionIsStale(pool, connection) {\n  return connection.generation !== pool.generation;\n}\nfunction shouldHandleStateChangeError(server, err) {\n  const etv = err.topologyVersion;\n  const stv = server.description.topologyVersion;\n  return compareTopologyVersion(stv, etv) < 0;\n}\nfunction inActiveTransaction(session, cmd) {\n  return session && session.inTransaction() && !isTransactionCommand(cmd);\n}\nfunction makeOperationHandler(server, connection, cmd, options, callback) {\n  const session = options && options.session;\n  return function handleOperationResult(err, result) {\n    if (err && !connectionIsStale(server.s.pool, connection)) {\n      if (err instanceof MongoNetworkError) {\n        if (session && !session.hasEnded) {\n          session.serverSession.isDirty = true;\n        }\n        if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n        if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else {\n        // if pre-4.4 server, then add error label if its a retryable write error\n        if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n        if (isSDAMUnrecoverableError(err)) {\n          if (shouldHandleStateChangeError(server, err)) {\n            if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n              server.s.pool.clear();\n            }\n            markServerUnknown(server, err);\n            process.nextTick(() => server.requestCheck());\n          }\n        }\n      }\n    }\n    callback(err, result);\n  };\n}\nmodule.exports = {\n  Server\n};","map":{"version":3,"names":["EventEmitter","require","ConnectionPool","CMAP_EVENT_NAMES","MongoError","relayEvents","BSON","retrieveBSON","Logger","ServerDescription","compareTopologyVersion","ReadPreference","Monitor","MongoNetworkError","MongoNetworkTimeoutError","collationNotSupported","debugOptions","isSDAMUnrecoverableError","isRetryableWriteError","isNodeShuttingDownError","isNetworkErrorBeforeHandshake","maxWireVersion","makeStateMachine","extractCommand","common","ServerType","isTransactionCommand","DEBUG_FIELDS","STATE_CLOSING","STATE_CLOSED","STATE_CONNECTING","STATE_CONNECTED","stateTransition","kMonitor","Symbol","Server","constructor","description","options","topology","s","logger","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Timestamp","state","credentials","poolOptions","Object","assign","host","port","pool","concat","on","clusterTime","clear","error","markServerUnknown","event","emit","address","reply","roundTripTime","calculateRoundTripTime","duration","supportsRetryableWrites","name","autoEncrypter","connect","destroy","callback","force","close","err","requestCheck","command","ns","cmd","basicReadValidations","wireProtocolCommand","isDebug","extractedCommand","debug","JSON","stringify","shouldRedact","withConnection","conn","cb","makeOperationHandler","query","cursorState","getMore","batchSize","killCursors","undefined","insert","ops","executeWriteOperation","server","op","update","remove","defineProperty","prototype","get","set","logicalSessionTimeoutMinutes","type","Standalone","oldRtt","alpha","readPreference","args","Array","isArray","unacknowledgedWrite","writeConcern","w","find","o","hint","reset","topologyVersion","connectionIsStale","connection","generation","shouldHandleStateChangeError","etv","stv","inActiveTransaction","session","inTransaction","handleOperationResult","result","hasEnded","serverSession","isDirty","addErrorLabel","process","nextTick","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/sdam/server.js"],"sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;\nconst CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\nconst MongoError = require('../error').MongoError;\nconst relayEvents = require('../utils').relayEvents;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst Logger = require('../connection/logger');\nconst ServerDescription = require('./server_description').ServerDescription;\nconst compareTopologyVersion = require('./server_description').compareTopologyVersion;\nconst ReadPreference = require('../topologies/read_preference');\nconst Monitor = require('./monitor').Monitor;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst collationNotSupported = require('../utils').collationNotSupported;\nconst debugOptions = require('../connection/utils').debugOptions;\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\nconst isNodeShuttingDownError = require('../error').isNodeShuttingDownError;\nconst isNetworkErrorBeforeHandshake = require('../error').isNetworkErrorBeforeHandshake;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst extractCommand = require('../../command_utils').extractCommand;\nconst common = require('./common');\nconst ServerType = common.ServerType;\nconst isTransactionCommand = require('../transactions').isTransactionCommand;\n\n// Used for filtering out fields for logging\nconst DEBUG_FIELDS = [\n  'reconnect',\n  'reconnectTries',\n  'reconnectInterval',\n  'emitError',\n  'cursorFactory',\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'checkServerIdentity',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'key',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'servername'\n];\n\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\nconst kMonitor = Symbol('monitor');\n\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\nclass Server extends EventEmitter {\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  constructor(description, options, topology) {\n    super();\n\n    this.s = {\n      // the server description\n      description,\n      // a saved copy of the incoming options\n      options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson:\n        options.bson ||\n        new BSON([\n          BSON.Binary,\n          BSON.Code,\n          BSON.DBRef,\n          BSON.Decimal128,\n          BSON.Double,\n          BSON.Int32,\n          BSON.Long,\n          BSON.Map,\n          BSON.MaxKey,\n          BSON.MinKey,\n          BSON.ObjectId,\n          BSON.BSONRegExp,\n          BSON.Symbol,\n          BSON.Timestamp\n        ]),\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology\n    };\n\n    // create the connection pool\n    // NOTE: this used to happen in `connect`, we supported overriding pool options there\n    const poolOptions = Object.assign(\n      { host: this.description.host, port: this.description.port, bson: this.s.bson },\n      options\n    );\n\n    this.s.pool = new ConnectionPool(poolOptions);\n    relayEvents(\n      this.s.pool,\n      this,\n      ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES)\n    );\n\n    this.s.pool.on('clusterTimeReceived', clusterTime => {\n      this.clusterTime = clusterTime;\n    });\n\n    // create the monitor\n    this[kMonitor] = new Monitor(this, this.s.options);\n    relayEvents(this[kMonitor], this, [\n      'serverHeartbeatStarted',\n      'serverHeartbeatSucceeded',\n      'serverHeartbeatFailed',\n\n      // legacy events\n      'monitoring'\n    ]);\n\n    this[kMonitor].on('resetConnectionPool', () => {\n      this.s.pool.clear();\n    });\n\n    this[kMonitor].on('resetServer', error => markServerUnknown(this, error));\n    this[kMonitor].on('serverHeartbeatSucceeded', event => {\n      this.emit(\n        'descriptionReceived',\n        new ServerDescription(this.description.address, event.reply, {\n          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)\n        })\n      );\n\n      if (this.s.state === STATE_CONNECTING) {\n        stateTransition(this, STATE_CONNECTED);\n        this.emit('connect', this);\n      }\n    });\n  }\n\n  get description() {\n    return this.s.description;\n  }\n\n  get supportsRetryableWrites() {\n    return supportsRetryableWrites(this);\n  }\n\n  get name() {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n    return null;\n  }\n\n  /**\n   * Initiate server connect\n   */\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n    this[kMonitor].connect();\n  }\n\n  /**\n   * Destroy the server connection\n   *\n   * @param {object} [options] Optional settings\n   * @param {Boolean} [options.force=false] Force destroy the pool\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = Object.assign({}, { force: false }, options);\n\n    if (this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n\n    this[kMonitor].close();\n    this.s.pool.close(options, err => {\n      stateTransition(this, STATE_CLOSED);\n      this.emit('closed');\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n  requestCheck() {\n    this[kMonitor].requestCheck();\n  }\n\n  /**\n   * Execute a command\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {object} [options] Optional settings\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      (callback = options), (options = {}), (options = options || {});\n    }\n\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    const error = basicReadValidations(this, options);\n    if (error) {\n      return callback(error);\n    }\n\n    // Clone the options\n    options = Object.assign({}, options, { wireProtocolCommand: false });\n\n    // Debug log\n    if (this.s.logger.isDebug()) {\n      const extractedCommand = extractCommand(cmd);\n      this.s.logger.debug(\n        `executing command [${JSON.stringify({\n          ns,\n          cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,\n          options: debugOptions(DEBUG_FIELDS, options)\n        })}] against ${this.name}`\n      );\n    }\n\n    // error if collation not supported\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoError(`server ${this.name} does not support collation`));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a query against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command document for the query\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  query(ns, cmd, cursorState, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a `getMore` against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  getMore(ns, cursorState, batchSize, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.getMore(\n        ns,\n        cursorState,\n        batchSize,\n        options,\n        makeOperationHandler(this, conn, null, options, cb)\n      );\n    }, callback);\n  }\n\n  /**\n   * Execute a `killCursors` command against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {function} callback\n   */\n  killCursors(ns, cursorState, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('server is closed'));\n      }\n\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, undefined, cb));\n    }, callback);\n  }\n\n  /**\n   * Insert one or more documents\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of documents to insert\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'insert', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more update operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  update(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'update', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more remove operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'remove', ns, ops }, options, callback);\n  }\n}\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function() {\n    return this.s.topology.clusterTime;\n  },\n  set: function(clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction supportsRetryableWrites(server) {\n  return (\n    server.description.maxWireVersion >= 6 &&\n    server.description.logicalSessionTimeoutMinutes &&\n    server.description.type !== ServerType.Standalone\n  );\n}\n\nfunction calculateRoundTripTime(oldRtt, duration) {\n  if (oldRtt === -1) {\n    return duration;\n  }\n\n  const alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\n\nfunction basicReadValidations(server, options) {\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const server = args.server;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(`server ${server.name} does not support collation`));\n    return;\n  }\n  const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;\n  if (unacknowledgedWrite || maxWireVersion(server) < 5) {\n    if ((op === 'update' || op === 'remove') && ops.find(o => o.hint)) {\n      callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));\n      return;\n    }\n  }\n\n  server.s.pool.withConnection((err, conn, cb) => {\n    if (err) {\n      markServerUnknown(server, err);\n      return cb(err);\n    }\n\n    conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));\n  }, callback);\n}\n\nfunction markServerUnknown(server, error) {\n  if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {\n    server[kMonitor].reset();\n  }\n\n  server.emit(\n    'descriptionReceived',\n    new ServerDescription(server.description.address, null, {\n      error,\n      topologyVersion:\n        error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion\n    })\n  );\n}\n\nfunction connectionIsStale(pool, connection) {\n  return connection.generation !== pool.generation;\n}\n\nfunction shouldHandleStateChangeError(server, err) {\n  const etv = err.topologyVersion;\n  const stv = server.description.topologyVersion;\n\n  return compareTopologyVersion(stv, etv) < 0;\n}\n\nfunction inActiveTransaction(session, cmd) {\n  return session && session.inTransaction() && !isTransactionCommand(cmd);\n}\n\nfunction makeOperationHandler(server, connection, cmd, options, callback) {\n  const session = options && options.session;\n\n  return function handleOperationResult(err, result) {\n    if (err && !connectionIsStale(server.s.pool, connection)) {\n      if (err instanceof MongoNetworkError) {\n        if (session && !session.hasEnded) {\n          session.serverSession.isDirty = true;\n        }\n\n        if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else {\n        // if pre-4.4 server, then add error label if its a retryable write error\n        if (\n          maxWireVersion(server) < 9 &&\n          isRetryableWriteError(err) &&\n          !inActiveTransaction(session, cmd)\n        ) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (isSDAMUnrecoverableError(err)) {\n          if (shouldHandleStateChangeError(server, err)) {\n            if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n              server.s.pool.clear();\n            }\n\n            markServerUnknown(server, err);\n            process.nextTick(() => server.requestCheck());\n          }\n        }\n      }\n    }\n\n    callback(err, result);\n  };\n}\n\nmodule.exports = {\n  Server\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}