{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst EventEmitter = require('events');\nconst connect = require('../connection/connect');\nconst Connection = require('../../cmap/connection').Connection;\nconst common = require('./common');\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\nconst now = require('../../utils').now;\nconst sdamEvents = require('./events');\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kRTTPinger = Symbol('rttPinger');\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    });\n\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      host: server.description.host,\n      port: server.description.port,\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, this.options,\n    // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true,\n      bsonRegExp: true\n    });\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n\n    // ensure encryption is not requested for monitoring\n    delete connectOptions.autoEncrypter;\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n    this[kMonitorId].wake();\n  }\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\nfunction resetMonitorState(monitor) {\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n  monitor[kCancellationToken].emit('cancel');\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({\n      force: true\n    });\n  }\n}\nfunction checkServer(monitor, callback) {\n  let start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({\n        force: true\n      });\n      monitor[kConnection] = undefined;\n    }\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = {\n      ismaster: true\n    };\n    const options = {\n      socketTimeout: connectTimeoutMS\n    };\n    if (isAwaitable) {\n      cmd.maxAwaitTimeMS = maxAwaitTimeMS;\n      cmd.topologyVersion = makeTopologyVersion(topologyVersion);\n      if (connectTimeoutMS) {\n        options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;\n      }\n      options.exhaustAllowed = true;\n      if (monitor[kRTTPinger] == null) {\n        monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n      }\n    }\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n      const isMaster = result.result;\n      const rttPinger = monitor[kRTTPinger];\n      const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);\n      monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));\n\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n        callback(undefined, isMaster);\n      }\n    });\n    return;\n  }\n\n  // connecting does an implicit `ismaster`\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n    if (err) {\n      monitor[kConnection] = undefined;\n\n      // we already reset the connection pool on network errors in all cases\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n      failureHandler(err);\n      return;\n    }\n    monitor[kConnection] = conn;\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));\n    callback(undefined, conn.ismaster);\n  });\n}\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n      callback();\n    }\n\n    // TODO: the next line is a legacy event, remove in v4\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n      done();\n    });\n  };\n}\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n  close() {\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n    this[kMonitorId] = undefined;\n    if (this[kConnection]) {\n      this[kConnection].destroy({\n        force: true\n      });\n    }\n  }\n}\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = now();\n  const cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n  if (rttPinger.closed) {\n    return;\n  }\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n  rttPinger[kConnection].command('admin.$cmd', {\n    ismaster: 1\n  }, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n    measureAndReschedule();\n  });\n}\nmodule.exports = {\n  Monitor\n};","map":{"version":3,"names":["ServerType","require","EventEmitter","connect","Connection","common","makeStateMachine","MongoNetworkError","BSON","retrieveBSON","makeInterruptableAsyncInterval","calculateDurationInMs","now","sdamEvents","ServerHeartbeatStartedEvent","ServerHeartbeatSucceededEvent","ServerHeartbeatFailedEvent","kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kRTTPinger","kRoundTripTime","STATE_CLOSED","STATE_CLOSING","STATE_IDLE","STATE_MONITORING","stateTransition","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","constructor","server","options","undefined","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","connectionTimeout","heartbeatFrequencyMS","minHeartbeatFrequencyMS","connectOptions","assign","id","host","port","bson","connectionType","raw","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","credentials","autoEncrypter","monitorServer","interval","minInterval","immediate","requestCheck","has","wake","reset","topologyVersion","resetMonitorState","close","emit","stop","clearTimeout","destroy","force","checkServer","callback","start","failureHandler","err","closed","maxAwaitTimeMS","isAwaitable","cmd","ismaster","socketTimeout","makeTopologyVersion","exhaustAllowed","RTTPinger","command","result","isMaster","rttPinger","duration","roundTripTime","conn","done","process","nextTick","type","Unknown","setTimeout","tv","processId","counter","Long","fromNumber","cancellationToken","measureRoundTripTime","measureAndReschedule","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/sdam/monitor.js"],"sourcesContent":["'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst EventEmitter = require('events');\nconst connect = require('../connection/connect');\nconst Connection = require('../../cmap/connection').Connection;\nconst common = require('./common');\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\n\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kRTTPinger = Symbol('rttPinger');\nconst kRoundTripTime = Symbol('roundTripTime');\n\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS:\n        typeof options.connectionTimeout === 'number'\n          ? options.connectionTimeout\n          : typeof options.connectTimeoutMS === 'number'\n          ? options.connectTimeoutMS\n          : 10000,\n      heartbeatFrequencyMS:\n        typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS:\n        typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    });\n\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign(\n      {\n        id: '<monitor>',\n        host: server.description.host,\n        port: server.description.port,\n        bson: server.s.bson,\n        connectionType: Connection\n      },\n      server.s.options,\n      this.options,\n\n      // force BSON serialization options\n      {\n        raw: false,\n        promoteLongs: true,\n        promoteValues: true,\n        promoteBuffers: true,\n        bsonRegExp: true\n      }\n    );\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n\n    // ensure encryption is not requested for monitoring\n    delete connectOptions.autoEncrypter;\n\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\n\nfunction resetMonitorState(monitor) {\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n\n  monitor[kCancellationToken].emit('cancel');\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({ force: true });\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  let start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({ force: true });\n      monitor[kConnection] = undefined;\n    }\n\n    monitor.emit(\n      'serverHeartbeatFailed',\n      new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address)\n    );\n\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n\n    const cmd = { ismaster: true };\n    const options = { socketTimeout: connectTimeoutMS };\n\n    if (isAwaitable) {\n      cmd.maxAwaitTimeMS = maxAwaitTimeMS;\n      cmd.topologyVersion = makeTopologyVersion(topologyVersion);\n      if (connectTimeoutMS) {\n        options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;\n      }\n      options.exhaustAllowed = true;\n      if (monitor[kRTTPinger] == null) {\n        monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n      }\n    }\n\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      const isMaster = result.result;\n      const rttPinger = monitor[kRTTPinger];\n\n      const duration =\n        isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);\n\n      monitor.emit(\n        'serverHeartbeatSucceeded',\n        new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)\n      );\n\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n\n        callback(undefined, isMaster);\n      }\n    });\n\n    return;\n  }\n\n  // connecting does an implicit `ismaster`\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({ force: true });\n      return;\n    }\n\n    if (err) {\n      monitor[kConnection] = undefined;\n\n      // we already reset the connection pool on network errors in all cases\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    monitor.emit(\n      'serverHeartbeatSucceeded',\n      new ServerHeartbeatSucceededEvent(\n        calculateDurationInMs(start),\n        conn.ismaster,\n        monitor.address\n      )\n    );\n\n    callback(undefined, conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    // TODO: the next line is a legacy event, remove in v4\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    this.closed = true;\n\n    clearTimeout(this[kMonitorId]);\n    this[kMonitorId] = undefined;\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({ force: true });\n    }\n  }\n}\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = now();\n  const cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({ force: true });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(\n      () => measureRoundTripTime(rttPinger, options),\n      heartbeatFrequencyMS\n    );\n  }\n\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n\n    return;\n  }\n\n  rttPinger[kConnection].command('admin.$cmd', { ismaster: 1 }, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\nmodule.exports = {\n  Monitor\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}