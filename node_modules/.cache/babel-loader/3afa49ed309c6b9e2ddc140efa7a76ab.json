{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst MessageStream = require('./message_stream');\nconst MongoError = require('../core/error').MongoError;\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\nconst CommandResult = require('../core/connection/command_result');\nconst StreamDescription = require('./stream_description').StreamDescription;\nconst wp = require('../core/wireprotocol');\nconst apm = require('../core/connection/apm');\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\nconst uuidV4 = require('../core/utils').uuidV4;\nconst now = require('../utils').now;\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    this.host = options.host || 'localhost';\n    this.port = options.port || 27017;\n    this.monitorCommands = typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // retain a reference to an `AutoEncrypter` if present\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    }\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    this[kMessageStream].on('error', error => this.handleIssue({\n      destroy: error\n    }));\n    stream.on('close', () => this.handleIssue({\n      isClose: true\n    }));\n    stream.on('timeout', () => this.handleIssue({\n      isTimeout: true,\n      destroy: true\n    }));\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n  get description() {\n    return this[kDescription];\n  }\n  get ismaster() {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n  get stream() {\n    return this[kStream];\n  }\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n\n  /**\n   * @param {{ isTimeout?: boolean; isClose?: boolean; destroy?: boolean | Error }} issue\n   */\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n    this.closed = true;\n    for (const idAndOp of this[kQueue]) {\n      const op = idAndOp[1];\n      if (issue.isTimeout) {\n        op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n          beforeHandshake: this.ismaster == null\n        }));\n      } else if (issue.isClose) {\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n    this[kQueue].clear();\n    this.emit('close');\n  }\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = Object.assign({\n      force: false\n    }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    this[kStream].end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  // Wire protocol methods\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n}\n\n/// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: {\n        write: write.bind(connection),\n        isConnected: () => true\n      }\n    }\n  };\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n  return server;\n}\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    }\n\n    // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n    callback(undefined, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));\n  };\n}\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n  return uuidV4().toString('hex');\n}\n\n// Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operationDescription.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));\n        } else {\n          this.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));\n        }\n      }\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\nmodule.exports = {\n  Connection\n};","map":{"version":3,"names":["EventEmitter","require","MessageStream","MongoError","MongoNetworkError","MongoNetworkTimeoutError","MongoWriteConcernError","CommandResult","StreamDescription","wp","apm","updateSessionFromResponse","uuidV4","now","calculateDurationInMs","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","Connection","constructor","stream","options","id","address","streamIdentifier","bson","socketTimeout","host","port","monitorCommands","closed","destroyed","generation","autoEncrypter","Map","on","messageHandler","error","handleIssue","destroy","isClose","isTimeout","pipe","description","ismaster","response","receiveResponse","idleTime","clusterTime","markAvailable","issue","undefined","idAndOp","op","cb","beforeHandshake","clear","emit","callback","Object","assign","force","end","err","command","ns","cmd","makeServerTrampoline","query","cursorState","getMore","batchSize","killCursors","insert","ops","update","remove","connection","server","s","pool","write","bind","isConnected","conn","message","has","responseTo","operationDescription","get","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","documents","document","session","$clusterTime","writeConcernError","ok","$err","errmsg","code","fullResult","remoteAddress","remotePort","toString","noResponse","documentsReturnedIn","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","raw","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","started","reply","CommandFailedEvent","result","CommandSucceededEvent","writeCommand","e","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/cmap/connection.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst MessageStream = require('./message_stream');\nconst MongoError = require('../core/error').MongoError;\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\nconst CommandResult = require('../core/connection/command_result');\nconst StreamDescription = require('./stream_description').StreamDescription;\nconst wp = require('../core/wireprotocol');\nconst apm = require('../core/connection/apm');\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\nconst uuidV4 = require('../core/utils').uuidV4;\nconst now = require('../utils').now;\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    this.host = options.host || 'localhost';\n    this.port = options.port || 27017;\n    this.monitorCommands =\n      typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // retain a reference to an `AutoEncrypter` if present\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    }\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    this[kMessageStream].on('error', error => this.handleIssue({ destroy: error }));\n    stream.on('close', () => this.handleIssue({ isClose: true }));\n    stream.on('timeout', () => this.handleIssue({ isTimeout: true, destroy: true }));\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n\n  /**\n   * @param {{ isTimeout?: boolean; isClose?: boolean; destroy?: boolean | Error }} issue\n   */\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const idAndOp of this[kQueue]) {\n      const op = idAndOp[1];\n      if (issue.isTimeout) {\n        op.cb(\n          new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n            beforeHandshake: this.ismaster == null\n          })\n        );\n      } else if (issue.isClose) {\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit('close');\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  // Wire protocol methods\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n}\n\n/// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: { write: write.bind(connection), isConnected: () => true }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    }\n\n    // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n    callback(\n      undefined,\n      new CommandResult(\n        operationDescription.fullResult ? message : message.documents[0],\n        conn,\n        message\n      )\n    );\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\n// Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started)\n          );\n        } else {\n          this.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}