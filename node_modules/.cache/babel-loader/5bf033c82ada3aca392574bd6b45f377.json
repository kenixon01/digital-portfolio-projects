{"ast":null,"code":"'use strict';\n\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\nconst EventEmitter = require('events');\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nconst uuidV4 = require('./utils').uuidV4;\nconst MongoError = require('./error').MongoError;\nconst isRetryableError = require('././error').isRetryableError;\nconst MongoNetworkError = require('./error').MongoNetworkError;\nconst MongoWriteConcernError = require('./error').MongoWriteConcernError;\nconst Transaction = require('./transactions').Transaction;\nconst TxnState = require('./transactions').TxnState;\nconst isPromiseLike = require('./utils').isPromiseLike;\nconst ReadPreference = require('./topologies/read_preference');\nconst maybePromise = require('../utils').maybePromise;\nconst isTransactionCommand = require('./transactions').isTransactionCommand;\nconst resolveClusterTime = require('./topologies/shared').resolveClusterTime;\nconst isSharded = require('./wireprotocol/shared').isSharded;\nconst maxWireVersion = require('./utils').maxWireVersion;\nconst now = require('./../utils').now;\nconst calculateDurationInMs = require('./../utils').calculateDurationInMs;\nconst minWireVersionForShardedTransactions = 8;\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new MongoError('Cannot use a session that has ended');\n    if (typeof callback === 'function') {\n      callback(error, null);\n      return false;\n    }\n    throw error;\n  }\n  return true;\n}\n\n/**\n * Options to pass when creating a Client Session\n * @typedef {Object} SessionOptions\n * @property {boolean} [causalConsistency=true] Whether causal consistency should be enabled on this session\n * @property {TransactionOptions} [defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.\n */\n\n/**\n * A BSON document reflecting the lsid of a {@link ClientSession}\n * @typedef {Object} SessionId\n */\n\nconst kServerSession = Symbol('serverSession');\n\n/**\n * A class representing a client session on the server\n * WARNING: not meant to be instantiated directly.\n * @class\n * @hideconstructor\n */\nclass ClientSession extends EventEmitter {\n  /**\n   * Create a client session.\n   * WARNING: not meant to be instantiated directly\n   *\n   * @param {Topology} topology The current client's topology (Internal Class)\n   * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)\n   * @param {SessionOptions} [options] Optional settings\n   * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n    if (topology == null) {\n      throw new Error('ClientSession requires a topology');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new Error('ClientSession requires a ServerSessionPool');\n    }\n    options = options || {};\n    clientOptions = clientOptions || {};\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n    this.supports = {\n      causalConsistency: typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = null;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n\n  /**\n   * The server id associated with this session\n   * @type {SessionId}\n   */\n  get id() {\n    return this.serverSession.id;\n  }\n  get serverSession() {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    }\n    return this[kServerSession];\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param {Object} [options] Optional settings. Currently reserved for future use\n   * @param {Function} [callback] Optional callback for completion of this operation\n   */\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {};\n    const session = this;\n    return maybePromise(this, callback, done => {\n      if (session.hasEnded) {\n        return done();\n      }\n      function completeEndSession() {\n        // release the server session back to the pool\n        session.sessionPool.release(session.serverSession);\n        session[kServerSession] = undefined;\n\n        // mark the session as ended, and emit a signal\n        session.hasEnded = true;\n        session.emit('ended', session);\n\n        // spec indicates that we should ignore all errors for `endSessions`\n        done();\n      }\n      if (session.serverSession && session.inTransaction()) {\n        session.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n        return;\n      }\n      completeEndSession();\n    });\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Used to determine if this session equals another\n   * @param {ClientSession} session\n   * @return {boolean} true if the sessions are equal\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n\n  /**\n   * Increment the transaction number on the internal ServerSession\n   */\n  incrementTransactionNumber() {\n    this.serverSession.txnNumber++;\n  }\n\n  /**\n   * @returns {boolean} whether this session is currently in a transaction or not\n   */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param {TransactionOptions} options Options for the transaction\n   */\n  startTransaction(options) {\n    assertAlive(this);\n    if (this.inTransaction()) {\n      throw new MongoError('Transaction already in progress');\n    }\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\n    if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new MongoError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n\n    // create transaction state\n    this.transaction = new Transaction(Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions));\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n  commitTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'commitTransaction', done));\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n  abortTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'abortTransaction', done));\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   * @ignore\n   */\n  toBSON() {\n    throw new Error('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * A user provided function to be run within a transaction\n   *\n   * @callback WithTransactionCallback\n   * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.\n   * @returns {Promise} The resulting Promise of operations run within this transaction\n   */\n\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param {WithTransactionCallback} fn\n   * @param {TransactionOptions} [options] Optional settings for the transaction\n   */\n  withTransaction(fn, options) {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst UNSATISFIABLE_WRITE_CONCERN_CODE = 100;\nconst UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;\nconst MAX_TIME_MS_EXPIRED_CODE = 50;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction hasNotTimedOut(startTime, max) {\n  return calculateDurationInMs(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;\n}\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null) return false;\n  return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;\n}\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n    throw err;\n  });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([TxnState.NO_TRANSACTION, TxnState.TRANSACTION_COMMITTED, TxnState.TRANSACTION_ABORTED]);\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options) {\n  session.startTransaction(options);\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new TypeError('Function provided to `withTransaction` must return a Promise');\n  }\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }).catch(err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel('UnknownTransactionCommitResult');\n      }\n      throw err;\n    }\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n    return maybeRetryOrThrow(err);\n  });\n}\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  }\n\n  // handle any initial problematic cases\n  let txnState = session.transaction.state;\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoError('No transaction started'));\n    return;\n  }\n  if (commandName === 'commitTransaction') {\n    if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback(null, null);\n      return;\n    }\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback(null, null);\n      return;\n    }\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call abortTransaction twice'));\n      return;\n    }\n    if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n\n  // construct and send the command\n  const command = {\n    [commandName]: 1\n  };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.w) {\n    writeConcern = {\n      w: session.clientOptions.w\n    };\n  }\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n  function commandHandler(e, r) {\n    if (commandName === 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n      if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult');\n\n          // per txns spec, must unpin session in this case\n          session.transaction.unpinServer();\n        }\n      }\n    } else {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n    }\n    callback(e, r);\n  }\n\n  // The spec indicates that we should ignore all errors on `abortTransaction`\n  function transactionError(err) {\n    return commandName === 'commitTransaction' ? err : null;\n  }\n  if (\n  // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n  session.transaction.recoveryToken && supportsRecoveryToken(session)) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  // send the command\n  session.topology.command('admin.$cmd', command, {\n    session\n  }, (err, reply) => {\n    if (err && isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.transaction.unpinServer();\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n      return session.topology.command('admin.$cmd', command, {\n        session\n      }, (_err, _reply) => commandHandler(transactionError(_err), _reply));\n    }\n    commandHandler(transactionError(err), reply);\n  });\n}\nfunction supportsRecoveryToken(session) {\n  const topology = session.topology;\n  return !!topology.s.options.useRecoveryToken;\n}\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @ignore\n */\nclass ServerSession {\n  constructor() {\n    this.id = {\n      id: new Binary(uuidV4(), Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   * @ignore\n   * @param {Date} sessionTimeoutMinutes The server's \"logicalSessionTimeoutMinutes\"\n   * @return {boolean} true if the session has timed out.\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @ignore\n */\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new Error('ServerSessionPool requires a topology');\n    }\n    this.topology = topology;\n    this.sessions = [];\n  }\n\n  /**\n   * Ends all sessions in the session pool.\n   * @ignore\n   */\n  endAllPooledSessions(callback) {\n    if (this.sessions.length) {\n      this.topology.endSessions(this.sessions.map(session => session.id), () => {\n        this.sessions = [];\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n      return;\n    }\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession\n   * is created.\n   * @ignore\n   * @returns {ServerSession}\n   */\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        return session;\n      }\n    }\n    return new ServerSession();\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   * @ignore\n   * @param {ServerSession} session The session to release to the pool\n   */\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {\n    return true;\n  }\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @ignore\n * @param {ClientSession} session the session tracking transaction state\n * @param {Object} command the command to decorate\n * @param {Object} topology the topology for tracking the cluster time\n * @param {Object} [options] Optional settings passed to calling operation\n * @return {MongoError|null} An error, if some error condition was met\n */\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n    return new MongoError('Cannot use a session that has ended');\n  }\n\n  // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    return;\n  }\n  const serverSession = session.serverSession;\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  // first apply non-transaction-specific sessions data\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = options.willRetryWrite;\n  const shouldApplyReadConcern = commandSupportsReadConcern(command, options);\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  // now attempt to apply transaction-specific sessions data\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    // TODO: the following should only be applied to read operation per spec.\n    // for causal consistency\n    if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n    return;\n  }\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(`Read preference in a transaction must be primary, not: ${options.readPreference.mode}`);\n  }\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    resolveClusterTime(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n}\nmodule.exports = {\n  ClientSession,\n  ServerSession,\n  ServerSessionPool,\n  TxnState,\n  applySession,\n  updateSessionFromResponse,\n  commandSupportsReadConcern\n};","map":{"version":3,"names":["retrieveBSON","require","EventEmitter","BSON","Binary","uuidV4","MongoError","isRetryableError","MongoNetworkError","MongoWriteConcernError","Transaction","TxnState","isPromiseLike","ReadPreference","maybePromise","isTransactionCommand","resolveClusterTime","isSharded","maxWireVersion","now","calculateDurationInMs","minWireVersionForShardedTransactions","assertAlive","session","callback","serverSession","error","kServerSession","Symbol","ClientSession","constructor","topology","sessionPool","options","clientOptions","Error","ServerSessionPool","hasEnded","undefined","supports","causalConsistency","clusterTime","initialClusterTime","operationTime","explicit","owner","defaultTransactionOptions","Object","assign","transaction","id","acquire","endSession","done","completeEndSession","release","emit","inTransaction","abortTransaction","err","advanceOperationTime","greaterThan","equals","buffer","incrementTransactionNumber","txnNumber","isActive","startTransaction","topologyMaxWireVersion","transition","STARTING_TRANSACTION","commitTransaction","endTransaction","toBSON","withTransaction","fn","startTime","attemptTransaction","MAX_WITH_TRANSACTION_TIMEOUT","UNSATISFIABLE_WRITE_CONCERN_CODE","UNKNOWN_REPL_WRITE_CONCERN_CODE","MAX_TIME_MS_EXPIRED_CODE","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","isUnknownTransactionCommitResult","isMaxTimeMSExpiredError","has","codeName","code","writeConcernError","attemptTransactionCommit","catch","hasErrorLabel","USER_EXPLICIT_TXN_END_STATES","NO_TRANSACTION","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","state","promise","Promise","reject","TypeError","then","maybeRetryOrThrow","addErrorLabel","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","writeConcern","w","wtimeout","maxTimeMS","commandHandler","e","r","unpinServer","transactionError","recoveryToken","supportsRecoveryToken","reply","_err","_reply","s","useRecoveryToken","ServerSession","SUBTYPE_UUID","lastUse","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","sessions","endAllPooledSessions","length","endSessions","map","logicalSessionTimeoutMinutes","shift","pooledSession","pop","unshift","commandSupportsReadConcern","aggregate","count","distinct","find","parallelCollectionScan","geoNear","geoSearch","mapReduce","out","inline","applySession","lsid","isRetryableWrite","willRetryWrite","shouldApplyReadConcern","Long","fromNumber","readConcern","afterClusterTime","readPreference","primary","mode","autocommit","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/sessions.js"],"sourcesContent":["'use strict';\n\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\nconst EventEmitter = require('events');\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nconst uuidV4 = require('./utils').uuidV4;\nconst MongoError = require('./error').MongoError;\nconst isRetryableError = require('././error').isRetryableError;\nconst MongoNetworkError = require('./error').MongoNetworkError;\nconst MongoWriteConcernError = require('./error').MongoWriteConcernError;\nconst Transaction = require('./transactions').Transaction;\nconst TxnState = require('./transactions').TxnState;\nconst isPromiseLike = require('./utils').isPromiseLike;\nconst ReadPreference = require('./topologies/read_preference');\nconst maybePromise = require('../utils').maybePromise;\nconst isTransactionCommand = require('./transactions').isTransactionCommand;\nconst resolveClusterTime = require('./topologies/shared').resolveClusterTime;\nconst isSharded = require('./wireprotocol/shared').isSharded;\nconst maxWireVersion = require('./utils').maxWireVersion;\nconst now = require('./../utils').now;\nconst calculateDurationInMs = require('./../utils').calculateDurationInMs;\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new MongoError('Cannot use a session that has ended');\n    if (typeof callback === 'function') {\n      callback(error, null);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n\n/**\n * Options to pass when creating a Client Session\n * @typedef {Object} SessionOptions\n * @property {boolean} [causalConsistency=true] Whether causal consistency should be enabled on this session\n * @property {TransactionOptions} [defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.\n */\n\n/**\n * A BSON document reflecting the lsid of a {@link ClientSession}\n * @typedef {Object} SessionId\n */\n\nconst kServerSession = Symbol('serverSession');\n\n/**\n * A class representing a client session on the server\n * WARNING: not meant to be instantiated directly.\n * @class\n * @hideconstructor\n */\nclass ClientSession extends EventEmitter {\n  /**\n   * Create a client session.\n   * WARNING: not meant to be instantiated directly\n   *\n   * @param {Topology} topology The current client's topology (Internal Class)\n   * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)\n   * @param {SessionOptions} [options] Optional settings\n   * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n\n    if (topology == null) {\n      throw new Error('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new Error('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options || {};\n    clientOptions = clientOptions || {};\n\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n\n    this.supports = {\n      causalConsistency:\n        typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = null;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n\n  /**\n   * The server id associated with this session\n   * @type {SessionId}\n   */\n  get id() {\n    return this.serverSession.id;\n  }\n\n  get serverSession() {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    }\n\n    return this[kServerSession];\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param {Object} [options] Optional settings. Currently reserved for future use\n   * @param {Function} [callback] Optional callback for completion of this operation\n   */\n  endSession(options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || {};\n\n    const session = this;\n    return maybePromise(this, callback, done => {\n      if (session.hasEnded) {\n        return done();\n      }\n\n      function completeEndSession() {\n        // release the server session back to the pool\n        session.sessionPool.release(session.serverSession);\n        session[kServerSession] = undefined;\n\n        // mark the session as ended, and emit a signal\n        session.hasEnded = true;\n        session.emit('ended', session);\n\n        // spec indicates that we should ignore all errors for `endSessions`\n        done();\n      }\n\n      if (session.serverSession && session.inTransaction()) {\n        session.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Used to determine if this session equals another\n   * @param {ClientSession} session\n   * @return {boolean} true if the sessions are equal\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n\n  /**\n   * Increment the transaction number on the internal ServerSession\n   */\n  incrementTransactionNumber() {\n    this.serverSession.txnNumber++;\n  }\n\n  /**\n   * @returns {boolean} whether this session is currently in a transaction or not\n   */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param {TransactionOptions} options Options for the transaction\n   */\n  startTransaction(options) {\n    assertAlive(this);\n    if (this.inTransaction()) {\n      throw new MongoError('Transaction already in progress');\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\n    if (\n      isSharded(this.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n\n    // create transaction state\n    this.transaction = new Transaction(\n      Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions)\n    );\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n  commitTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'commitTransaction', done));\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n  abortTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'abortTransaction', done));\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   * @ignore\n   */\n  toBSON() {\n    throw new Error('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * A user provided function to be run within a transaction\n   *\n   * @callback WithTransactionCallback\n   * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.\n   * @returns {Promise} The resulting Promise of operations run within this transaction\n   */\n\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param {WithTransactionCallback} fn\n   * @param {TransactionOptions} [options] Optional settings for the transaction\n   */\n  withTransaction(fn, options) {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst UNSATISFIABLE_WRITE_CONCERN_CODE = 100;\nconst UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;\nconst MAX_TIME_MS_EXPIRED_CODE = 50;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction hasNotTimedOut(startTime, max) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) &&\n      err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE &&\n      err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE)\n  );\n}\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null) return false;\n  return (\n    err.code === MAX_TIME_MS_EXPIRED_CODE ||\n    (err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE)\n  );\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (\n      err instanceof MongoError &&\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n      !isMaxTimeMSExpiredError(err)\n    ) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([\n  TxnState.NO_TRANSACTION,\n  TxnState.TRANSACTION_COMMITTED,\n  TxnState.TRANSACTION_ABORTED\n]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  session.startTransaction(options);\n\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new TypeError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise\n    .then(() => {\n      if (userExplicitlyEndedTransaction(session)) {\n        return;\n      }\n\n      return attemptTransactionCommit(session, startTime, fn, options);\n    })\n    .catch(err => {\n      function maybeRetryOrThrow(err) {\n        if (\n          err instanceof MongoError &&\n          err.hasErrorLabel('TransientTransactionError') &&\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\n        ) {\n          return attemptTransaction(session, startTime, fn, options);\n        }\n\n        if (isMaxTimeMSExpiredError(err)) {\n          err.addErrorLabel('UnknownTransactionCommitResult');\n        }\n\n        throw err;\n      }\n\n      if (session.transaction.isActive) {\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n      }\n\n      return maybeRetryOrThrow(err);\n    });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  }\n\n  // handle any initial problematic cases\n  let txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (\n      txnState === TxnState.STARTING_TRANSACTION ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (\n      txnState === TxnState.TRANSACTION_COMMITTED ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n\n  // construct and send the command\n  const command = { [commandName]: 1 };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.w) {\n    writeConcern = { w: session.clientOptions.w };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, { writeConcern });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName === 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n\n      if (\n        e &&\n        (e instanceof MongoNetworkError ||\n          e instanceof MongoWriteConcernError ||\n          isRetryableError(e) ||\n          isMaxTimeMSExpiredError(e))\n      ) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult');\n\n          // per txns spec, must unpin session in this case\n          session.transaction.unpinServer();\n        }\n      }\n    } else {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n    }\n\n    callback(e, r);\n  }\n\n  // The spec indicates that we should ignore all errors on `abortTransaction`\n  function transactionError(err) {\n    return commandName === 'commitTransaction' ? err : null;\n  }\n\n  if (\n    // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n    session.transaction.recoveryToken &&\n    supportsRecoveryToken(session)\n  ) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  // send the command\n  session.topology.command('admin.$cmd', command, { session }, (err, reply) => {\n    if (err && isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.transaction.unpinServer();\n\n        command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return session.topology.command('admin.$cmd', command, { session }, (_err, _reply) =>\n        commandHandler(transactionError(_err), _reply)\n      );\n    }\n\n    commandHandler(transactionError(err), reply);\n  });\n}\n\nfunction supportsRecoveryToken(session) {\n  const topology = session.topology;\n  return !!topology.s.options.useRecoveryToken;\n}\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @ignore\n */\nclass ServerSession {\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   * @ignore\n   * @param {Date} sessionTimeoutMinutes The server's \"logicalSessionTimeoutMinutes\"\n   * @return {boolean} true if the session has timed out.\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @ignore\n */\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new Error('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n\n  /**\n   * Ends all sessions in the session pool.\n   * @ignore\n   */\n  endAllPooledSessions(callback) {\n    if (this.sessions.length) {\n      this.topology.endSessions(\n        this.sessions.map(session => session.id),\n        () => {\n          this.sessions = [];\n          if (typeof callback === 'function') {\n            callback();\n          }\n        }\n      );\n\n      return;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession\n   * is created.\n   * @ignore\n   * @returns {ServerSession}\n   */\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   * @ignore\n   * @param {ServerSession} session The session to release to the pool\n   */\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n  if (\n    command.aggregate ||\n    command.count ||\n    command.distinct ||\n    command.find ||\n    command.parallelCollectionScan ||\n    command.geoNear ||\n    command.geoSearch\n  ) {\n    return true;\n  }\n\n  if (\n    command.mapReduce &&\n    options &&\n    options.out &&\n    (options.out.inline === 1 || options.out === 'inline')\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @ignore\n * @param {ClientSession} session the session tracking transaction state\n * @param {Object} command the command to decorate\n * @param {Object} topology the topology for tracking the cluster time\n * @param {Object} [options] Optional settings passed to calling operation\n * @return {MongoError|null} An error, if some error condition was met\n */\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n    return new MongoError('Cannot use a session that has ended');\n  }\n\n  // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    return;\n  }\n\n  const serverSession = session.serverSession;\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  // first apply non-transaction-specific sessions data\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = options.willRetryWrite;\n  const shouldApplyReadConcern = commandSupportsReadConcern(command, options);\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  // now attempt to apply transaction-specific sessions data\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    // TODO: the following should only be applied to read operation per spec.\n    // for causal consistency\n    if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n\n    return;\n  }\n\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(\n      `Read preference in a transaction must be primary, not: ${options.readPreference.mode}`\n    );\n  }\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session.clientOptions.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n}\n\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    resolveClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n}\n\nmodule.exports = {\n  ClientSession,\n  ServerSession,\n  ServerSessionPool,\n  TxnState,\n  applySession,\n  updateSessionFromResponse,\n  commandSupportsReadConcern\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,YAAY,GAAGC,OAAO,CAAC,oBAAoB,CAAC,CAACD,YAAY;AAC/D,MAAME,YAAY,GAAGD,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAME,IAAI,GAAGH,YAAY,EAAE;AAC3B,MAAMI,MAAM,GAAGD,IAAI,CAACC,MAAM;AAC1B,MAAMC,MAAM,GAAGJ,OAAO,CAAC,SAAS,CAAC,CAACI,MAAM;AACxC,MAAMC,UAAU,GAAGL,OAAO,CAAC,SAAS,CAAC,CAACK,UAAU;AAChD,MAAMC,gBAAgB,GAAGN,OAAO,CAAC,WAAW,CAAC,CAACM,gBAAgB;AAC9D,MAAMC,iBAAiB,GAAGP,OAAO,CAAC,SAAS,CAAC,CAACO,iBAAiB;AAC9D,MAAMC,sBAAsB,GAAGR,OAAO,CAAC,SAAS,CAAC,CAACQ,sBAAsB;AACxE,MAAMC,WAAW,GAAGT,OAAO,CAAC,gBAAgB,CAAC,CAACS,WAAW;AACzD,MAAMC,QAAQ,GAAGV,OAAO,CAAC,gBAAgB,CAAC,CAACU,QAAQ;AACnD,MAAMC,aAAa,GAAGX,OAAO,CAAC,SAAS,CAAC,CAACW,aAAa;AACtD,MAAMC,cAAc,GAAGZ,OAAO,CAAC,8BAA8B,CAAC;AAC9D,MAAMa,YAAY,GAAGb,OAAO,CAAC,UAAU,CAAC,CAACa,YAAY;AACrD,MAAMC,oBAAoB,GAAGd,OAAO,CAAC,gBAAgB,CAAC,CAACc,oBAAoB;AAC3E,MAAMC,kBAAkB,GAAGf,OAAO,CAAC,qBAAqB,CAAC,CAACe,kBAAkB;AAC5E,MAAMC,SAAS,GAAGhB,OAAO,CAAC,uBAAuB,CAAC,CAACgB,SAAS;AAC5D,MAAMC,cAAc,GAAGjB,OAAO,CAAC,SAAS,CAAC,CAACiB,cAAc;AACxD,MAAMC,GAAG,GAAGlB,OAAO,CAAC,YAAY,CAAC,CAACkB,GAAG;AACrC,MAAMC,qBAAqB,GAAGnB,OAAO,CAAC,YAAY,CAAC,CAACmB,qBAAqB;AACzE,MAAMC,oCAAoC,GAAG,CAAC;AAE9C,SAASC,WAAW,CAACC,OAAO,EAAEC,QAAQ,EAAE;EACtC,IAAID,OAAO,CAACE,aAAa,IAAI,IAAI,EAAE;IACjC,MAAMC,KAAK,GAAG,IAAIpB,UAAU,CAAC,qCAAqC,CAAC;IACnE,IAAI,OAAOkB,QAAQ,KAAK,UAAU,EAAE;MAClCA,QAAQ,CAACE,KAAK,EAAE,IAAI,CAAC;MACrB,OAAO,KAAK;IACd;IAEA,MAAMA,KAAK;EACb;EAEA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAGC,MAAM,CAAC,eAAe,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,SAAS3B,YAAY,CAAC;EACvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4B,WAAW,CAACC,QAAQ,EAAEC,WAAW,EAAEC,OAAO,EAAEC,aAAa,EAAE;IACzD,KAAK,EAAE;IAEP,IAAIH,QAAQ,IAAI,IAAI,EAAE;MACpB,MAAM,IAAII,KAAK,CAAC,mCAAmC,CAAC;IACtD;IAEA,IAAIH,WAAW,IAAI,IAAI,IAAI,EAAEA,WAAW,YAAYI,iBAAiB,CAAC,EAAE;MACtE,MAAM,IAAID,KAAK,CAAC,4CAA4C,CAAC;IAC/D;IAEAF,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvBC,aAAa,GAAGA,aAAa,IAAI,CAAC,CAAC;IAEnC,IAAI,CAACH,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACK,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACH,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACP,cAAc,CAAC,GAAGW,SAAS;IAEhC,IAAI,CAACC,QAAQ,GAAG;MACdC,iBAAiB,EACf,OAAOP,OAAO,CAACO,iBAAiB,KAAK,WAAW,GAAGP,OAAO,CAACO,iBAAiB,GAAG;IACnF,CAAC;IAED,IAAI,CAACC,WAAW,GAAGR,OAAO,CAACS,kBAAkB;IAE7C,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,QAAQ,GAAG,CAAC,CAACX,OAAO,CAACW,QAAQ;IAClC,IAAI,CAACC,KAAK,GAAGZ,OAAO,CAACY,KAAK;IAC1B,IAAI,CAACC,yBAAyB,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,OAAO,CAACa,yBAAyB,CAAC;IACrF,IAAI,CAACG,WAAW,GAAG,IAAIvC,WAAW,EAAE;EACtC;;EAEA;AACF;AACA;AACA;EACE,IAAIwC,EAAE,GAAG;IACP,OAAO,IAAI,CAACzB,aAAa,CAACyB,EAAE;EAC9B;EAEA,IAAIzB,aAAa,GAAG;IAClB,IAAI,IAAI,CAACE,cAAc,CAAC,IAAI,IAAI,EAAE;MAChC,IAAI,CAACA,cAAc,CAAC,GAAG,IAAI,CAACK,WAAW,CAACmB,OAAO,EAAE;IACnD;IAEA,OAAO,IAAI,CAACxB,cAAc,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEyB,UAAU,CAACnB,OAAO,EAAET,QAAQ,EAAE;IAC5B,IAAI,OAAOS,OAAO,KAAK,UAAU,EAAGT,QAAQ,GAAGS,OAAO,EAAIA,OAAO,GAAG,CAAC,CAAE;IACvEA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IAEvB,MAAMV,OAAO,GAAG,IAAI;IACpB,OAAOT,YAAY,CAAC,IAAI,EAAEU,QAAQ,EAAE6B,IAAI,IAAI;MAC1C,IAAI9B,OAAO,CAACc,QAAQ,EAAE;QACpB,OAAOgB,IAAI,EAAE;MACf;MAEA,SAASC,kBAAkB,GAAG;QAC5B;QACA/B,OAAO,CAACS,WAAW,CAACuB,OAAO,CAAChC,OAAO,CAACE,aAAa,CAAC;QAClDF,OAAO,CAACI,cAAc,CAAC,GAAGW,SAAS;;QAEnC;QACAf,OAAO,CAACc,QAAQ,GAAG,IAAI;QACvBd,OAAO,CAACiC,IAAI,CAAC,OAAO,EAAEjC,OAAO,CAAC;;QAE9B;QACA8B,IAAI,EAAE;MACR;MAEA,IAAI9B,OAAO,CAACE,aAAa,IAAIF,OAAO,CAACkC,aAAa,EAAE,EAAE;QACpDlC,OAAO,CAACmC,gBAAgB,CAACC,GAAG,IAAI;UAC9B,IAAIA,GAAG,EAAE,OAAON,IAAI,CAACM,GAAG,CAAC;UACzBL,kBAAkB,EAAE;QACtB,CAAC,CAAC;QAEF;MACF;MAEAA,kBAAkB,EAAE;IACtB,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;EACEM,oBAAoB,CAACjB,aAAa,EAAE;IAClC,IAAI,IAAI,CAACA,aAAa,IAAI,IAAI,EAAE;MAC9B,IAAI,CAACA,aAAa,GAAGA,aAAa;MAClC;IACF;IAEA,IAAIA,aAAa,CAACkB,WAAW,CAAC,IAAI,CAAClB,aAAa,CAAC,EAAE;MACjD,IAAI,CAACA,aAAa,GAAGA,aAAa;IACpC;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEmB,MAAM,CAACvC,OAAO,EAAE;IACd,IAAI,EAAEA,OAAO,YAAYM,aAAa,CAAC,EAAE;MACvC,OAAO,KAAK;IACd;IAEA,OAAO,IAAI,CAACqB,EAAE,CAACA,EAAE,CAACa,MAAM,CAACD,MAAM,CAACvC,OAAO,CAAC2B,EAAE,CAACA,EAAE,CAACa,MAAM,CAAC;EACvD;;EAEA;AACF;AACA;EACEC,0BAA0B,GAAG;IAC3B,IAAI,CAACvC,aAAa,CAACwC,SAAS,EAAE;EAChC;;EAEA;AACF;AACA;EACER,aAAa,GAAG;IACd,OAAO,IAAI,CAACR,WAAW,CAACiB,QAAQ;EAClC;;EAEA;AACF;AACA;AACA;AACA;EACEC,gBAAgB,CAAClC,OAAO,EAAE;IACxBX,WAAW,CAAC,IAAI,CAAC;IACjB,IAAI,IAAI,CAACmC,aAAa,EAAE,EAAE;MACxB,MAAM,IAAInD,UAAU,CAAC,iCAAiC,CAAC;IACzD;IAEA,MAAM8D,sBAAsB,GAAGlD,cAAc,CAAC,IAAI,CAACa,QAAQ,CAAC;IAC5D,IACEd,SAAS,CAAC,IAAI,CAACc,QAAQ,CAAC,IACxBqC,sBAAsB,IAAI,IAAI,IAC9BA,sBAAsB,GAAG/C,oCAAoC,EAC7D;MACA,MAAM,IAAIf,UAAU,CAAC,sEAAsE,CAAC;IAC9F;;IAEA;IACA,IAAI,CAAC0D,0BAA0B,EAAE;;IAEjC;IACA,IAAI,CAACf,WAAW,GAAG,IAAIvC,WAAW,CAChCqC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACd,aAAa,EAAED,OAAO,IAAI,IAAI,CAACa,yBAAyB,CAAC,CACjF;IAED,IAAI,CAACG,WAAW,CAACoB,UAAU,CAAC1D,QAAQ,CAAC2D,oBAAoB,CAAC;EAC5D;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,iBAAiB,CAAC/C,QAAQ,EAAE;IAC1B,OAAOV,YAAY,CAAC,IAAI,EAAEU,QAAQ,EAAE6B,IAAI,IAAImB,cAAc,CAAC,IAAI,EAAE,mBAAmB,EAAEnB,IAAI,CAAC,CAAC;EAC9F;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEK,gBAAgB,CAAClC,QAAQ,EAAE;IACzB,OAAOV,YAAY,CAAC,IAAI,EAAEU,QAAQ,EAAE6B,IAAI,IAAImB,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAEnB,IAAI,CAAC,CAAC;EAC7F;;EAEA;AACF;AACA;AACA;EACEoB,MAAM,GAAG;IACP,MAAM,IAAItC,KAAK,CAAC,6CAA6C,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuC,eAAe,CAACC,EAAE,EAAE1C,OAAO,EAAE;IAC3B,MAAM2C,SAAS,GAAGzD,GAAG,EAAE;IACvB,OAAO0D,kBAAkB,CAAC,IAAI,EAAED,SAAS,EAAED,EAAE,EAAE1C,OAAO,CAAC;EACzD;AACF;AAEA,MAAM6C,4BAA4B,GAAG,MAAM;AAC3C,MAAMC,gCAAgC,GAAG,GAAG;AAC5C,MAAMC,+BAA+B,GAAG,EAAE;AAC1C,MAAMC,wBAAwB,GAAG,EAAE;AACnC,MAAMC,sCAAsC,GAAG,IAAIC,GAAG,CAAC,CACrD,2BAA2B,EAC3B,yBAAyB,EACzB,2BAA2B,CAC5B,CAAC;AAEF,SAASC,cAAc,CAACR,SAAS,EAAES,GAAG,EAAE;EACtC,OAAOjE,qBAAqB,CAACwD,SAAS,CAAC,GAAGS,GAAG;AAC/C;AAEA,SAASC,gCAAgC,CAAC3B,GAAG,EAAE;EAC7C,OACE4B,uBAAuB,CAAC5B,GAAG,CAAC,IAC3B,CAACuB,sCAAsC,CAACM,GAAG,CAAC7B,GAAG,CAAC8B,QAAQ,CAAC,IACxD9B,GAAG,CAAC+B,IAAI,KAAKX,gCAAgC,IAC7CpB,GAAG,CAAC+B,IAAI,KAAKV,+BAAgC;AAEnD;AAEA,SAASO,uBAAuB,CAAC5B,GAAG,EAAE;EACpC,IAAIA,GAAG,IAAI,IAAI,EAAE,OAAO,KAAK;EAC7B,OACEA,GAAG,CAAC+B,IAAI,KAAKT,wBAAwB,IACpCtB,GAAG,CAACgC,iBAAiB,IAAIhC,GAAG,CAACgC,iBAAiB,CAACD,IAAI,KAAKT,wBAAyB;AAEtF;AAEA,SAASW,wBAAwB,CAACrE,OAAO,EAAEqD,SAAS,EAAED,EAAE,EAAE1C,OAAO,EAAE;EACjE,OAAOV,OAAO,CAACgD,iBAAiB,EAAE,CAACsB,KAAK,CAAClC,GAAG,IAAI;IAC9C,IACEA,GAAG,YAAYrD,UAAU,IACzB8E,cAAc,CAACR,SAAS,EAAEE,4BAA4B,CAAC,IACvD,CAACS,uBAAuB,CAAC5B,GAAG,CAAC,EAC7B;MACA,IAAIA,GAAG,CAACmC,aAAa,CAAC,gCAAgC,CAAC,EAAE;QACvD,OAAOF,wBAAwB,CAACrE,OAAO,EAAEqD,SAAS,EAAED,EAAE,EAAE1C,OAAO,CAAC;MAClE;MAEA,IAAI0B,GAAG,CAACmC,aAAa,CAAC,2BAA2B,CAAC,EAAE;QAClD,OAAOjB,kBAAkB,CAACtD,OAAO,EAAEqD,SAAS,EAAED,EAAE,EAAE1C,OAAO,CAAC;MAC5D;IACF;IAEA,MAAM0B,GAAG;EACX,CAAC,CAAC;AACJ;AAEA,MAAMoC,4BAA4B,GAAG,IAAIZ,GAAG,CAAC,CAC3CxE,QAAQ,CAACqF,cAAc,EACvBrF,QAAQ,CAACsF,qBAAqB,EAC9BtF,QAAQ,CAACuF,mBAAmB,CAC7B,CAAC;AAEF,SAASC,8BAA8B,CAAC5E,OAAO,EAAE;EAC/C,OAAOwE,4BAA4B,CAACP,GAAG,CAACjE,OAAO,CAAC0B,WAAW,CAACmD,KAAK,CAAC;AACpE;AAEA,SAASvB,kBAAkB,CAACtD,OAAO,EAAEqD,SAAS,EAAED,EAAE,EAAE1C,OAAO,EAAE;EAC3DV,OAAO,CAAC4C,gBAAgB,CAAClC,OAAO,CAAC;EAEjC,IAAIoE,OAAO;EACX,IAAI;IACFA,OAAO,GAAG1B,EAAE,CAACpD,OAAO,CAAC;EACvB,CAAC,CAAC,OAAOoC,GAAG,EAAE;IACZ0C,OAAO,GAAGC,OAAO,CAACC,MAAM,CAAC5C,GAAG,CAAC;EAC/B;EAEA,IAAI,CAAC/C,aAAa,CAACyF,OAAO,CAAC,EAAE;IAC3B9E,OAAO,CAACmC,gBAAgB,EAAE;IAC1B,MAAM,IAAI8C,SAAS,CAAC,8DAA8D,CAAC;EACrF;EAEA,OAAOH,OAAO,CACXI,IAAI,CAAC,MAAM;IACV,IAAIN,8BAA8B,CAAC5E,OAAO,CAAC,EAAE;MAC3C;IACF;IAEA,OAAOqE,wBAAwB,CAACrE,OAAO,EAAEqD,SAAS,EAAED,EAAE,EAAE1C,OAAO,CAAC;EAClE,CAAC,CAAC,CACD4D,KAAK,CAAClC,GAAG,IAAI;IACZ,SAAS+C,iBAAiB,CAAC/C,GAAG,EAAE;MAC9B,IACEA,GAAG,YAAYrD,UAAU,IACzBqD,GAAG,CAACmC,aAAa,CAAC,2BAA2B,CAAC,IAC9CV,cAAc,CAACR,SAAS,EAAEE,4BAA4B,CAAC,EACvD;QACA,OAAOD,kBAAkB,CAACtD,OAAO,EAAEqD,SAAS,EAAED,EAAE,EAAE1C,OAAO,CAAC;MAC5D;MAEA,IAAIsD,uBAAuB,CAAC5B,GAAG,CAAC,EAAE;QAChCA,GAAG,CAACgD,aAAa,CAAC,gCAAgC,CAAC;MACrD;MAEA,MAAMhD,GAAG;IACX;IAEA,IAAIpC,OAAO,CAAC0B,WAAW,CAACiB,QAAQ,EAAE;MAChC,OAAO3C,OAAO,CAACmC,gBAAgB,EAAE,CAAC+C,IAAI,CAAC,MAAMC,iBAAiB,CAAC/C,GAAG,CAAC,CAAC;IACtE;IAEA,OAAO+C,iBAAiB,CAAC/C,GAAG,CAAC;EAC/B,CAAC,CAAC;AACN;AAEA,SAASa,cAAc,CAACjD,OAAO,EAAEqF,WAAW,EAAEpF,QAAQ,EAAE;EACtD,IAAI,CAACF,WAAW,CAACC,OAAO,EAAEC,QAAQ,CAAC,EAAE;IACnC;IACA;EACF;;EAEA;EACA,IAAIqF,QAAQ,GAAGtF,OAAO,CAAC0B,WAAW,CAACmD,KAAK;EAExC,IAAIS,QAAQ,KAAKlG,QAAQ,CAACqF,cAAc,EAAE;IACxCxE,QAAQ,CAAC,IAAIlB,UAAU,CAAC,wBAAwB,CAAC,CAAC;IAClD;EACF;EAEA,IAAIsG,WAAW,KAAK,mBAAmB,EAAE;IACvC,IACEC,QAAQ,KAAKlG,QAAQ,CAAC2D,oBAAoB,IAC1CuC,QAAQ,KAAKlG,QAAQ,CAACmG,2BAA2B,EACjD;MACA;MACAvF,OAAO,CAAC0B,WAAW,CAACoB,UAAU,CAAC1D,QAAQ,CAACmG,2BAA2B,CAAC;MACpEtF,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;MACpB;IACF;IAEA,IAAIqF,QAAQ,KAAKlG,QAAQ,CAACuF,mBAAmB,EAAE;MAC7C1E,QAAQ,CAAC,IAAIlB,UAAU,CAAC,8DAA8D,CAAC,CAAC;MACxF;IACF;EACF,CAAC,MAAM;IACL,IAAIuG,QAAQ,KAAKlG,QAAQ,CAAC2D,oBAAoB,EAAE;MAC9C;MACA/C,OAAO,CAAC0B,WAAW,CAACoB,UAAU,CAAC1D,QAAQ,CAACuF,mBAAmB,CAAC;MAC5D1E,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;MACpB;IACF;IAEA,IAAIqF,QAAQ,KAAKlG,QAAQ,CAACuF,mBAAmB,EAAE;MAC7C1E,QAAQ,CAAC,IAAIlB,UAAU,CAAC,oCAAoC,CAAC,CAAC;MAC9D;IACF;IAEA,IACEuG,QAAQ,KAAKlG,QAAQ,CAACsF,qBAAqB,IAC3CY,QAAQ,KAAKlG,QAAQ,CAACmG,2BAA2B,EACjD;MACAtF,QAAQ,CAAC,IAAIlB,UAAU,CAAC,8DAA8D,CAAC,CAAC;MACxF;IACF;EACF;;EAEA;EACA,MAAMyG,OAAO,GAAG;IAAE,CAACH,WAAW,GAAG;EAAE,CAAC;;EAEpC;EACA,IAAII,YAAY;EAChB,IAAIzF,OAAO,CAAC0B,WAAW,CAAChB,OAAO,CAAC+E,YAAY,EAAE;IAC5CA,YAAY,GAAGjE,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEzB,OAAO,CAAC0B,WAAW,CAAChB,OAAO,CAAC+E,YAAY,CAAC;EAC5E,CAAC,MAAM,IAAIzF,OAAO,CAACW,aAAa,IAAIX,OAAO,CAACW,aAAa,CAAC+E,CAAC,EAAE;IAC3DD,YAAY,GAAG;MAAEC,CAAC,EAAE1F,OAAO,CAACW,aAAa,CAAC+E;IAAE,CAAC;EAC/C;EAEA,IAAIJ,QAAQ,KAAKlG,QAAQ,CAACsF,qBAAqB,EAAE;IAC/Ce,YAAY,GAAGjE,MAAM,CAACC,MAAM,CAAC;MAAEkE,QAAQ,EAAE;IAAM,CAAC,EAAEF,YAAY,EAAE;MAAEC,CAAC,EAAE;IAAW,CAAC,CAAC;EACpF;EAEA,IAAID,YAAY,EAAE;IAChBjE,MAAM,CAACC,MAAM,CAAC+D,OAAO,EAAE;MAAEC;IAAa,CAAC,CAAC;EAC1C;EAEA,IAAIJ,WAAW,KAAK,mBAAmB,IAAIrF,OAAO,CAAC0B,WAAW,CAAChB,OAAO,CAACkF,SAAS,EAAE;IAChFpE,MAAM,CAACC,MAAM,CAAC+D,OAAO,EAAE;MAAEI,SAAS,EAAE5F,OAAO,CAAC0B,WAAW,CAAChB,OAAO,CAACkF;IAAU,CAAC,CAAC;EAC9E;EAEA,SAASC,cAAc,CAACC,CAAC,EAAEC,CAAC,EAAE;IAC5B,IAAIV,WAAW,KAAK,mBAAmB,EAAE;MACvCrF,OAAO,CAAC0B,WAAW,CAACoB,UAAU,CAAC1D,QAAQ,CAACsF,qBAAqB,CAAC;MAE9D,IACEoB,CAAC,KACAA,CAAC,YAAY7G,iBAAiB,IAC7B6G,CAAC,YAAY5G,sBAAsB,IACnCF,gBAAgB,CAAC8G,CAAC,CAAC,IACnB9B,uBAAuB,CAAC8B,CAAC,CAAC,CAAC,EAC7B;QACA,IAAI/B,gCAAgC,CAAC+B,CAAC,CAAC,EAAE;UACvCA,CAAC,CAACV,aAAa,CAAC,gCAAgC,CAAC;;UAEjD;UACApF,OAAO,CAAC0B,WAAW,CAACsE,WAAW,EAAE;QACnC;MACF;IACF,CAAC,MAAM;MACLhG,OAAO,CAAC0B,WAAW,CAACoB,UAAU,CAAC1D,QAAQ,CAACuF,mBAAmB,CAAC;IAC9D;IAEA1E,QAAQ,CAAC6F,CAAC,EAAEC,CAAC,CAAC;EAChB;;EAEA;EACA,SAASE,gBAAgB,CAAC7D,GAAG,EAAE;IAC7B,OAAOiD,WAAW,KAAK,mBAAmB,GAAGjD,GAAG,GAAG,IAAI;EACzD;EAEA;EACE;EACApC,OAAO,CAAC0B,WAAW,CAACwE,aAAa,IACjCC,qBAAqB,CAACnG,OAAO,CAAC,EAC9B;IACAwF,OAAO,CAACU,aAAa,GAAGlG,OAAO,CAAC0B,WAAW,CAACwE,aAAa;EAC3D;;EAEA;EACAlG,OAAO,CAACQ,QAAQ,CAACgF,OAAO,CAAC,YAAY,EAAEA,OAAO,EAAE;IAAExF;EAAQ,CAAC,EAAE,CAACoC,GAAG,EAAEgE,KAAK,KAAK;IAC3E,IAAIhE,GAAG,IAAIpD,gBAAgB,CAACoD,GAAG,CAAC,EAAE;MAChC;MACA,IAAIoD,OAAO,CAACxC,iBAAiB,EAAE;QAC7B;QACAhD,OAAO,CAAC0B,WAAW,CAACsE,WAAW,EAAE;QAEjCR,OAAO,CAACC,YAAY,GAAGjE,MAAM,CAACC,MAAM,CAAC;UAAEkE,QAAQ,EAAE;QAAM,CAAC,EAAEH,OAAO,CAACC,YAAY,EAAE;UAC9EC,CAAC,EAAE;QACL,CAAC,CAAC;MACJ;MAEA,OAAO1F,OAAO,CAACQ,QAAQ,CAACgF,OAAO,CAAC,YAAY,EAAEA,OAAO,EAAE;QAAExF;MAAQ,CAAC,EAAE,CAACqG,IAAI,EAAEC,MAAM,KAC/ET,cAAc,CAACI,gBAAgB,CAACI,IAAI,CAAC,EAAEC,MAAM,CAAC,CAC/C;IACH;IAEAT,cAAc,CAACI,gBAAgB,CAAC7D,GAAG,CAAC,EAAEgE,KAAK,CAAC;EAC9C,CAAC,CAAC;AACJ;AAEA,SAASD,qBAAqB,CAACnG,OAAO,EAAE;EACtC,MAAMQ,QAAQ,GAAGR,OAAO,CAACQ,QAAQ;EACjC,OAAO,CAAC,CAACA,QAAQ,CAAC+F,CAAC,CAAC7F,OAAO,CAAC8F,gBAAgB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,CAAC;EAClBlG,WAAW,GAAG;IACZ,IAAI,CAACoB,EAAE,GAAG;MAAEA,EAAE,EAAE,IAAI9C,MAAM,CAACC,MAAM,EAAE,EAAED,MAAM,CAAC6H,YAAY;IAAE,CAAC;IAC3D,IAAI,CAACC,OAAO,GAAG/G,GAAG,EAAE;IACpB,IAAI,CAAC8C,SAAS,GAAG,CAAC;IAClB,IAAI,CAACkE,OAAO,GAAG,KAAK;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,WAAW,CAACC,qBAAqB,EAAE;IACjC;IACA;IACA,MAAMC,eAAe,GAAGC,IAAI,CAACC,KAAK,CAC9BpH,qBAAqB,CAAC,IAAI,CAAC8G,OAAO,CAAC,GAAG,QAAQ,GAAI,OAAO,GAAI,KAAK,CACrE;IAED,OAAOI,eAAe,GAAGD,qBAAqB,GAAG,CAAC;EACpD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMjG,iBAAiB,CAAC;EACtBN,WAAW,CAACC,QAAQ,EAAE;IACpB,IAAIA,QAAQ,IAAI,IAAI,EAAE;MACpB,MAAM,IAAII,KAAK,CAAC,uCAAuC,CAAC;IAC1D;IAEA,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC0G,QAAQ,GAAG,EAAE;EACpB;;EAEA;AACF;AACA;AACA;EACEC,oBAAoB,CAAClH,QAAQ,EAAE;IAC7B,IAAI,IAAI,CAACiH,QAAQ,CAACE,MAAM,EAAE;MACxB,IAAI,CAAC5G,QAAQ,CAAC6G,WAAW,CACvB,IAAI,CAACH,QAAQ,CAACI,GAAG,CAACtH,OAAO,IAAIA,OAAO,CAAC2B,EAAE,CAAC,EACxC,MAAM;QACJ,IAAI,CAACuF,QAAQ,GAAG,EAAE;QAClB,IAAI,OAAOjH,QAAQ,KAAK,UAAU,EAAE;UAClCA,QAAQ,EAAE;QACZ;MACF,CAAC,CACF;MAED;IACF;IAEA,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAClCA,QAAQ,EAAE;IACZ;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2B,OAAO,GAAG;IACR,MAAMkF,qBAAqB,GAAG,IAAI,CAACtG,QAAQ,CAAC+G,4BAA4B;IACxE,OAAO,IAAI,CAACL,QAAQ,CAACE,MAAM,EAAE;MAC3B,MAAMpH,OAAO,GAAG,IAAI,CAACkH,QAAQ,CAACM,KAAK,EAAE;MACrC,IAAI,CAACxH,OAAO,CAAC6G,WAAW,CAACC,qBAAqB,CAAC,EAAE;QAC/C,OAAO9G,OAAO;MAChB;IACF;IAEA,OAAO,IAAIyG,aAAa,EAAE;EAC5B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEzE,OAAO,CAAChC,OAAO,EAAE;IACf,MAAM8G,qBAAqB,GAAG,IAAI,CAACtG,QAAQ,CAAC+G,4BAA4B;IACxE,OAAO,IAAI,CAACL,QAAQ,CAACE,MAAM,EAAE;MAC3B,MAAMK,aAAa,GAAG,IAAI,CAACP,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;MAC7D,IAAIK,aAAa,CAACZ,WAAW,CAACC,qBAAqB,CAAC,EAAE;QACpD,IAAI,CAACI,QAAQ,CAACQ,GAAG,EAAE;MACrB,CAAC,MAAM;QACL;MACF;IACF;IAEA,IAAI,CAAC1H,OAAO,CAAC6G,WAAW,CAACC,qBAAqB,CAAC,EAAE;MAC/C,IAAI9G,OAAO,CAAC4G,OAAO,EAAE;QACnB;MACF;;MAEA;MACA,IAAI,CAACM,QAAQ,CAACS,OAAO,CAAC3H,OAAO,CAAC;IAChC;EACF;AACF;;AAEA;AACA;AACA,SAAS4H,0BAA0B,CAACpC,OAAO,EAAE9E,OAAO,EAAE;EACpD,IACE8E,OAAO,CAACqC,SAAS,IACjBrC,OAAO,CAACsC,KAAK,IACbtC,OAAO,CAACuC,QAAQ,IAChBvC,OAAO,CAACwC,IAAI,IACZxC,OAAO,CAACyC,sBAAsB,IAC9BzC,OAAO,CAAC0C,OAAO,IACf1C,OAAO,CAAC2C,SAAS,EACjB;IACA,OAAO,IAAI;EACb;EAEA,IACE3C,OAAO,CAAC4C,SAAS,IACjB1H,OAAO,IACPA,OAAO,CAAC2H,GAAG,KACV3H,OAAO,CAAC2H,GAAG,CAACC,MAAM,KAAK,CAAC,IAAI5H,OAAO,CAAC2H,GAAG,KAAK,QAAQ,CAAC,EACtD;IACA,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,YAAY,CAACvI,OAAO,EAAEwF,OAAO,EAAE9E,OAAO,EAAE;EAC/C,IAAIV,OAAO,CAACc,QAAQ,EAAE;IACpB;IACA,OAAO,IAAI/B,UAAU,CAAC,qCAAqC,CAAC;EAC9D;;EAEA;EACA,IAAI2B,OAAO,IAAIA,OAAO,CAAC+E,YAAY,IAAI/E,OAAO,CAAC+E,YAAY,CAACC,CAAC,KAAK,CAAC,EAAE;IACnE;EACF;EAEA,MAAMxF,aAAa,GAAGF,OAAO,CAACE,aAAa;EAC3CA,aAAa,CAACyG,OAAO,GAAG/G,GAAG,EAAE;EAC7B4F,OAAO,CAACgD,IAAI,GAAGtI,aAAa,CAACyB,EAAE;;EAE/B;EACA,MAAMO,aAAa,GAAGlC,OAAO,CAACkC,aAAa,EAAE,IAAI1C,oBAAoB,CAACgG,OAAO,CAAC;EAC9E,MAAMiD,gBAAgB,GAAG/H,OAAO,CAACgI,cAAc;EAC/C,MAAMC,sBAAsB,GAAGf,0BAA0B,CAACpC,OAAO,EAAE9E,OAAO,CAAC;EAE3E,IAAIR,aAAa,CAACwC,SAAS,KAAK+F,gBAAgB,IAAIvG,aAAa,CAAC,EAAE;IAClEsD,OAAO,CAAC9C,SAAS,GAAG9D,IAAI,CAACgK,IAAI,CAACC,UAAU,CAAC3I,aAAa,CAACwC,SAAS,CAAC;EACnE;;EAEA;EACA,IAAI,CAACR,aAAa,EAAE;IAClB,IAAIlC,OAAO,CAAC0B,WAAW,CAACmD,KAAK,KAAKzF,QAAQ,CAACqF,cAAc,EAAE;MACzDzE,OAAO,CAAC0B,WAAW,CAACoB,UAAU,CAAC1D,QAAQ,CAACqF,cAAc,CAAC;IACzD;;IAEA;IACA;IACA,IAAIzE,OAAO,CAACgB,QAAQ,CAACC,iBAAiB,IAAIjB,OAAO,CAACoB,aAAa,IAAIuH,sBAAsB,EAAE;MACzFnD,OAAO,CAACsD,WAAW,GAAGtD,OAAO,CAACsD,WAAW,IAAI,CAAC,CAAC;MAC/CtH,MAAM,CAACC,MAAM,CAAC+D,OAAO,CAACsD,WAAW,EAAE;QAAEC,gBAAgB,EAAE/I,OAAO,CAACoB;MAAc,CAAC,CAAC;IACjF;IAEA;EACF;EAEA,IAAIV,OAAO,CAACsI,cAAc,IAAI,CAACtI,OAAO,CAACsI,cAAc,CAACzG,MAAM,CAACjD,cAAc,CAAC2J,OAAO,CAAC,EAAE;IACpF,OAAO,IAAIlK,UAAU,CAClB,0DAAyD2B,OAAO,CAACsI,cAAc,CAACE,IAAK,EAAC,CACxF;EACH;;EAEA;EACA1D,OAAO,CAAC2D,UAAU,GAAG,KAAK;EAE1B,IAAInJ,OAAO,CAAC0B,WAAW,CAACmD,KAAK,KAAKzF,QAAQ,CAAC2D,oBAAoB,EAAE;IAC/D/C,OAAO,CAAC0B,WAAW,CAACoB,UAAU,CAAC1D,QAAQ,CAACgK,uBAAuB,CAAC;IAChE5D,OAAO,CAAC5C,gBAAgB,GAAG,IAAI;IAE/B,MAAMkG,WAAW,GACf9I,OAAO,CAAC0B,WAAW,CAAChB,OAAO,CAACoI,WAAW,IAAI9I,OAAO,CAACW,aAAa,CAACmI,WAAW;IAC9E,IAAIA,WAAW,EAAE;MACftD,OAAO,CAACsD,WAAW,GAAGA,WAAW;IACnC;IAEA,IAAI9I,OAAO,CAACgB,QAAQ,CAACC,iBAAiB,IAAIjB,OAAO,CAACoB,aAAa,EAAE;MAC/DoE,OAAO,CAACsD,WAAW,GAAGtD,OAAO,CAACsD,WAAW,IAAI,CAAC,CAAC;MAC/CtH,MAAM,CAACC,MAAM,CAAC+D,OAAO,CAACsD,WAAW,EAAE;QAAEC,gBAAgB,EAAE/I,OAAO,CAACoB;MAAc,CAAC,CAAC;IACjF;EACF;AACF;AAEA,SAASiI,yBAAyB,CAACrJ,OAAO,EAAEsJ,QAAQ,EAAE;EACpD,IAAIA,QAAQ,CAACC,YAAY,EAAE;IACzB9J,kBAAkB,CAACO,OAAO,EAAEsJ,QAAQ,CAACC,YAAY,CAAC;EACpD;EAEA,IAAID,QAAQ,CAAClI,aAAa,IAAIpB,OAAO,IAAIA,OAAO,CAACgB,QAAQ,CAACC,iBAAiB,EAAE;IAC3EjB,OAAO,CAACqC,oBAAoB,CAACiH,QAAQ,CAAClI,aAAa,CAAC;EACtD;EAEA,IAAIkI,QAAQ,CAACpD,aAAa,IAAIlG,OAAO,IAAIA,OAAO,CAACkC,aAAa,EAAE,EAAE;IAChElC,OAAO,CAAC0B,WAAW,CAAC8H,cAAc,GAAGF,QAAQ,CAACpD,aAAa;EAC7D;AACF;AAEAuD,MAAM,CAACC,OAAO,GAAG;EACfpJ,aAAa;EACbmG,aAAa;EACb5F,iBAAiB;EACjBzB,QAAQ;EACRmJ,YAAY;EACZc,yBAAyB;EACzBzB;AACF,CAAC"},"metadata":{},"sourceType":"script"}