{"ast":null,"code":"'use strict';\n\nconst MongoError = require('../error').MongoError;\nconst collectionNamespace = require('./shared').collectionNamespace;\nconst command = require('./command');\nconst decorateWithExplain = require('../../utils').decorateWithExplain;\nconst Explain = require('../../explain').Explain;\nfunction writeCommand(server, type, opsField, ns, ops, options, callback) {\n  if (ops.length === 0) throw new MongoError(`${type} must contain at least one document`);\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const writeConcern = options.writeConcern;\n  let writeCommand = {};\n  writeCommand[type] = collectionNamespace(ns);\n  writeCommand[opsField] = ops;\n  writeCommand.ordered = ordered;\n  if (writeConcern && Object.keys(writeConcern).length > 0) {\n    writeCommand.writeConcern = writeConcern;\n  }\n  if (options.collation) {\n    for (let i = 0; i < writeCommand[opsField].length; i++) {\n      if (!writeCommand[opsField][i].collation) {\n        writeCommand[opsField][i].collation = options.collation;\n      }\n    }\n  }\n  if (options.bypassDocumentValidation === true) {\n    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n\n  // If a command is to be explained, we need to reformat the command after\n  // the other command properties are specified.\n  const explain = Explain.fromOptions(options);\n  if (explain) {\n    writeCommand = decorateWithExplain(writeCommand, explain);\n  }\n  const commandOptions = Object.assign({\n    checkKeys: type === 'insert',\n    numberToReturn: 1\n  }, options);\n  command(server, ns, writeCommand, commandOptions, callback);\n}\nmodule.exports = writeCommand;","map":{"version":3,"names":["MongoError","require","collectionNamespace","command","decorateWithExplain","Explain","writeCommand","server","type","opsField","ns","ops","options","callback","length","ordered","writeConcern","Object","keys","collation","i","bypassDocumentValidation","explain","fromOptions","commandOptions","assign","checkKeys","numberToReturn","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/wireprotocol/write_command.js"],"sourcesContent":["'use strict';\n\nconst MongoError = require('../error').MongoError;\nconst collectionNamespace = require('./shared').collectionNamespace;\nconst command = require('./command');\nconst decorateWithExplain = require('../../utils').decorateWithExplain;\nconst Explain = require('../../explain').Explain;\n\nfunction writeCommand(server, type, opsField, ns, ops, options, callback) {\n  if (ops.length === 0) throw new MongoError(`${type} must contain at least one document`);\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const writeConcern = options.writeConcern;\n\n  let writeCommand = {};\n  writeCommand[type] = collectionNamespace(ns);\n  writeCommand[opsField] = ops;\n  writeCommand.ordered = ordered;\n\n  if (writeConcern && Object.keys(writeConcern).length > 0) {\n    writeCommand.writeConcern = writeConcern;\n  }\n\n  if (options.collation) {\n    for (let i = 0; i < writeCommand[opsField].length; i++) {\n      if (!writeCommand[opsField][i].collation) {\n        writeCommand[opsField][i].collation = options.collation;\n      }\n    }\n  }\n\n  if (options.bypassDocumentValidation === true) {\n    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n\n  // If a command is to be explained, we need to reformat the command after\n  // the other command properties are specified.\n  const explain = Explain.fromOptions(options);\n  if (explain) {\n    writeCommand = decorateWithExplain(writeCommand, explain);\n  }\n\n  const commandOptions = Object.assign(\n    {\n      checkKeys: type === 'insert',\n      numberToReturn: 1\n    },\n    options\n  );\n\n  command(server, ns, writeCommand, commandOptions, callback);\n}\n\nmodule.exports = writeCommand;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,UAAU,CAAC,CAACD,UAAU;AACjD,MAAME,mBAAmB,GAAGD,OAAO,CAAC,UAAU,CAAC,CAACC,mBAAmB;AACnE,MAAMC,OAAO,GAAGF,OAAO,CAAC,WAAW,CAAC;AACpC,MAAMG,mBAAmB,GAAGH,OAAO,CAAC,aAAa,CAAC,CAACG,mBAAmB;AACtE,MAAMC,OAAO,GAAGJ,OAAO,CAAC,eAAe,CAAC,CAACI,OAAO;AAEhD,SAASC,YAAY,CAACC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,EAAE,EAAEC,GAAG,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EACxE,IAAIF,GAAG,CAACG,MAAM,KAAK,CAAC,EAAE,MAAM,IAAId,UAAU,CAAE,GAAEQ,IAAK,qCAAoC,CAAC;EACxF,IAAI,OAAOI,OAAO,KAAK,UAAU,EAAE;IACjCC,QAAQ,GAAGD,OAAO;IAClBA,OAAO,GAAG,CAAC,CAAC;EACd;EAEAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAMG,OAAO,GAAG,OAAOH,OAAO,CAACG,OAAO,KAAK,SAAS,GAAGH,OAAO,CAACG,OAAO,GAAG,IAAI;EAC7E,MAAMC,YAAY,GAAGJ,OAAO,CAACI,YAAY;EAEzC,IAAIV,YAAY,GAAG,CAAC,CAAC;EACrBA,YAAY,CAACE,IAAI,CAAC,GAAGN,mBAAmB,CAACQ,EAAE,CAAC;EAC5CJ,YAAY,CAACG,QAAQ,CAAC,GAAGE,GAAG;EAC5BL,YAAY,CAACS,OAAO,GAAGA,OAAO;EAE9B,IAAIC,YAAY,IAAIC,MAAM,CAACC,IAAI,CAACF,YAAY,CAAC,CAACF,MAAM,GAAG,CAAC,EAAE;IACxDR,YAAY,CAACU,YAAY,GAAGA,YAAY;EAC1C;EAEA,IAAIJ,OAAO,CAACO,SAAS,EAAE;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,YAAY,CAACG,QAAQ,CAAC,CAACK,MAAM,EAAEM,CAAC,EAAE,EAAE;MACtD,IAAI,CAACd,YAAY,CAACG,QAAQ,CAAC,CAACW,CAAC,CAAC,CAACD,SAAS,EAAE;QACxCb,YAAY,CAACG,QAAQ,CAAC,CAACW,CAAC,CAAC,CAACD,SAAS,GAAGP,OAAO,CAACO,SAAS;MACzD;IACF;EACF;EAEA,IAAIP,OAAO,CAACS,wBAAwB,KAAK,IAAI,EAAE;IAC7Cf,YAAY,CAACe,wBAAwB,GAAGT,OAAO,CAACS,wBAAwB;EAC1E;;EAEA;EACA;EACA,MAAMC,OAAO,GAAGjB,OAAO,CAACkB,WAAW,CAACX,OAAO,CAAC;EAC5C,IAAIU,OAAO,EAAE;IACXhB,YAAY,GAAGF,mBAAmB,CAACE,YAAY,EAAEgB,OAAO,CAAC;EAC3D;EAEA,MAAME,cAAc,GAAGP,MAAM,CAACQ,MAAM,CAClC;IACEC,SAAS,EAAElB,IAAI,KAAK,QAAQ;IAC5BmB,cAAc,EAAE;EAClB,CAAC,EACDf,OAAO,CACR;EAEDT,OAAO,CAACI,MAAM,EAAEG,EAAE,EAAEJ,YAAY,EAAEkB,cAAc,EAAEX,QAAQ,CAAC;AAC7D;AAEAe,MAAM,CAACC,OAAO,GAAGvB,YAAY"},"metadata":{},"sourceType":"script"}