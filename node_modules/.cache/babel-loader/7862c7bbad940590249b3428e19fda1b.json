{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n  f = require('util').format,\n  diff = require('./shared').diff,\n  EventEmitter = require('events').EventEmitter,\n  Logger = require('../connection/logger'),\n  ReadPreference = require('./read_preference'),\n  MongoError = require('../error').MongoError,\n  Buffer = require('safe-buffer').Buffer;\nvar TopologyType = {\n  Single: 'Single',\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\n  Sharded: 'Sharded',\n  Unknown: 'Unknown'\n};\nvar ServerType = {\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown'\n};\nvar ReplSetState = function (options) {\n  options = options || {};\n  // Add event listener\n  EventEmitter.call(this);\n  // Topology state\n  this.topologyType = TopologyType.ReplicaSetNoPrimary;\n  this.setName = options.setName;\n\n  // Server set\n  this.set = {};\n\n  // Unpacked options\n  this.id = options.id;\n  this.setName = options.setName;\n\n  // Replicaset logger\n  this.logger = options.logger || Logger('ReplSet', options);\n\n  // Server selection index\n  this.index = 0;\n  // Acceptable latency\n  this.acceptableLatency = options.acceptableLatency || 15;\n\n  // heartbeatFrequencyMS\n  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n\n  // Server side\n  this.primary = null;\n  this.secondaries = [];\n  this.arbiters = [];\n  this.passives = [];\n  this.ghosts = [];\n  // Current unknown hosts\n  this.unknownServers = [];\n  // In set status\n  this.set = {};\n  // Status\n  this.maxElectionId = null;\n  this.maxSetVersion = 0;\n  // Description of the Replicaset\n  this.replicasetDescription = {\n    topologyType: 'Unknown',\n    servers: []\n  };\n  this.logicalSessionTimeoutMinutes = undefined;\n};\ninherits(ReplSetState, EventEmitter);\nReplSetState.prototype.hasPrimaryAndSecondary = function () {\n  return this.primary != null && this.secondaries.length > 0;\n};\nReplSetState.prototype.hasPrimaryOrSecondary = function () {\n  return this.hasPrimary() || this.hasSecondary();\n};\nReplSetState.prototype.hasPrimary = function () {\n  return this.primary != null;\n};\nReplSetState.prototype.hasSecondary = function () {\n  return this.secondaries.length > 0;\n};\nReplSetState.prototype.get = function (host) {\n  var servers = this.allServers();\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].name.toLowerCase() === host.toLowerCase()) {\n      return servers[i];\n    }\n  }\n  return null;\n};\nReplSetState.prototype.allServers = function (options) {\n  options = options || {};\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  if (!options.ignoreArbiters) servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n  return servers;\n};\nReplSetState.prototype.destroy = function (options, callback) {\n  const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);\n  if (this.primary) serversToDestroy.push(this.primary);\n  let serverCount = serversToDestroy.length;\n  const serverDestroyed = () => {\n    serverCount--;\n    if (serverCount > 0) {\n      return;\n    }\n\n    // Clear out the complete state\n    this.secondaries = [];\n    this.arbiters = [];\n    this.passives = [];\n    this.ghosts = [];\n    this.unknownServers = [];\n    this.set = {};\n    this.primary = null;\n\n    // Emit the topology changed\n    emitTopologyDescriptionChanged(this);\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n  if (serverCount === 0) {\n    serverDestroyed();\n    return;\n  }\n  serversToDestroy.forEach(server => server.destroy(options, serverDestroyed));\n};\nReplSetState.prototype.remove = function (server, options) {\n  options = options || {};\n\n  // Get the server name and lowerCase it\n  var serverName = server.name.toLowerCase();\n\n  // Only remove if the current server is not connected\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n\n  // Check if it's active and this is just a failed connection attempt\n  for (var i = 0; i < servers.length; i++) {\n    if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {\n      return;\n    }\n  }\n\n  // If we have it in the set remove it\n  if (this.set[serverName]) {\n    this.set[serverName].type = ServerType.Unknown;\n    this.set[serverName].electionId = null;\n    this.set[serverName].setName = null;\n    this.set[serverName].setVersion = null;\n  }\n\n  // Remove type\n  var removeType = null;\n\n  // Remove from any lists\n  if (this.primary && this.primary.equals(server)) {\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    removeType = 'primary';\n  }\n\n  // Remove from any other server lists\n  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;\n  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;\n  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;\n  removeFrom(server, this.ghosts);\n  removeFrom(server, this.unknownServers);\n\n  // Push to unknownServers\n  this.unknownServers.push(serverName);\n\n  // Do we have a removeType\n  if (removeType) {\n    this.emit('left', removeType, server);\n  }\n};\nconst isArbiter = ismaster => ismaster.arbiterOnly && ismaster.setName;\nReplSetState.prototype.update = function (server) {\n  var self = this;\n  // Get the current ismaster\n  var ismaster = server.lastIsMaster();\n\n  // Get the server name and lowerCase it\n  var serverName = server.name.toLowerCase();\n\n  //\n  // Add any hosts\n  //\n  if (ismaster) {\n    // Join all the possible new hosts\n    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];\n    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);\n    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);\n    hosts = hosts.map(function (s) {\n      return s.toLowerCase();\n    });\n\n    // Add all hosts as unknownServers\n    for (var i = 0; i < hosts.length; i++) {\n      // Add to the list of unknown server\n      if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {\n        this.unknownServers.push(hosts[i].toLowerCase());\n      }\n      if (!this.set[hosts[i]]) {\n        this.set[hosts[i]] = {\n          type: ServerType.Unknown,\n          electionId: null,\n          setName: null,\n          setVersion: null\n        };\n      }\n    }\n  }\n\n  //\n  // Unknown server\n  //\n  if (!ismaster && !inList(ismaster, server, this.unknownServers)) {\n    self.set[serverName] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n    // Update set information about the server instance\n    self.set[serverName].type = ServerType.Unknown;\n    self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n    self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n    self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n    if (self.unknownServers.indexOf(server.name) === -1) {\n      self.unknownServers.push(serverName);\n    }\n\n    // Set the topology\n    return false;\n  }\n\n  // Update logicalSessionTimeoutMinutes\n  if (ismaster.logicalSessionTimeoutMinutes !== undefined && !isArbiter(ismaster)) {\n    if (self.logicalSessionTimeoutMinutes === undefined || ismaster.logicalSessionTimeoutMinutes === null) {\n      self.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;\n    } else {\n      self.logicalSessionTimeoutMinutes = Math.min(self.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);\n    }\n  }\n\n  //\n  // Is this a mongos\n  //\n  if (ismaster && ismaster.msg === 'isdbgrid') {\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n    return false;\n  }\n\n  // A RSGhost instance\n  if (ismaster.isreplicaset) {\n    self.set[serverName] = {\n      type: ServerType.RSGhost,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n    }\n\n    // Set the topology\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n\n    // Set the topology\n    return false;\n  }\n\n  // A RSOther instance\n  if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {\n    self.set[serverName] = {\n      type: ServerType.RSOther,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n\n    // Set the topology\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    return false;\n  }\n\n  //\n  // Standalone server, destroy and return\n  //\n  if (ismaster && ismaster.ismaster && !ismaster.setName) {\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;\n    this.remove(server, {\n      force: true\n    });\n    return false;\n  }\n\n  //\n  // Server in maintanance mode\n  //\n  if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {\n    this.remove(server, {\n      force: true\n    });\n    return false;\n  }\n\n  //\n  // If the .me field does not match the passed in server\n  //\n  if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {\n    if (this.logger.isWarn()) {\n      this.logger.warn(f('the seedlist server was removed due to its address %s not matching its ismaster.me address %s', server.name, ismaster.me));\n    }\n\n    // Delete from the set\n    delete this.set[serverName];\n    // Delete unknown servers\n    removeFrom(server, self.unknownServers);\n\n    // Destroy the instance\n    server.destroy({\n      force: true\n    });\n\n    // Set the type of topology we have\n    if (this.primary && !this.primary.equals(server)) {\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    //\n    // We have a potential primary\n    //\n    if (!this.primary && ismaster.primary) {\n      this.set[ismaster.primary.toLowerCase()] = {\n        type: ServerType.PossiblePrimary,\n        setName: null,\n        electionId: null,\n        setVersion: null\n      };\n    }\n    return false;\n  }\n\n  //\n  // Primary handling\n  //\n  if (!this.primary && ismaster.ismaster && ismaster.setName) {\n    var ismasterElectionId = server.lastIsMaster().electionId;\n    if (this.setName && this.setName !== ismaster.setName) {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      return new MongoError(f('setName from ismaster does not match provided connection setName [%s] != [%s]', ismaster.setName, this.setName));\n    }\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      var result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n      // Get the electionIds\n      var ismasterSetVersion = server.lastIsMaster().setVersion;\n      if (result === 1) {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n        return false;\n      } else if (result === 0 && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          this.topologyType = TopologyType.ReplicaSetNoPrimary;\n          return false;\n        }\n      }\n      this.maxSetVersion = ismasterSetVersion;\n      this.maxElectionId = ismasterElectionId;\n    }\n\n    // Hande normalization of server names\n    var normalizedHosts = ismaster.hosts.map(function (x) {\n      return x.toLowerCase();\n    });\n    var locationIndex = normalizedHosts.indexOf(serverName);\n\n    // Validate that the server exists in the host list\n    if (locationIndex !== -1) {\n      self.primary = server;\n      self.set[serverName] = {\n        type: ServerType.RSPrimary,\n        setVersion: ismaster.setVersion,\n        electionId: ismaster.electionId,\n        setName: ismaster.setName\n      };\n\n      // Set the topology\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      if (ismaster.setName) this.setName = ismaster.setName;\n      removeFrom(server, self.unknownServers);\n      removeFrom(server, self.secondaries);\n      removeFrom(server, self.passives);\n      self.emit('joined', 'primary', server);\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } else if (ismaster.ismaster && ismaster.setName) {\n    // Get the electionIds\n    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;\n    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;\n    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;\n    ismasterElectionId = server.lastIsMaster().electionId;\n    ismasterSetVersion = server.lastIsMaster().setVersion;\n    var ismasterSetName = server.lastIsMaster().setName;\n\n    // Is it the same server instance\n    if (this.primary.equals(server) && currentSetName === ismasterSetName) {\n      return false;\n    }\n\n    // If we do not have the same rs name\n    if (currentSetName && currentSetName !== ismasterSetName) {\n      if (!this.primary.equals(server)) {\n        this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      } else {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      }\n      return false;\n    }\n\n    // Check if we need to replace the server\n    if (currentElectionId && ismasterElectionId) {\n      result = compareObjectIds(currentElectionId, ismasterElectionId);\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion > ismasterSetVersion) {\n        return false;\n      }\n    } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {\n      if (ismasterSetVersion < this.maxSetVersion) {\n        return false;\n      }\n    }\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      } else {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      }\n      this.maxElectionId = ismasterElectionId;\n      this.maxSetVersion = ismasterSetVersion;\n    } else {\n      this.maxSetVersion = ismasterSetVersion;\n    }\n\n    // Modify the entry to unknown\n    self.set[self.primary.name.toLowerCase()] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n\n    // Signal primary left\n    self.emit('left', 'primary', this.primary);\n    // Destroy the instance\n    self.primary.destroy({\n      force: true\n    });\n    // Set the new instance\n    self.primary = server;\n    // Set the set information\n    self.set[serverName] = {\n      type: ServerType.RSPrimary,\n      setVersion: ismaster.setVersion,\n      electionId: ismaster.electionId,\n      setName: ismaster.setName\n    };\n\n    // Set the topology\n    this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    removeFrom(server, self.secondaries);\n    removeFrom(server, self.passives);\n    self.emit('joined', 'primary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  // A possible instance\n  if (!this.primary && ismaster.primary) {\n    self.set[ismaster.primary.toLowerCase()] = {\n      type: ServerType.PossiblePrimary,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n  }\n\n  //\n  // Secondary handling\n  //\n  if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);\n    // Set the topology\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n\n    // Remove primary\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({\n        force: true\n      });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n\n    // Emit secondary joined replicaset\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Arbiter handling\n  //\n  if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);\n    // Set the topology\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    self.emit('joined', 'arbiter', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Passive handling\n  //\n  if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);\n    // Set the topology\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n\n    // Remove primary\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({\n        force: true\n      });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Remove the primary\n  //\n  if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {\n    self.emit('left', 'primary', this.primary);\n    this.primary.destroy({\n      force: true\n    });\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    return false;\n  }\n  this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n  return false;\n};\n\n/**\n * Recalculate single server max staleness\n * @method\n */\nReplSetState.prototype.updateServerMaxStaleness = function (server, haInterval) {\n  // Locate the max secondary lastwrite\n  var max = 0;\n  // Go over all secondaries\n  for (var i = 0; i < this.secondaries.length; i++) {\n    max = Math.max(max, this.secondaries[i].lastWriteDate);\n  }\n\n  // Perform this servers staleness calculation\n  if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {\n    server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;\n  } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {\n    server.staleness = max - server.lastWriteDate + haInterval;\n  }\n};\n\n/**\n * Recalculate all the staleness values for secodaries\n * @method\n */\nReplSetState.prototype.updateSecondariesMaxStaleness = function (haInterval) {\n  for (var i = 0; i < this.secondaries.length; i++) {\n    this.updateServerMaxStaleness(this.secondaries[i], haInterval);\n  }\n};\n\n/**\n * Pick a server by the passed in ReadPreference\n * @method\n * @param {ReadPreference} readPreference The ReadPreference instance to use\n */\nReplSetState.prototype.pickServer = function (readPreference) {\n  // If no read Preference set to primary by default\n  readPreference = readPreference || ReadPreference.primary;\n\n  // maxStalenessSeconds is not allowed with a primary read\n  if (readPreference.preference === 'primary' && readPreference.maxStalenessSeconds != null) {\n    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');\n  }\n\n  // Check if we have any non compatible servers for maxStalenessSeconds\n  var allservers = this.primary ? [this.primary] : [];\n  allservers = allservers.concat(this.secondaries);\n\n  // Does any of the servers not support the right wire protocol version\n  // for maxStalenessSeconds when maxStalenessSeconds specified on readPreference. Then error out\n  if (readPreference.maxStalenessSeconds != null) {\n    for (var i = 0; i < allservers.length; i++) {\n      if (allservers[i].ismaster.maxWireVersion < 5) {\n        return new MongoError('maxStalenessSeconds not supported by at least one of the replicaset members');\n      }\n    }\n  }\n\n  // Do we have the nearest readPreference\n  if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds == null) {\n    return pickNearest(this, readPreference);\n  } else if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds != null) {\n    return pickNearestMaxStalenessSeconds(this, readPreference);\n  }\n\n  // Get all the secondaries\n  var secondaries = this.secondaries;\n\n  // Check if we can satisfy and of the basic read Preferences\n  if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {\n    return new MongoError('no secondary server available');\n  }\n  if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {\n    return new MongoError('no secondary or primary server available');\n  }\n  if (readPreference.equals(ReadPreference.primary) && this.primary == null) {\n    return new MongoError('no primary server available');\n  }\n\n  // Secondary preferred or just secondaries\n  if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      // Pick nearest of any other servers available\n      var server = pickNearest(this, readPreference);\n      // No server in the window return primary\n      if (server) {\n        return server;\n      }\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      // Pick nearest of any other servers available\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n      // No server in the window return primary\n      if (server) {\n        return server;\n      }\n    }\n    if (readPreference.equals(ReadPreference.secondaryPreferred)) {\n      return this.primary;\n    }\n    return null;\n  }\n\n  // Primary preferred\n  if (readPreference.equals(ReadPreference.primaryPreferred)) {\n    server = null;\n\n    // We prefer the primary if it's available\n    if (this.primary) {\n      return this.primary;\n    }\n\n    // Pick a secondary\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      server = pickNearest(this, readPreference);\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n    }\n\n    //  Did we find a server\n    if (server) return server;\n  }\n\n  // Return the primary\n  return this.primary;\n};\n\n//\n// Filter serves by tags\nvar filterByTags = function (readPreference, servers) {\n  if (readPreference.tags == null) return servers;\n  var filteredServers = [];\n  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];\n\n  // Iterate over the tags\n  for (var j = 0; j < tagsArray.length; j++) {\n    var tags = tagsArray[j];\n\n    // Iterate over all the servers\n    for (var i = 0; i < servers.length; i++) {\n      var serverTag = servers[i].lastIsMaster().tags || {};\n\n      // Did we find the a matching server\n      var found = true;\n      // Check if the server is valid\n      for (var name in tags) {\n        if (serverTag[name] !== tags[name]) {\n          found = false;\n        }\n      }\n\n      // Add to candidate list\n      if (found) {\n        filteredServers.push(servers[i]);\n      }\n    }\n  }\n\n  // Returned filtered servers\n  return filteredServers;\n};\nfunction pickNearestMaxStalenessSeconds(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = [];\n\n  // Get the maxStalenessMS\n  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000;\n\n  // Check if the maxStalenessMS > 90 seconds\n  if (maxStalenessMS < 90 * 1000) {\n    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');\n  }\n\n  // Add primary to list if not a secondary read preference\n  if (self.primary && readPreference.preference !== 'secondary' && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Add all the secondaries\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  }\n\n  // If we have a secondaryPreferred readPreference and no server add the primary\n  if (self.primary && servers.length === 0 && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Filter by tags\n  servers = filterByTags(readPreference, servers);\n\n  // Filter by latency\n  servers = servers.filter(function (s) {\n    return s.staleness <= maxStalenessMS;\n  });\n\n  // Sort by time\n  servers.sort(function (a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  });\n\n  // No servers, default to primary\n  if (servers.length === 0) {\n    return null;\n  }\n\n  // Ensure index does not overflow the number of available servers\n  self.index = self.index % servers.length;\n\n  // Get the server\n  var server = servers[self.index];\n  // Add to the index\n  self.index = self.index + 1;\n  // Return the first server of the sorted and filtered list\n  return server;\n}\nfunction pickNearest(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = [];\n\n  // Add primary to list if not a secondary read preference\n  if (self.primary && readPreference.preference !== 'secondary' && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Add all the secondaries\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  }\n\n  // If we have a secondaryPreferred readPreference and no server add the primary\n  if (servers.length === 0 && self.primary && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Filter by tags\n  servers = filterByTags(readPreference, servers);\n\n  // Sort by time\n  servers.sort(function (a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  });\n\n  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)\n  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;\n\n  // Filter by latency\n  servers = servers.filter(function (s) {\n    return s.lastIsMasterMS <= lowest + self.acceptableLatency;\n  });\n\n  // No servers, default to primary\n  if (servers.length === 0) {\n    return null;\n  }\n\n  // Ensure index does not overflow the number of available servers\n  self.index = self.index % servers.length;\n  // Get the server\n  var server = servers[self.index];\n  // Add to the index\n  self.index = self.index + 1;\n  // Return the first server of the sorted and filtered list\n  return server;\n}\nfunction inList(ismaster, server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n  return false;\n}\nfunction addToList(self, type, ismaster, server, list) {\n  var serverName = server.name.toLowerCase();\n  // Update set information about the server instance\n  self.set[serverName].type = type;\n  self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n  self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n  self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n  // Add to the list\n  list.push(server);\n}\nfunction compareObjectIds(id1, id2) {\n  var a = Buffer.from(id1.toHexString(), 'hex');\n  var b = Buffer.from(id2.toHexString(), 'hex');\n  if (a === b) {\n    return 0;\n  }\n  if (typeof Buffer.compare === 'function') {\n    return Buffer.compare(a, b);\n  }\n  var x = a.length;\n  var y = b.length;\n  var len = Math.min(x, y);\n  for (var i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n  if (i !== len) {\n    x = a[i];\n    y = b[i];\n  }\n  return x < y ? -1 : y < x ? 1 : 0;\n}\nfunction removeFrom(server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals && list[i].equals(server)) {\n      list.splice(i, 1);\n      return true;\n    } else if (typeof list[i] === 'string' && list[i].toLowerCase() === server.name.toLowerCase()) {\n      list.splice(i, 1);\n      return true;\n    }\n  }\n  return false;\n}\nfunction emitTopologyDescriptionChanged(self) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    var topology = 'Unknown';\n    var setName = self.setName;\n    if (self.hasPrimaryAndSecondary()) {\n      topology = 'ReplicaSetWithPrimary';\n    } else if (!self.hasPrimary() && self.hasSecondary()) {\n      topology = 'ReplicaSetNoPrimary';\n    }\n\n    // Generate description\n    var description = {\n      topologyType: topology,\n      setName: setName,\n      servers: []\n    };\n\n    // Add the primary to the list\n    if (self.hasPrimary()) {\n      var desc = self.primary.getDescription();\n      desc.type = 'RSPrimary';\n      description.servers.push(desc);\n    }\n\n    // Add all the secondaries\n    description.servers = description.servers.concat(self.secondaries.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    }));\n\n    // Add all the arbiters\n    description.servers = description.servers.concat(self.arbiters.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSArbiter';\n      return description;\n    }));\n\n    // Add all the passives\n    description.servers = description.servers.concat(self.passives.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    }));\n\n    // Get the diff\n    var diffResult = diff(self.replicasetDescription, description);\n\n    // Create the result\n    var result = {\n      topologyId: self.id,\n      previousDescription: self.replicasetDescription,\n      newDescription: description,\n      diff: diffResult\n    };\n\n    // Emit the topologyDescription change\n    // if(diffResult.servers.length > 0) {\n    self.emit('topologyDescriptionChanged', result);\n    // }\n\n    // Set the new description\n    self.replicasetDescription = description;\n  }\n}\nmodule.exports = ReplSetState;","map":{"version":3,"names":["inherits","require","f","format","diff","EventEmitter","Logger","ReadPreference","MongoError","Buffer","TopologyType","Single","ReplicaSetNoPrimary","ReplicaSetWithPrimary","Sharded","Unknown","ServerType","Standalone","Mongos","PossiblePrimary","RSPrimary","RSSecondary","RSArbiter","RSOther","RSGhost","ReplSetState","options","call","topologyType","setName","set","id","logger","index","acceptableLatency","heartbeatFrequencyMS","primary","secondaries","arbiters","passives","ghosts","unknownServers","maxElectionId","maxSetVersion","replicasetDescription","servers","logicalSessionTimeoutMinutes","undefined","prototype","hasPrimaryAndSecondary","length","hasPrimaryOrSecondary","hasPrimary","hasSecondary","get","host","allServers","i","name","toLowerCase","concat","ignoreArbiters","destroy","callback","serversToDestroy","push","serverCount","serverDestroyed","emitTopologyDescriptionChanged","forEach","server","remove","serverName","force","equals","isConnected","type","electionId","setVersion","removeType","removeFrom","emit","isArbiter","ismaster","arbiterOnly","update","self","lastIsMaster","hosts","Array","isArray","map","s","indexOf","inList","Math","min","msg","isreplicaset","hidden","secondary","passive","me","isWarn","warn","ismasterElectionId","result","compareObjectIds","ismasterSetVersion","normalizedHosts","x","locationIndex","currentElectionId","currentSetVersion","currentSetName","ismasterSetName","addToList","updateServerMaxStaleness","haInterval","max","lastWriteDate","maxWireVersion","staleness","lastUpdateTime","updateSecondariesMaxStaleness","pickServer","readPreference","preference","maxStalenessSeconds","allservers","pickNearest","pickNearestMaxStalenessSeconds","secondaryPreferred","primaryPreferred","filterByTags","tags","filteredServers","tagsArray","j","serverTag","found","maxStalenessMS","filter","sort","a","b","lastIsMasterMS","lowest","list","id1","id2","from","toHexString","compare","y","len","splice","listeners","topology","description","desc","getDescription","diffResult","topologyId","previousDescription","newDescription","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/topologies/replset_state.js"],"sourcesContent":["'use strict';\n\nvar inherits = require('util').inherits,\n  f = require('util').format,\n  diff = require('./shared').diff,\n  EventEmitter = require('events').EventEmitter,\n  Logger = require('../connection/logger'),\n  ReadPreference = require('./read_preference'),\n  MongoError = require('../error').MongoError,\n  Buffer = require('safe-buffer').Buffer;\n\nvar TopologyType = {\n  Single: 'Single',\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\n  Sharded: 'Sharded',\n  Unknown: 'Unknown'\n};\n\nvar ServerType = {\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown'\n};\n\nvar ReplSetState = function(options) {\n  options = options || {};\n  // Add event listener\n  EventEmitter.call(this);\n  // Topology state\n  this.topologyType = TopologyType.ReplicaSetNoPrimary;\n  this.setName = options.setName;\n\n  // Server set\n  this.set = {};\n\n  // Unpacked options\n  this.id = options.id;\n  this.setName = options.setName;\n\n  // Replicaset logger\n  this.logger = options.logger || Logger('ReplSet', options);\n\n  // Server selection index\n  this.index = 0;\n  // Acceptable latency\n  this.acceptableLatency = options.acceptableLatency || 15;\n\n  // heartbeatFrequencyMS\n  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n\n  // Server side\n  this.primary = null;\n  this.secondaries = [];\n  this.arbiters = [];\n  this.passives = [];\n  this.ghosts = [];\n  // Current unknown hosts\n  this.unknownServers = [];\n  // In set status\n  this.set = {};\n  // Status\n  this.maxElectionId = null;\n  this.maxSetVersion = 0;\n  // Description of the Replicaset\n  this.replicasetDescription = {\n    topologyType: 'Unknown',\n    servers: []\n  };\n\n  this.logicalSessionTimeoutMinutes = undefined;\n};\n\ninherits(ReplSetState, EventEmitter);\n\nReplSetState.prototype.hasPrimaryAndSecondary = function() {\n  return this.primary != null && this.secondaries.length > 0;\n};\n\nReplSetState.prototype.hasPrimaryOrSecondary = function() {\n  return this.hasPrimary() || this.hasSecondary();\n};\n\nReplSetState.prototype.hasPrimary = function() {\n  return this.primary != null;\n};\n\nReplSetState.prototype.hasSecondary = function() {\n  return this.secondaries.length > 0;\n};\n\nReplSetState.prototype.get = function(host) {\n  var servers = this.allServers();\n\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].name.toLowerCase() === host.toLowerCase()) {\n      return servers[i];\n    }\n  }\n\n  return null;\n};\n\nReplSetState.prototype.allServers = function(options) {\n  options = options || {};\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  if (!options.ignoreArbiters) servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n  return servers;\n};\n\nReplSetState.prototype.destroy = function(options, callback) {\n  const serversToDestroy = this.secondaries\n    .concat(this.arbiters)\n    .concat(this.passives)\n    .concat(this.ghosts);\n  if (this.primary) serversToDestroy.push(this.primary);\n\n  let serverCount = serversToDestroy.length;\n  const serverDestroyed = () => {\n    serverCount--;\n    if (serverCount > 0) {\n      return;\n    }\n\n    // Clear out the complete state\n    this.secondaries = [];\n    this.arbiters = [];\n    this.passives = [];\n    this.ghosts = [];\n    this.unknownServers = [];\n    this.set = {};\n    this.primary = null;\n\n    // Emit the topology changed\n    emitTopologyDescriptionChanged(this);\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n\n  if (serverCount === 0) {\n    serverDestroyed();\n    return;\n  }\n\n  serversToDestroy.forEach(server => server.destroy(options, serverDestroyed));\n};\n\nReplSetState.prototype.remove = function(server, options) {\n  options = options || {};\n\n  // Get the server name and lowerCase it\n  var serverName = server.name.toLowerCase();\n\n  // Only remove if the current server is not connected\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n\n  // Check if it's active and this is just a failed connection attempt\n  for (var i = 0; i < servers.length; i++) {\n    if (\n      !options.force &&\n      servers[i].equals(server) &&\n      servers[i].isConnected &&\n      servers[i].isConnected()\n    ) {\n      return;\n    }\n  }\n\n  // If we have it in the set remove it\n  if (this.set[serverName]) {\n    this.set[serverName].type = ServerType.Unknown;\n    this.set[serverName].electionId = null;\n    this.set[serverName].setName = null;\n    this.set[serverName].setVersion = null;\n  }\n\n  // Remove type\n  var removeType = null;\n\n  // Remove from any lists\n  if (this.primary && this.primary.equals(server)) {\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    removeType = 'primary';\n  }\n\n  // Remove from any other server lists\n  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;\n  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;\n  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;\n  removeFrom(server, this.ghosts);\n  removeFrom(server, this.unknownServers);\n\n  // Push to unknownServers\n  this.unknownServers.push(serverName);\n\n  // Do we have a removeType\n  if (removeType) {\n    this.emit('left', removeType, server);\n  }\n};\n\nconst isArbiter = ismaster => ismaster.arbiterOnly && ismaster.setName;\n\nReplSetState.prototype.update = function(server) {\n  var self = this;\n  // Get the current ismaster\n  var ismaster = server.lastIsMaster();\n\n  // Get the server name and lowerCase it\n  var serverName = server.name.toLowerCase();\n\n  //\n  // Add any hosts\n  //\n  if (ismaster) {\n    // Join all the possible new hosts\n    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];\n    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);\n    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);\n    hosts = hosts.map(function(s) {\n      return s.toLowerCase();\n    });\n\n    // Add all hosts as unknownServers\n    for (var i = 0; i < hosts.length; i++) {\n      // Add to the list of unknown server\n      if (\n        this.unknownServers.indexOf(hosts[i]) === -1 &&\n        (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)\n      ) {\n        this.unknownServers.push(hosts[i].toLowerCase());\n      }\n\n      if (!this.set[hosts[i]]) {\n        this.set[hosts[i]] = {\n          type: ServerType.Unknown,\n          electionId: null,\n          setName: null,\n          setVersion: null\n        };\n      }\n    }\n  }\n\n  //\n  // Unknown server\n  //\n  if (!ismaster && !inList(ismaster, server, this.unknownServers)) {\n    self.set[serverName] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n    // Update set information about the server instance\n    self.set[serverName].type = ServerType.Unknown;\n    self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n    self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n    self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n\n    if (self.unknownServers.indexOf(server.name) === -1) {\n      self.unknownServers.push(serverName);\n    }\n\n    // Set the topology\n    return false;\n  }\n\n  // Update logicalSessionTimeoutMinutes\n  if (ismaster.logicalSessionTimeoutMinutes !== undefined && !isArbiter(ismaster)) {\n    if (\n      self.logicalSessionTimeoutMinutes === undefined ||\n      ismaster.logicalSessionTimeoutMinutes === null\n    ) {\n      self.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;\n    } else {\n      self.logicalSessionTimeoutMinutes = Math.min(\n        self.logicalSessionTimeoutMinutes,\n        ismaster.logicalSessionTimeoutMinutes\n      );\n    }\n  }\n\n  //\n  // Is this a mongos\n  //\n  if (ismaster && ismaster.msg === 'isdbgrid') {\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    return false;\n  }\n\n  // A RSGhost instance\n  if (ismaster.isreplicaset) {\n    self.set[serverName] = {\n      type: ServerType.RSGhost,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n    }\n\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n\n    // Set the topology\n    return false;\n  }\n\n  // A RSOther instance\n  if (\n    (ismaster.setName && ismaster.hidden) ||\n    (ismaster.setName &&\n      !ismaster.ismaster &&\n      !ismaster.secondary &&\n      !ismaster.arbiterOnly &&\n      !ismaster.passive)\n  ) {\n    self.set[serverName] = {\n      type: ServerType.RSOther,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    return false;\n  }\n\n  //\n  // Standalone server, destroy and return\n  //\n  if (ismaster && ismaster.ismaster && !ismaster.setName) {\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;\n    this.remove(server, { force: true });\n    return false;\n  }\n\n  //\n  // Server in maintanance mode\n  //\n  if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {\n    this.remove(server, { force: true });\n    return false;\n  }\n\n  //\n  // If the .me field does not match the passed in server\n  //\n  if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {\n    if (this.logger.isWarn()) {\n      this.logger.warn(\n        f(\n          'the seedlist server was removed due to its address %s not matching its ismaster.me address %s',\n          server.name,\n          ismaster.me\n        )\n      );\n    }\n\n    // Delete from the set\n    delete this.set[serverName];\n    // Delete unknown servers\n    removeFrom(server, self.unknownServers);\n\n    // Destroy the instance\n    server.destroy({ force: true });\n\n    // Set the type of topology we have\n    if (this.primary && !this.primary.equals(server)) {\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    //\n    // We have a potential primary\n    //\n    if (!this.primary && ismaster.primary) {\n      this.set[ismaster.primary.toLowerCase()] = {\n        type: ServerType.PossiblePrimary,\n        setName: null,\n        electionId: null,\n        setVersion: null\n      };\n    }\n\n    return false;\n  }\n\n  //\n  // Primary handling\n  //\n  if (!this.primary && ismaster.ismaster && ismaster.setName) {\n    var ismasterElectionId = server.lastIsMaster().electionId;\n    if (this.setName && this.setName !== ismaster.setName) {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      return new MongoError(\n        f(\n          'setName from ismaster does not match provided connection setName [%s] != [%s]',\n          ismaster.setName,\n          this.setName\n        )\n      );\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      var result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n      // Get the electionIds\n      var ismasterSetVersion = server.lastIsMaster().setVersion;\n\n      if (result === 1) {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n        return false;\n      } else if (result === 0 && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          this.topologyType = TopologyType.ReplicaSetNoPrimary;\n          return false;\n        }\n      }\n\n      this.maxSetVersion = ismasterSetVersion;\n      this.maxElectionId = ismasterElectionId;\n    }\n\n    // Hande normalization of server names\n    var normalizedHosts = ismaster.hosts.map(function(x) {\n      return x.toLowerCase();\n    });\n    var locationIndex = normalizedHosts.indexOf(serverName);\n\n    // Validate that the server exists in the host list\n    if (locationIndex !== -1) {\n      self.primary = server;\n      self.set[serverName] = {\n        type: ServerType.RSPrimary,\n        setVersion: ismaster.setVersion,\n        electionId: ismaster.electionId,\n        setName: ismaster.setName\n      };\n\n      // Set the topology\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      if (ismaster.setName) this.setName = ismaster.setName;\n      removeFrom(server, self.unknownServers);\n      removeFrom(server, self.secondaries);\n      removeFrom(server, self.passives);\n      self.emit('joined', 'primary', server);\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } else if (ismaster.ismaster && ismaster.setName) {\n    // Get the electionIds\n    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;\n    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;\n    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;\n    ismasterElectionId = server.lastIsMaster().electionId;\n    ismasterSetVersion = server.lastIsMaster().setVersion;\n    var ismasterSetName = server.lastIsMaster().setName;\n\n    // Is it the same server instance\n    if (this.primary.equals(server) && currentSetName === ismasterSetName) {\n      return false;\n    }\n\n    // If we do not have the same rs name\n    if (currentSetName && currentSetName !== ismasterSetName) {\n      if (!this.primary.equals(server)) {\n        this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      } else {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      }\n\n      return false;\n    }\n\n    // Check if we need to replace the server\n    if (currentElectionId && ismasterElectionId) {\n      result = compareObjectIds(currentElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion > ismasterSetVersion) {\n        return false;\n      }\n    } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {\n      if (ismasterSetVersion < this.maxSetVersion) {\n        return false;\n      }\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      } else {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      }\n\n      this.maxElectionId = ismasterElectionId;\n      this.maxSetVersion = ismasterSetVersion;\n    } else {\n      this.maxSetVersion = ismasterSetVersion;\n    }\n\n    // Modify the entry to unknown\n    self.set[self.primary.name.toLowerCase()] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n\n    // Signal primary left\n    self.emit('left', 'primary', this.primary);\n    // Destroy the instance\n    self.primary.destroy({ force: true });\n    // Set the new instance\n    self.primary = server;\n    // Set the set information\n    self.set[serverName] = {\n      type: ServerType.RSPrimary,\n      setVersion: ismaster.setVersion,\n      electionId: ismaster.electionId,\n      setName: ismaster.setName\n    };\n\n    // Set the topology\n    this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    removeFrom(server, self.secondaries);\n    removeFrom(server, self.passives);\n    self.emit('joined', 'primary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  // A possible instance\n  if (!this.primary && ismaster.primary) {\n    self.set[ismaster.primary.toLowerCase()] = {\n      type: ServerType.PossiblePrimary,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n  }\n\n  //\n  // Secondary handling\n  //\n  if (\n    ismaster.secondary &&\n    ismaster.setName &&\n    !inList(ismaster, server, this.secondaries) &&\n    this.setName &&\n    this.setName === ismaster.setName\n  ) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n\n    // Remove primary\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({ force: true });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n\n    // Emit secondary joined replicaset\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Arbiter handling\n  //\n  if (\n    isArbiter(ismaster) &&\n    !inList(ismaster, server, this.arbiters) &&\n    this.setName &&\n    this.setName === ismaster.setName\n  ) {\n    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    self.emit('joined', 'arbiter', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Passive handling\n  //\n  if (\n    ismaster.passive &&\n    ismaster.setName &&\n    !inList(ismaster, server, this.passives) &&\n    this.setName &&\n    this.setName === ismaster.setName\n  ) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n\n    // Remove primary\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({ force: true });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Remove the primary\n  //\n  if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {\n    self.emit('left', 'primary', this.primary);\n    this.primary.destroy({ force: true });\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    return false;\n  }\n\n  this.topologyType = this.primary\n    ? TopologyType.ReplicaSetWithPrimary\n    : TopologyType.ReplicaSetNoPrimary;\n  return false;\n};\n\n/**\n * Recalculate single server max staleness\n * @method\n */\nReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {\n  // Locate the max secondary lastwrite\n  var max = 0;\n  // Go over all secondaries\n  for (var i = 0; i < this.secondaries.length; i++) {\n    max = Math.max(max, this.secondaries[i].lastWriteDate);\n  }\n\n  // Perform this servers staleness calculation\n  if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {\n    server.staleness =\n      server.lastUpdateTime -\n      server.lastWriteDate -\n      (this.primary.lastUpdateTime - this.primary.lastWriteDate) +\n      haInterval;\n  } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {\n    server.staleness = max - server.lastWriteDate + haInterval;\n  }\n};\n\n/**\n * Recalculate all the staleness values for secodaries\n * @method\n */\nReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {\n  for (var i = 0; i < this.secondaries.length; i++) {\n    this.updateServerMaxStaleness(this.secondaries[i], haInterval);\n  }\n};\n\n/**\n * Pick a server by the passed in ReadPreference\n * @method\n * @param {ReadPreference} readPreference The ReadPreference instance to use\n */\nReplSetState.prototype.pickServer = function(readPreference) {\n  // If no read Preference set to primary by default\n  readPreference = readPreference || ReadPreference.primary;\n\n  // maxStalenessSeconds is not allowed with a primary read\n  if (readPreference.preference === 'primary' && readPreference.maxStalenessSeconds != null) {\n    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');\n  }\n\n  // Check if we have any non compatible servers for maxStalenessSeconds\n  var allservers = this.primary ? [this.primary] : [];\n  allservers = allservers.concat(this.secondaries);\n\n  // Does any of the servers not support the right wire protocol version\n  // for maxStalenessSeconds when maxStalenessSeconds specified on readPreference. Then error out\n  if (readPreference.maxStalenessSeconds != null) {\n    for (var i = 0; i < allservers.length; i++) {\n      if (allservers[i].ismaster.maxWireVersion < 5) {\n        return new MongoError(\n          'maxStalenessSeconds not supported by at least one of the replicaset members'\n        );\n      }\n    }\n  }\n\n  // Do we have the nearest readPreference\n  if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds == null) {\n    return pickNearest(this, readPreference);\n  } else if (\n    readPreference.preference === 'nearest' &&\n    readPreference.maxStalenessSeconds != null\n  ) {\n    return pickNearestMaxStalenessSeconds(this, readPreference);\n  }\n\n  // Get all the secondaries\n  var secondaries = this.secondaries;\n\n  // Check if we can satisfy and of the basic read Preferences\n  if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {\n    return new MongoError('no secondary server available');\n  }\n\n  if (\n    readPreference.equals(ReadPreference.secondaryPreferred) &&\n    secondaries.length === 0 &&\n    this.primary == null\n  ) {\n    return new MongoError('no secondary or primary server available');\n  }\n\n  if (readPreference.equals(ReadPreference.primary) && this.primary == null) {\n    return new MongoError('no primary server available');\n  }\n\n  // Secondary preferred or just secondaries\n  if (\n    readPreference.equals(ReadPreference.secondaryPreferred) ||\n    readPreference.equals(ReadPreference.secondary)\n  ) {\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      // Pick nearest of any other servers available\n      var server = pickNearest(this, readPreference);\n      // No server in the window return primary\n      if (server) {\n        return server;\n      }\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      // Pick nearest of any other servers available\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n      // No server in the window return primary\n      if (server) {\n        return server;\n      }\n    }\n\n    if (readPreference.equals(ReadPreference.secondaryPreferred)) {\n      return this.primary;\n    }\n\n    return null;\n  }\n\n  // Primary preferred\n  if (readPreference.equals(ReadPreference.primaryPreferred)) {\n    server = null;\n\n    // We prefer the primary if it's available\n    if (this.primary) {\n      return this.primary;\n    }\n\n    // Pick a secondary\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      server = pickNearest(this, readPreference);\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n    }\n\n    //  Did we find a server\n    if (server) return server;\n  }\n\n  // Return the primary\n  return this.primary;\n};\n\n//\n// Filter serves by tags\nvar filterByTags = function(readPreference, servers) {\n  if (readPreference.tags == null) return servers;\n  var filteredServers = [];\n  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];\n\n  // Iterate over the tags\n  for (var j = 0; j < tagsArray.length; j++) {\n    var tags = tagsArray[j];\n\n    // Iterate over all the servers\n    for (var i = 0; i < servers.length; i++) {\n      var serverTag = servers[i].lastIsMaster().tags || {};\n\n      // Did we find the a matching server\n      var found = true;\n      // Check if the server is valid\n      for (var name in tags) {\n        if (serverTag[name] !== tags[name]) {\n          found = false;\n        }\n      }\n\n      // Add to candidate list\n      if (found) {\n        filteredServers.push(servers[i]);\n      }\n    }\n  }\n\n  // Returned filtered servers\n  return filteredServers;\n};\n\nfunction pickNearestMaxStalenessSeconds(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = [];\n\n  // Get the maxStalenessMS\n  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000;\n\n  // Check if the maxStalenessMS > 90 seconds\n  if (maxStalenessMS < 90 * 1000) {\n    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');\n  }\n\n  // Add primary to list if not a secondary read preference\n  if (\n    self.primary &&\n    readPreference.preference !== 'secondary' &&\n    readPreference.preference !== 'secondaryPreferred'\n  ) {\n    servers.push(self.primary);\n  }\n\n  // Add all the secondaries\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  }\n\n  // If we have a secondaryPreferred readPreference and no server add the primary\n  if (self.primary && servers.length === 0 && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Filter by tags\n  servers = filterByTags(readPreference, servers);\n\n  // Filter by latency\n  servers = servers.filter(function(s) {\n    return s.staleness <= maxStalenessMS;\n  });\n\n  // Sort by time\n  servers.sort(function(a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  });\n\n  // No servers, default to primary\n  if (servers.length === 0) {\n    return null;\n  }\n\n  // Ensure index does not overflow the number of available servers\n  self.index = self.index % servers.length;\n\n  // Get the server\n  var server = servers[self.index];\n  // Add to the index\n  self.index = self.index + 1;\n  // Return the first server of the sorted and filtered list\n  return server;\n}\n\nfunction pickNearest(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = [];\n\n  // Add primary to list if not a secondary read preference\n  if (\n    self.primary &&\n    readPreference.preference !== 'secondary' &&\n    readPreference.preference !== 'secondaryPreferred'\n  ) {\n    servers.push(self.primary);\n  }\n\n  // Add all the secondaries\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  }\n\n  // If we have a secondaryPreferred readPreference and no server add the primary\n  if (servers.length === 0 && self.primary && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Filter by tags\n  servers = filterByTags(readPreference, servers);\n\n  // Sort by time\n  servers.sort(function(a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  });\n\n  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)\n  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;\n\n  // Filter by latency\n  servers = servers.filter(function(s) {\n    return s.lastIsMasterMS <= lowest + self.acceptableLatency;\n  });\n\n  // No servers, default to primary\n  if (servers.length === 0) {\n    return null;\n  }\n\n  // Ensure index does not overflow the number of available servers\n  self.index = self.index % servers.length;\n  // Get the server\n  var server = servers[self.index];\n  // Add to the index\n  self.index = self.index + 1;\n  // Return the first server of the sorted and filtered list\n  return server;\n}\n\nfunction inList(ismaster, server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())\n      return true;\n  }\n\n  return false;\n}\n\nfunction addToList(self, type, ismaster, server, list) {\n  var serverName = server.name.toLowerCase();\n  // Update set information about the server instance\n  self.set[serverName].type = type;\n  self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n  self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n  self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n  // Add to the list\n  list.push(server);\n}\n\nfunction compareObjectIds(id1, id2) {\n  var a = Buffer.from(id1.toHexString(), 'hex');\n  var b = Buffer.from(id2.toHexString(), 'hex');\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (typeof Buffer.compare === 'function') {\n    return Buffer.compare(a, b);\n  }\n\n  var x = a.length;\n  var y = b.length;\n  var len = Math.min(x, y);\n\n  for (var i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n\n  if (i !== len) {\n    x = a[i];\n    y = b[i];\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0;\n}\n\nfunction removeFrom(server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals && list[i].equals(server)) {\n      list.splice(i, 1);\n      return true;\n    } else if (typeof list[i] === 'string' && list[i].toLowerCase() === server.name.toLowerCase()) {\n      list.splice(i, 1);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction emitTopologyDescriptionChanged(self) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    var topology = 'Unknown';\n    var setName = self.setName;\n\n    if (self.hasPrimaryAndSecondary()) {\n      topology = 'ReplicaSetWithPrimary';\n    } else if (!self.hasPrimary() && self.hasSecondary()) {\n      topology = 'ReplicaSetNoPrimary';\n    }\n\n    // Generate description\n    var description = {\n      topologyType: topology,\n      setName: setName,\n      servers: []\n    };\n\n    // Add the primary to the list\n    if (self.hasPrimary()) {\n      var desc = self.primary.getDescription();\n      desc.type = 'RSPrimary';\n      description.servers.push(desc);\n    }\n\n    // Add all the secondaries\n    description.servers = description.servers.concat(\n      self.secondaries.map(function(x) {\n        var description = x.getDescription();\n        description.type = 'RSSecondary';\n        return description;\n      })\n    );\n\n    // Add all the arbiters\n    description.servers = description.servers.concat(\n      self.arbiters.map(function(x) {\n        var description = x.getDescription();\n        description.type = 'RSArbiter';\n        return description;\n      })\n    );\n\n    // Add all the passives\n    description.servers = description.servers.concat(\n      self.passives.map(function(x) {\n        var description = x.getDescription();\n        description.type = 'RSSecondary';\n        return description;\n      })\n    );\n\n    // Get the diff\n    var diffResult = diff(self.replicasetDescription, description);\n\n    // Create the result\n    var result = {\n      topologyId: self.id,\n      previousDescription: self.replicasetDescription,\n      newDescription: description,\n      diff: diffResult\n    };\n\n    // Emit the topologyDescription change\n    // if(diffResult.servers.length > 0) {\n    self.emit('topologyDescriptionChanged', result);\n    // }\n\n    // Set the new description\n    self.replicasetDescription = description;\n  }\n}\n\nmodule.exports = ReplSetState;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}