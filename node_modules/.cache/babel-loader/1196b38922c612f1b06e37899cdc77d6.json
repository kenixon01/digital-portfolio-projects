{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\nconst BufferList = require('bl');\nconst MongoParseError = require('../core/error').MongoParseError;\nconst decompress = require('../core/wireprotocol/compression').decompress;\nconst Response = require('../core/connection/commands').Response;\nconst BinMsg = require('../core/connection/msg').BinMsg;\nconst MongoError = require('../core/error').MongoError;\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\nconst compress = require('../core/wireprotocol/compression').compress;\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\nconst Msg = require('../core/connection/msg').Msg;\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new BufferList();\n  }\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n    processIncomingData(this, callback);\n  }\n  _read( /* size */\n  ) {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    // Compress the message body\n    compress({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      }\n\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n}\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n  const sizeOfMessage = buffer.readInt32LE(0);\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n  const message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n    return;\n  }\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (messageBody.length !== messageHeader.length) {\n      callback(new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\nmodule.exports = MessageStream;","map":{"version":3,"names":["Duplex","require","BufferList","MongoParseError","decompress","Response","BinMsg","MongoError","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","compress","compressorIDs","uncompressibleCommands","Msg","kDefaultMaxBsonMessageSize","kBuffer","Symbol","MessageStream","constructor","options","bson","maxBsonMessageSize","_write","chunk","_","callback","buffer","append","processIncomingData","_read","writeCommand","command","operationDescription","shouldCompress","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","err","compressedMessage","cb","msgHeader","alloc","writeInt32LE","length","requestId","compressionDetails","writeUInt8","commandDoc","query","commandName","Object","keys","has","stream","sizeOfMessage","message","consume","messageHeader","responseTo","opCode","ResponseType","responseOptions","messageBody","emit","fromCompressed","compressorID","compressedBuffer","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/cmap/message_stream.js"],"sourcesContent":["'use strict';\n\nconst Duplex = require('stream').Duplex;\nconst BufferList = require('bl');\nconst MongoParseError = require('../core/error').MongoParseError;\nconst decompress = require('../core/wireprotocol/compression').decompress;\nconst Response = require('../core/connection/commands').Response;\nconst BinMsg = require('../core/connection/msg').BinMsg;\nconst MongoError = require('../core/error').MongoError;\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\nconst compress = require('../core/wireprotocol/compression').compress;\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\nconst Msg = require('../core/connection/msg').Msg;\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n\n    this[kBuffer] = new BufferList();\n  }\n\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n\n    processIncomingData(this, callback);\n  }\n\n  _read(/* size */) {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    // Compress the message body\n    compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      }\n\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(\n        MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n        0\n      ); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n}\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.readInt32LE(0);\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(\n      new MongoParseError(\n        `Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`\n      )\n    );\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n\nmodule.exports = MessageStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}