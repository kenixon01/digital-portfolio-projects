{"ast":null,"code":"'use strict';\n\nconst inherits = require('util').inherits;\nconst f = require('util').format;\nconst EventEmitter = require('events').EventEmitter;\nconst ReadPreference = require('./read_preference');\nconst CoreCursor = require('../cursor').CoreCursor;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst Logger = require('../connection/logger');\nconst MongoError = require('../error').MongoError;\nconst Server = require('./server');\nconst ReplSetState = require('./replset_state');\nconst Timeout = require('./shared').Timeout;\nconst Interval = require('./shared').Interval;\nconst SessionMixins = require('./shared').SessionMixins;\nconst isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;\nconst relayEvents = require('../utils').relayEvents;\nconst BSON = retrieveBSON();\nconst getMMAPError = require('./shared').getMMAPError;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst legacyIsRetryableWriteError = require('./shared').legacyIsRetryableWriteError;\nconst now = require('../../utils').now;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\n//\n// States\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar UNREFERENCED = 'unreferenced';\nvar DESTROYED = 'destroyed';\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],\n    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],\n    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],\n    unreferenced: [UNREFERENCED, DESTROYED],\n    destroyed: [DESTROYED]\n  };\n\n  // Get current state\n  var legalStates = legalTransitions[self.state];\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\n    self.state = newState;\n  } else {\n    self.s.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));\n  }\n}\n\n//\n// ReplSet instance id\nvar id = 1;\nvar handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];\n\n/**\n * Creates a new Replset instance\n * @class\n * @param {array} seedlist A list of seeds for the replicaset\n * @param {boolean} options.setName The Replicaset set name\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.bsonRegExp=false] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {ReplSet} A cursor instance\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n * @fires ReplSet#failed\n * @fires ReplSet#fullsetup\n * @fires ReplSet#all\n * @fires ReplSet#error\n * @fires ReplSet#serverHeartbeatStarted\n * @fires ReplSet#serverHeartbeatSucceeded\n * @fires ReplSet#serverHeartbeatFailed\n * @fires ReplSet#topologyOpening\n * @fires ReplSet#topologyClosed\n * @fires ReplSet#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\nvar ReplSet = function (seedlist, options) {\n  var self = this;\n  options = options || {};\n\n  // Validate seedlist\n  if (!Array.isArray(seedlist)) throw new MongoError('seedlist must be an array');\n  // Validate list\n  if (seedlist.length === 0) throw new MongoError('seedlist must contain at least one entry');\n  // Validate entries\n  seedlist.forEach(function (e) {\n    if (typeof e.host !== 'string' || typeof e.port !== 'number') throw new MongoError('seedlist entry must contain a host and port');\n  });\n\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Get replSet Id\n  this.id = id++;\n\n  // Get the localThresholdMS\n  var localThresholdMS = options.localThresholdMS || 15;\n  // Backward compatibility\n  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency;\n\n  // Create a logger\n  var logger = Logger('ReplSet', options);\n\n  // Internal state\n  this.s = {\n    options: Object.assign({\n      metadata: makeClientMetadata(options)\n    }, options),\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // Logger instance\n    logger: logger,\n    // Seedlist\n    seedlist: seedlist,\n    // Replicaset state\n    replicaSetState: new ReplSetState({\n      id: this.id,\n      setName: options.setName,\n      acceptableLatency: localThresholdMS,\n      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,\n      logger: logger\n    }),\n    // Current servers we are connecting to\n    connectingServers: [],\n    // Ha interval\n    haInterval: options.haInterval ? options.haInterval : 10000,\n    // Minimum heartbeat frequency used if we detect a server close\n    minHeartbeatFrequencyMS: 500,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Server selection index\n    index: 0,\n    // Connect function options passed in\n    connectOptions: {},\n    // Are we running in debug mode\n    debug: typeof options.debug === 'boolean' ? options.debug : false\n  };\n\n  // Add handler for topology change\n  this.s.replicaSetState.on('topologyDescriptionChanged', function (r) {\n    self.emit('topologyDescriptionChanged', r);\n  });\n\n  // Log info warning if the socketTimeout < haInterval as it will cause\n  // a lot of recycled connections to happen.\n  if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {\n    this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts', this.s.options.socketTimeout, this.s.haInterval));\n  }\n\n  // Add forwarding of events from state handler\n  var types = ['joined', 'left'];\n  types.forEach(function (x) {\n    self.s.replicaSetState.on(x, function (t, s) {\n      self.emit(x, t, s);\n    });\n  });\n\n  // Connect stat\n  this.initialConnectState = {\n    connect: false,\n    fullsetup: false,\n    all: false\n  };\n\n  // Disconnected state\n  this.state = DISCONNECTED;\n  this.haTimeoutId = null;\n  // Last ismaster\n  this.ismaster = null;\n  // Contains the intervalId\n  this.intervalIds = [];\n\n  // Highest clusterTime seen in responses from the current deployment\n  this.clusterTime = null;\n};\ninherits(ReplSet, EventEmitter);\nObject.assign(ReplSet.prototype, SessionMixins);\nObject.defineProperty(ReplSet.prototype, 'type', {\n  enumerable: true,\n  get: function () {\n    return 'replset';\n  }\n});\nObject.defineProperty(ReplSet.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\nObject.defineProperty(ReplSet.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function () {\n    return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;\n  }\n});\nfunction rexecuteOperations(self) {\n  // If we have a primary and a disconnect handler, execute\n  // buffered operations\n  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute();\n  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executePrimary: true\n    });\n  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executeSecondary: true\n    });\n  }\n}\nfunction connectNewServers(self, servers, callback) {\n  // No new servers\n  if (servers.length === 0) {\n    return callback();\n  }\n\n  // Count lefts\n  var count = servers.length;\n  var error = null;\n  function done() {\n    count = count - 1;\n    if (count === 0) {\n      callback(error);\n    }\n  }\n\n  // Handle events\n  var _handleEvent = function (self, event) {\n    return function (err) {\n      var _self = this;\n\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        this.destroy({\n          force: true\n        });\n        return done();\n      }\n      if (event === 'connect') {\n        // Update the state\n        var result = self.s.replicaSetState.update(_self);\n        // Update the state with the new server\n        if (result) {\n          // Primary lastIsMaster store it\n          if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {\n            self.ismaster = _self.lastIsMaster();\n          }\n\n          // Remove the handlers\n          for (let i = 0; i < handlers.length; i++) {\n            _self.removeAllListeners(handlers[i]);\n          }\n\n          // Add stable state handlers\n          _self.on('error', handleEvent(self, 'error'));\n          _self.on('close', handleEvent(self, 'close'));\n          _self.on('timeout', handleEvent(self, 'timeout'));\n          _self.on('parseError', handleEvent(self, 'parseError'));\n\n          // Enalbe the monitoring of the new server\n          monitorServer(_self.lastIsMaster().me, self, {});\n\n          // Rexecute any stalled operation\n          rexecuteOperations(self);\n        } else {\n          _self.destroy({\n            force: true\n          });\n        }\n      } else if (event === 'error') {\n        error = err;\n      }\n\n      // Rexecute any stalled operation\n      rexecuteOperations(self);\n      done();\n    };\n  };\n\n  // Execute method\n  function execute(_server, i) {\n    setTimeout(function () {\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      // remove existing connecting server if it's failed to connect, otherwise\n      // wait for that server to connect\n      const existingServerIdx = self.s.connectingServers.findIndex(s => s.name === _server);\n      if (existingServerIdx >= 0) {\n        const connectingServer = self.s.connectingServers[existingServerIdx];\n        connectingServer.destroy({\n          force: true\n        });\n        self.s.connectingServers.splice(existingServerIdx, 1);\n        return done();\n      }\n\n      // Create a new server instance\n      var server = new Server(Object.assign({}, self.s.options, {\n        host: _server.split(':')[0],\n        port: parseInt(_server.split(':')[1], 10),\n        reconnect: false,\n        monitoring: false,\n        parent: self\n      }));\n\n      // Add temp handlers\n      server.once('connect', _handleEvent(self, 'connect'));\n      server.once('close', _handleEvent(self, 'close'));\n      server.once('timeout', _handleEvent(self, 'timeout'));\n      server.once('error', _handleEvent(self, 'error'));\n      server.once('parseError', _handleEvent(self, 'parseError'));\n\n      // SDAM Monitoring events\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e));\n\n      // Command Monitoring events\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n      self.s.connectingServers.push(server);\n      server.connect(self.s.connectOptions);\n    }, i);\n  }\n\n  // Create new instances\n  for (var i = 0; i < servers.length; i++) {\n    execute(servers[i], i);\n  }\n}\n\n// Ping the server\nvar pingServer = function (self, server, cb) {\n  // Measure running time\n  var start = new Date().getTime();\n\n  // Emit the server heartbeat start\n  emitSDAMEvent(self, 'serverHeartbeatStarted', {\n    connectionId: server.name\n  });\n\n  // Execute ismaster\n  // Set the socketTimeout for a monitoring message to a low number\n  // Ensuring ismaster calls are timed out quickly\n  server.command('admin.$cmd', {\n    ismaster: true\n  }, {\n    monitoring: true,\n    socketTimeout: self.s.options.connectionTimeout || 2000\n  }, function (err, r) {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      server.destroy({\n        force: true\n      });\n      return cb(err, r);\n    }\n\n    // Calculate latency\n    var latencyMS = new Date().getTime() - start;\n\n    // Set the last updatedTime\n    server.lastUpdateTime = now();\n\n    // We had an error, remove it from the state\n    if (err) {\n      // Emit the server heartbeat failure\n      emitSDAMEvent(self, 'serverHeartbeatFailed', {\n        durationMS: latencyMS,\n        failure: err,\n        connectionId: server.name\n      });\n\n      // Remove server from the state\n      self.s.replicaSetState.remove(server);\n    } else {\n      // Update the server ismaster\n      server.ismaster = r.result;\n\n      // Check if we have a lastWriteDate convert it to MS\n      // and store on the server instance for later use\n      if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {\n        server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();\n      }\n\n      // Do we have a brand new server\n      if (server.lastIsMasterMS === -1) {\n        server.lastIsMasterMS = latencyMS;\n      } else if (server.lastIsMasterMS) {\n        // After the first measurement, average RTT MUST be computed using an\n        // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.\n        // If the prior average is denoted old_rtt, then the new average (new_rtt) is\n        // computed from a new RTT measurement (x) using the following formula:\n        // alpha = 0.2\n        // new_rtt = alpha * x + (1 - alpha) * old_rtt\n        server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;\n      }\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      }\n\n      // Server heart beat event\n      emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n        durationMS: latencyMS,\n        reply: r.result,\n        connectionId: server.name\n      });\n    }\n\n    // Calculate the staleness for this server\n    self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval);\n\n    // Callback\n    cb(err, r);\n  });\n};\n\n// Each server is monitored in parallel in their own timeout loop\nvar monitorServer = function (host, self, options) {\n  // If this is not the initial scan\n  // Is this server already being monitoried, then skip monitoring\n  if (!options.haInterval) {\n    for (var i = 0; i < self.intervalIds.length; i++) {\n      if (self.intervalIds[i].__host === host) {\n        return;\n      }\n    }\n  }\n\n  // Get the haInterval\n  var _process = options.haInterval ? Timeout : Interval;\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  // Create the interval\n  var intervalId = new _process(function () {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      // clearInterval(intervalId);\n      intervalId.stop();\n      return;\n    }\n\n    // Do we already have server connection available for this host\n    var _server = self.s.replicaSetState.get(host);\n\n    // Check if we have a known server connection and reuse\n    if (_server) {\n      // Ping the server\n      return pingServer(self, _server, function (err) {\n        if (err) {\n          // NOTE: should something happen here?\n          return;\n        }\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\n          intervalId.stop();\n          return;\n        }\n\n        // Filter out all called intervaliIds\n        self.intervalIds = self.intervalIds.filter(function (intervalId) {\n          return intervalId.isRunning();\n        });\n\n        // Initial sweep\n        if (_process === Timeout) {\n          if (self.state === CONNECTING && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            stateTransition(self, CONNECTED);\n\n            // Emit connected sign\n            process.nextTick(function () {\n              self.emit('connect', self);\n            });\n\n            // Start topology interval check\n            topologyMonitor(self, {});\n          }\n        } else {\n          if (self.state === DISCONNECTED && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            stateTransition(self, CONNECTING);\n\n            // Rexecute any stalled operation\n            rexecuteOperations(self);\n\n            // Emit connected sign\n            process.nextTick(function () {\n              self.emit('reconnect', self);\n            });\n          }\n        }\n        if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n          // Set initial connect state\n          self.initialConnectState.fullsetup = true;\n          self.initialConnectState.all = true;\n          process.nextTick(function () {\n            self.emit('fullsetup', self);\n            self.emit('all', self);\n          });\n        }\n      });\n    }\n  }, _haInterval);\n\n  // Start the interval\n  intervalId.start();\n  // Add the intervalId host name\n  intervalId.__host = host;\n  // Add the intervalId to our list of intervalIds\n  self.intervalIds.push(intervalId);\n};\nfunction topologyMonitor(self, options) {\n  if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n  options = options || {};\n\n  // Get the servers\n  var servers = Object.keys(self.s.replicaSetState.set);\n\n  // Get the haInterval\n  var _process = options.haInterval ? Timeout : Interval;\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n  if (_process === Timeout) {\n    return connectNewServers(self, self.s.replicaSetState.unknownServers, function (err) {\n      // Don't emit errors if the connection was already\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n        self.emit('error', new MongoError('no primary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      } else if (!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n        self.emit('error', new MongoError('no secondary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      }\n      for (var i = 0; i < servers.length; i++) {\n        monitorServer(servers[i], self, options);\n      }\n    });\n  } else {\n    for (var i = 0; i < servers.length; i++) {\n      monitorServer(servers[i], self, options);\n    }\n  }\n\n  // Run the reconnect process\n  function executeReconnect(self) {\n    return function () {\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n      connectNewServers(self, self.s.replicaSetState.unknownServers, function () {\n        var monitoringFrequencey = self.s.replicaSetState.hasPrimary() ? _haInterval : self.s.minHeartbeatFrequencyMS;\n\n        // Create a timeout\n        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());\n      });\n    };\n  }\n\n  // Decide what kind of interval to use\n  var intervalTime = !self.s.replicaSetState.hasPrimary() ? self.s.minHeartbeatFrequencyMS : _haInterval;\n  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());\n}\nfunction addServerToList(list, server) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n  list.push(server);\n}\nfunction handleEvent(self, event) {\n  return function () {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n    // Debug log\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    }\n\n    // Remove from the replicaset state\n    self.s.replicaSetState.remove(this);\n\n    // Are we in a destroyed state return\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n\n    // If no primary and secondary available\n    if (!self.s.replicaSetState.hasPrimary() && !self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n      stateTransition(self, DISCONNECTED);\n    } else if (!self.s.replicaSetState.hasPrimary()) {\n      stateTransition(self, DISCONNECTED);\n    }\n    addServerToList(self.s.connectingServers, this);\n  };\n}\nfunction shouldTriggerConnect(self) {\n  const isConnecting = self.state === CONNECTING;\n  const hasPrimary = self.s.replicaSetState.hasPrimary();\n  const hasSecondary = self.s.replicaSetState.hasSecondary();\n  const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;\n  const readPreferenceSecondary = self.s.connectOptions.readPreference && self.s.connectOptions.readPreference.equals(ReadPreference.secondary);\n  return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;\n}\nfunction handleInitialConnectEvent(self, event) {\n  return function () {\n    var _this = this;\n    // Debug log\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    }\n\n    // Destroy the instance\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      return this.destroy({\n        force: true\n      });\n    }\n\n    // Check the type of server\n    if (event === 'connect') {\n      // Update the state\n      var result = self.s.replicaSetState.update(_this);\n      if (result === true) {\n        // Primary lastIsMaster store it\n        if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {\n          self.ismaster = _this.lastIsMaster();\n        }\n\n        // Debug log\n        if (self.s.logger.isDebug()) {\n          self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]', event, _this.name, self.id, JSON.stringify(self.s.replicaSetState.set)));\n        }\n\n        // Remove the handlers\n        for (let i = 0; i < handlers.length; i++) {\n          _this.removeAllListeners(handlers[i]);\n        }\n\n        // Add stable state handlers\n        _this.on('error', handleEvent(self, 'error'));\n        _this.on('close', handleEvent(self, 'close'));\n        _this.on('timeout', handleEvent(self, 'timeout'));\n        _this.on('parseError', handleEvent(self, 'parseError'));\n\n        // Do we have a primary or primaryAndSecondary\n        if (shouldTriggerConnect(self)) {\n          // We are connected\n          stateTransition(self, CONNECTED);\n\n          // Set initial connect state\n          self.initialConnectState.connect = true;\n          // Emit connect event\n          process.nextTick(function () {\n            self.emit('connect', self);\n          });\n          topologyMonitor(self, {});\n        }\n      } else if (result instanceof MongoError) {\n        _this.destroy({\n          force: true\n        });\n        self.destroy({\n          force: true\n        });\n        return self.emit('error', result);\n      } else {\n        _this.destroy({\n          force: true\n        });\n      }\n    } else {\n      // Emit failure to connect\n      self.emit('failed', this);\n      addServerToList(self.s.connectingServers, this);\n      // Remove from the state\n      self.s.replicaSetState.remove(this);\n    }\n    if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n      // Set initial connect state\n      self.initialConnectState.fullsetup = true;\n      self.initialConnectState.all = true;\n      process.nextTick(function () {\n        self.emit('fullsetup', self);\n        self.emit('all', self);\n      });\n    }\n\n    // Remove from the list from connectingServers\n    for (var i = 0; i < self.s.connectingServers.length; i++) {\n      if (self.s.connectingServers[i].equals(this)) {\n        self.s.connectingServers.splice(i, 1);\n      }\n    }\n\n    // Trigger topologyMonitor\n    if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {\n      topologyMonitor(self, {\n        haInterval: 1\n      });\n    }\n  };\n}\nfunction connectServers(self, servers) {\n  // Update connectingServers\n  self.s.connectingServers = self.s.connectingServers.concat(servers);\n\n  // Index used to interleaf the server connects, avoiding\n  // runtime issues on io constrained vm's\n  var timeoutInterval = 0;\n  function connect(server, timeoutInterval) {\n    setTimeout(function () {\n      // Add the server to the state\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      }\n\n      // Add event handlers\n      server.once('close', handleInitialConnectEvent(self, 'close'));\n      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));\n      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));\n      server.once('error', handleInitialConnectEvent(self, 'error'));\n      server.once('connect', handleInitialConnectEvent(self, 'connect'));\n\n      // SDAM Monitoring events\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e));\n\n      // Command Monitoring events\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n      // Start connection\n      server.connect(self.s.connectOptions);\n    }, timeoutInterval);\n  }\n\n  // Start all the servers\n  while (servers.length > 0) {\n    connect(servers.shift(), timeoutInterval++);\n  }\n}\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\n/**\n * Initiate server connect\n */\nReplSet.prototype.connect = function (options) {\n  var self = this;\n  // Add any connect level options to the internal state\n  this.s.connectOptions = options || {};\n\n  // Set connecting state\n  stateTransition(this, CONNECTING);\n\n  // Create server instances\n  var servers = this.s.seedlist.map(function (x) {\n    return new Server(Object.assign({}, self.s.options, x, options, {\n      reconnect: false,\n      monitoring: false,\n      parent: self\n    }));\n  });\n\n  // Error out as high availability interval must be < than socketTimeout\n  if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {\n    return self.emit('error', new MongoError(f('haInterval [%s] MS must be set to less than socketTimeout [%s] MS', this.s.options.haInterval, this.s.options.socketTimeout)));\n  }\n\n  // Emit the topology opening event\n  emitSDAMEvent(this, 'topologyOpening', {\n    topologyId: this.id\n  });\n  // Start all server connections\n  connectServers(self, servers);\n};\n\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\nReplSet.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Destroy the server connection\n * @param {boolean} [options.force=false] Force destroy the pool\n * @method\n */\nReplSet.prototype.destroy = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  let destroyCount = this.s.connectingServers.length + 1; // +1 for the callback from `replicaSetState.destroy`\n  const serverDestroyed = () => {\n    destroyCount--;\n    if (destroyCount > 0) {\n      return;\n    }\n\n    // Emit toplogy closing event\n    emitSDAMEvent(this, 'topologyClosed', {\n      topologyId: this.id\n    });\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n  if (this.state === DESTROYED) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  // Transition state\n  stateTransition(this, DESTROYED);\n\n  // Clear out any monitoring process\n  if (this.haTimeoutId) clearTimeout(this.haTimeoutId);\n\n  // Clear out all monitoring\n  for (var i = 0; i < this.intervalIds.length; i++) {\n    this.intervalIds[i].stop();\n  }\n\n  // Reset list of intervalIds\n  this.intervalIds = [];\n  if (destroyCount === 0) {\n    serverDestroyed();\n    return;\n  }\n\n  // Destroy the replicaset\n  this.s.replicaSetState.destroy(options, serverDestroyed);\n\n  // Destroy all connecting servers\n  this.s.connectingServers.forEach(function (x) {\n    x.destroy(options, serverDestroyed);\n  });\n};\n\n/**\n * Unref all connections belong to this server\n * @method\n */\nReplSet.prototype.unref = function () {\n  // Transition state\n  stateTransition(this, UNREFERENCED);\n  this.s.replicaSetState.allServers().forEach(function (x) {\n    x.unref();\n  });\n  clearTimeout(this.haTimeoutId);\n};\n\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\nReplSet.prototype.lastIsMaster = function () {\n  // If secondaryOnlyConnectionAllowed and no primary but secondary\n  // return the secondaries ismaster result.\n  if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {\n    return this.s.replicaSetState.secondaries[0].lastIsMaster();\n  }\n  return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;\n};\n\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\nReplSet.prototype.connections = function () {\n  var servers = this.s.replicaSetState.allServers();\n  var connections = [];\n  for (var i = 0; i < servers.length; i++) {\n    connections = connections.concat(servers[i].connections());\n  }\n  return connections;\n};\n\n/**\n * Figure out if the server is connected\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {boolean}\n */\nReplSet.prototype.isConnected = function (options) {\n  options = options || {};\n\n  // If we specified a read preference check if we are connected to something\n  // than can satisfy this\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\n    return this.s.replicaSetState.hasSecondary();\n  }\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\n    return this.s.replicaSetState.hasPrimary();\n  }\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {\n    return true;\n  }\n  return this.s.replicaSetState.hasPrimary();\n};\n\n/**\n * Figure out if the replicaset instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\nReplSet.prototype.isDestroyed = function () {\n  return this.state === DESTROYED;\n};\nconst SERVER_SELECTION_TIMEOUT_MS = 10000; // hardcoded `serverSelectionTimeoutMS` for legacy topology\nconst SERVER_SELECTION_INTERVAL_MS = 1000; // time to wait between selection attempts\n/**\n * Selects a server\n *\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {ClientSession} [options.session] Unused\n * @param {function} callback\n */\nReplSet.prototype.selectServer = function (selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined') callback = selector, selector = undefined, options = {};\n  if (typeof options === 'function') callback = options, options = selector;\n  options = options || {};\n  let readPreference;\n  if (selector instanceof ReadPreference) {\n    readPreference = selector;\n  } else {\n    readPreference = options.readPreference || ReadPreference.primary;\n  }\n  let lastError;\n  const start = now();\n  const _selectServer = () => {\n    if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {\n      if (lastError != null) {\n        callback(lastError, null);\n      } else {\n        callback(new MongoError('Server selection timed out'));\n      }\n      return;\n    }\n    const server = this.s.replicaSetState.pickServer(readPreference);\n    if (server == null) {\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n    if (!(server instanceof Server)) {\n      lastError = server;\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n    if (this.s.debug) this.emit('pickedServer', options.readPreference, server);\n    callback(null, server);\n  };\n  _selectServer();\n};\n\n/**\n * Get all connected servers\n * @method\n * @return {Server[]}\n */\nReplSet.prototype.getServers = function () {\n  return this.s.replicaSetState.allServers();\n};\n\n//\n// Execute write operation\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const self = args.self;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n  if (self.state === DESTROYED) {\n    return callback(new MongoError(f('topology was destroyed')));\n  }\n  const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self) && !options.session.inTransaction() && options.explain === undefined;\n  if (!self.s.replicaSetState.hasPrimary()) {\n    if (self.s.disconnectHandler) {\n      // Not connected but we have a disconnecthandler\n      return self.s.disconnectHandler.add(op, ns, ops, options, callback);\n    } else if (!willRetryWrite) {\n      // No server returned we had an error\n      return callback(new MongoError('no primary server found'));\n    }\n  }\n  const handler = (err, result) => {\n    if (!err) return callback(null, result);\n    if (!legacyIsRetryableWriteError(err, self)) {\n      err = getMMAPError(err);\n      return callback(err);\n    }\n    if (willRetryWrite) {\n      const newArgs = Object.assign({}, args, {\n        retrying: true\n      });\n      return executeWriteOperation(newArgs, options, callback);\n    }\n\n    // Per SDAM, remove primary from replicaset\n    if (self.s.replicaSetState.primary) {\n      self.s.replicaSetState.primary.destroy();\n      self.s.replicaSetState.remove(self.s.replicaSetState.primary, {\n        force: true\n      });\n    }\n    return callback(err);\n  };\n  if (callback.operationId) {\n    handler.operationId = callback.operationId;\n  }\n\n  // increment and assign txnNumber\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n  self.s.replicaSetState.primary[op](ns, ops, options, handler);\n}\n\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.insert = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'insert',\n    ns,\n    ops\n  }, options, callback);\n};\n\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.update = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'update',\n    ns,\n    ops\n  }, options, callback);\n};\n\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.remove = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'remove',\n    ns,\n    ops\n  }, options, callback);\n};\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\n\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Connection} [options.connection] Specify connection object to execute command against\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.command = function (ns, cmd, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var self = this;\n\n  // Establish readPreference\n  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;\n\n  // If the readPreference is primary and we have no primary, store it\n  if (readPreference.preference === 'primary' && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference === 'secondary' && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference !== 'primary' && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  }\n\n  // Pick a server\n  var server = this.s.replicaSetState.pickServer(readPreference);\n  // We received an error, return it\n  if (!(server instanceof Server)) return callback(server);\n  // Emit debug event\n  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);\n\n  // No server returned we had an error\n  if (server == null) {\n    return callback(new MongoError(f('no server found that matches the provided readPreference %s', readPreference)));\n  }\n  const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self) && !options.session.inTransaction() && isWriteCommand(cmd);\n  const cb = (err, result) => {\n    if (!err) return callback(null, result);\n    if (!legacyIsRetryableWriteError(err, self)) {\n      return callback(err);\n    }\n    if (willRetryWrite) {\n      const newOptions = Object.assign({}, options, {\n        retrying: true\n      });\n      return this.command(ns, cmd, newOptions, callback);\n    }\n\n    // Per SDAM, remove primary from replicaset\n    if (this.s.replicaSetState.primary) {\n      this.s.replicaSetState.primary.destroy();\n      this.s.replicaSetState.remove(this.s.replicaSetState.primary, {\n        force: true\n      });\n    }\n    return callback(err);\n  };\n\n  // increment and assign txnNumber\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n\n  // Execute the command\n  server.command(ns, cmd, options, cb);\n};\n\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\nReplSet.prototype.cursor = function (ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this;\n\n  // Set up final cursor type\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\n\n  // Return the cursor\n  return new FinalCursor(topology, ns, cmd, options);\n};\n\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * A replset reconnect event, used to verify that the topology reconnected\n *\n * @event ReplSet#reconnect\n * @type {ReplSet}\n */\n\n/**\n * A replset fullsetup event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#fullsetup\n * @type {ReplSet}\n */\n\n/**\n * A replset all event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#all\n * @type {ReplSet}\n */\n\n/**\n * A replset failed event, used to signal that initial replset connection failed.\n *\n * @event ReplSet#failed\n * @type {ReplSet}\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event ReplSet#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event ReplSet#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event ReplSet#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event ReplSet#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event ReplSet#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event ReplSet#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatStarted SDAM event\n *\n * @event ReplSet#serverHeartbeatStarted\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatFailed SDAM event\n *\n * @event ReplSet#serverHeartbeatFailed\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatSucceeded SDAM change event\n *\n * @event ReplSet#serverHeartbeatSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event ReplSet#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event ReplSet#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event ReplSet#commandFailed\n * @type {object}\n */\n\nmodule.exports = ReplSet;","map":{"version":3,"names":["inherits","require","f","format","EventEmitter","ReadPreference","CoreCursor","retrieveBSON","Logger","MongoError","Server","ReplSetState","Timeout","Interval","SessionMixins","isRetryableWritesSupported","relayEvents","BSON","getMMAPError","makeClientMetadata","legacyIsRetryableWriteError","now","calculateDurationInMs","DISCONNECTED","CONNECTING","CONNECTED","UNREFERENCED","DESTROYED","stateTransition","self","newState","legalTransitions","disconnected","connecting","connected","unreferenced","destroyed","legalStates","state","indexOf","s","logger","error","id","handlers","ReplSet","seedlist","options","Array","isArray","length","forEach","e","host","port","call","localThresholdMS","acceptableLatency","Object","assign","metadata","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","Cursor","cursorFactory","replicaSetState","setName","heartbeatFrequencyMS","haInterval","connectingServers","minHeartbeatFrequencyMS","disconnectHandler","index","connectOptions","debug","on","r","emit","isWarn","socketTimeout","warn","types","x","t","initialConnectState","connect","fullsetup","all","haTimeoutId","ismaster","intervalIds","clusterTime","prototype","defineProperty","enumerable","get","native","logicalSessionTimeoutMinutes","rexecuteOperations","hasPrimaryAndSecondary","execute","hasPrimary","executePrimary","hasSecondary","executeSecondary","connectNewServers","servers","callback","count","done","_handleEvent","event","err","_self","destroy","force","result","update","lastIsMaster","i","removeAllListeners","handleEvent","monitorServer","me","_server","setTimeout","existingServerIdx","findIndex","name","connectingServer","splice","server","split","parseInt","reconnect","monitoring","parent","once","push","pingServer","cb","start","Date","getTime","emitSDAMEvent","connectionId","command","connectionTimeout","latencyMS","lastUpdateTime","durationMS","failure","remove","lastWrite","lastWriteDate","lastIsMasterMS","reply","updateServerMaxStaleness","__host","_process","_haInterval","intervalId","stop","filter","isRunning","secondaryOnlyConnectionAllowed","process","nextTick","topologyMonitor","keys","set","unknownServers","executeReconnect","monitoringFrequencey","intervalTime","addServerToList","list","toLowerCase","isDebug","shouldTriggerConnect","isConnecting","readPreferenceSecondary","readPreference","equals","secondary","handleInitialConnectEvent","_this","JSON","stringify","connectServers","concat","timeoutInterval","shift","description","listeners","map","topologyId","auth","credentials","destroyCount","serverDestroyed","clearTimeout","unref","allServers","secondaries","primary","connections","isConnected","primaryPreferred","secondaryPreferred","isDestroyed","SERVER_SELECTION_TIMEOUT_MS","SERVER_SELECTION_INTERVAL_MS","selectServer","selector","undefined","lastError","_selectServer","pickServer","getServers","executeWriteOperation","args","op","ns","ops","willRetryWrite","retrying","retryWrites","session","inTransaction","explain","add","handler","newArgs","operationId","incrementTransactionNumber","insert","RETRYABLE_WRITE_OPERATIONS","isWriteCommand","some","cmd","preference","newOptions","cursor","topology","FinalCursor","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/topologies/replset.js"],"sourcesContent":["'use strict';\n\nconst inherits = require('util').inherits;\nconst f = require('util').format;\nconst EventEmitter = require('events').EventEmitter;\nconst ReadPreference = require('./read_preference');\nconst CoreCursor = require('../cursor').CoreCursor;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst Logger = require('../connection/logger');\nconst MongoError = require('../error').MongoError;\nconst Server = require('./server');\nconst ReplSetState = require('./replset_state');\nconst Timeout = require('./shared').Timeout;\nconst Interval = require('./shared').Interval;\nconst SessionMixins = require('./shared').SessionMixins;\nconst isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;\nconst relayEvents = require('../utils').relayEvents;\nconst BSON = retrieveBSON();\nconst getMMAPError = require('./shared').getMMAPError;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst legacyIsRetryableWriteError = require('./shared').legacyIsRetryableWriteError;\nconst now = require('../../utils').now;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\n//\n// States\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar UNREFERENCED = 'unreferenced';\nvar DESTROYED = 'destroyed';\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],\n    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],\n    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],\n    unreferenced: [UNREFERENCED, DESTROYED],\n    destroyed: [DESTROYED]\n  };\n\n  // Get current state\n  var legalStates = legalTransitions[self.state];\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\n    self.state = newState;\n  } else {\n    self.s.logger.error(\n      f(\n        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',\n        self.id,\n        self.state,\n        newState,\n        legalStates\n      )\n    );\n  }\n}\n\n//\n// ReplSet instance id\nvar id = 1;\nvar handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];\n\n/**\n * Creates a new Replset instance\n * @class\n * @param {array} seedlist A list of seeds for the replicaset\n * @param {boolean} options.setName The Replicaset set name\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.bsonRegExp=false] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {ReplSet} A cursor instance\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n * @fires ReplSet#failed\n * @fires ReplSet#fullsetup\n * @fires ReplSet#all\n * @fires ReplSet#error\n * @fires ReplSet#serverHeartbeatStarted\n * @fires ReplSet#serverHeartbeatSucceeded\n * @fires ReplSet#serverHeartbeatFailed\n * @fires ReplSet#topologyOpening\n * @fires ReplSet#topologyClosed\n * @fires ReplSet#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\nvar ReplSet = function(seedlist, options) {\n  var self = this;\n  options = options || {};\n\n  // Validate seedlist\n  if (!Array.isArray(seedlist)) throw new MongoError('seedlist must be an array');\n  // Validate list\n  if (seedlist.length === 0) throw new MongoError('seedlist must contain at least one entry');\n  // Validate entries\n  seedlist.forEach(function(e) {\n    if (typeof e.host !== 'string' || typeof e.port !== 'number')\n      throw new MongoError('seedlist entry must contain a host and port');\n  });\n\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Get replSet Id\n  this.id = id++;\n\n  // Get the localThresholdMS\n  var localThresholdMS = options.localThresholdMS || 15;\n  // Backward compatibility\n  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency;\n\n  // Create a logger\n  var logger = Logger('ReplSet', options);\n\n  // Internal state\n  this.s = {\n    options: Object.assign({ metadata: makeClientMetadata(options) }, options),\n    // BSON instance\n    bson:\n      options.bson ||\n      new BSON([\n        BSON.Binary,\n        BSON.Code,\n        BSON.DBRef,\n        BSON.Decimal128,\n        BSON.Double,\n        BSON.Int32,\n        BSON.Long,\n        BSON.Map,\n        BSON.MaxKey,\n        BSON.MinKey,\n        BSON.ObjectId,\n        BSON.BSONRegExp,\n        BSON.Symbol,\n        BSON.Timestamp\n      ]),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // Logger instance\n    logger: logger,\n    // Seedlist\n    seedlist: seedlist,\n    // Replicaset state\n    replicaSetState: new ReplSetState({\n      id: this.id,\n      setName: options.setName,\n      acceptableLatency: localThresholdMS,\n      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,\n      logger: logger\n    }),\n    // Current servers we are connecting to\n    connectingServers: [],\n    // Ha interval\n    haInterval: options.haInterval ? options.haInterval : 10000,\n    // Minimum heartbeat frequency used if we detect a server close\n    minHeartbeatFrequencyMS: 500,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Server selection index\n    index: 0,\n    // Connect function options passed in\n    connectOptions: {},\n    // Are we running in debug mode\n    debug: typeof options.debug === 'boolean' ? options.debug : false\n  };\n\n  // Add handler for topology change\n  this.s.replicaSetState.on('topologyDescriptionChanged', function(r) {\n    self.emit('topologyDescriptionChanged', r);\n  });\n\n  // Log info warning if the socketTimeout < haInterval as it will cause\n  // a lot of recycled connections to happen.\n  if (\n    this.s.logger.isWarn() &&\n    this.s.options.socketTimeout !== 0 &&\n    this.s.options.socketTimeout < this.s.haInterval\n  ) {\n    this.s.logger.warn(\n      f(\n        'warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts',\n        this.s.options.socketTimeout,\n        this.s.haInterval\n      )\n    );\n  }\n\n  // Add forwarding of events from state handler\n  var types = ['joined', 'left'];\n  types.forEach(function(x) {\n    self.s.replicaSetState.on(x, function(t, s) {\n      self.emit(x, t, s);\n    });\n  });\n\n  // Connect stat\n  this.initialConnectState = {\n    connect: false,\n    fullsetup: false,\n    all: false\n  };\n\n  // Disconnected state\n  this.state = DISCONNECTED;\n  this.haTimeoutId = null;\n  // Last ismaster\n  this.ismaster = null;\n  // Contains the intervalId\n  this.intervalIds = [];\n\n  // Highest clusterTime seen in responses from the current deployment\n  this.clusterTime = null;\n};\n\ninherits(ReplSet, EventEmitter);\nObject.assign(ReplSet.prototype, SessionMixins);\n\nObject.defineProperty(ReplSet.prototype, 'type', {\n  enumerable: true,\n  get: function() {\n    return 'replset';\n  }\n});\n\nObject.defineProperty(ReplSet.prototype, 'parserType', {\n  enumerable: true,\n  get: function() {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\n\nObject.defineProperty(ReplSet.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function() {\n    return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;\n  }\n});\n\nfunction rexecuteOperations(self) {\n  // If we have a primary and a disconnect handler, execute\n  // buffered operations\n  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute();\n  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({ executePrimary: true });\n  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({ executeSecondary: true });\n  }\n}\n\nfunction connectNewServers(self, servers, callback) {\n  // No new servers\n  if (servers.length === 0) {\n    return callback();\n  }\n\n  // Count lefts\n  var count = servers.length;\n  var error = null;\n\n  function done() {\n    count = count - 1;\n    if (count === 0) {\n      callback(error);\n    }\n  }\n\n  // Handle events\n  var _handleEvent = function(self, event) {\n    return function(err) {\n      var _self = this;\n\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        this.destroy({ force: true });\n        return done();\n      }\n\n      if (event === 'connect') {\n        // Update the state\n        var result = self.s.replicaSetState.update(_self);\n        // Update the state with the new server\n        if (result) {\n          // Primary lastIsMaster store it\n          if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {\n            self.ismaster = _self.lastIsMaster();\n          }\n\n          // Remove the handlers\n          for (let i = 0; i < handlers.length; i++) {\n            _self.removeAllListeners(handlers[i]);\n          }\n\n          // Add stable state handlers\n          _self.on('error', handleEvent(self, 'error'));\n          _self.on('close', handleEvent(self, 'close'));\n          _self.on('timeout', handleEvent(self, 'timeout'));\n          _self.on('parseError', handleEvent(self, 'parseError'));\n\n          // Enalbe the monitoring of the new server\n          monitorServer(_self.lastIsMaster().me, self, {});\n\n          // Rexecute any stalled operation\n          rexecuteOperations(self);\n        } else {\n          _self.destroy({ force: true });\n        }\n      } else if (event === 'error') {\n        error = err;\n      }\n\n      // Rexecute any stalled operation\n      rexecuteOperations(self);\n      done();\n    };\n  };\n\n  // Execute method\n  function execute(_server, i) {\n    setTimeout(function() {\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      // remove existing connecting server if it's failed to connect, otherwise\n      // wait for that server to connect\n      const existingServerIdx = self.s.connectingServers.findIndex(s => s.name === _server);\n      if (existingServerIdx >= 0) {\n        const connectingServer = self.s.connectingServers[existingServerIdx];\n        connectingServer.destroy({ force: true });\n\n        self.s.connectingServers.splice(existingServerIdx, 1);\n        return done();\n      }\n\n      // Create a new server instance\n      var server = new Server(\n        Object.assign({}, self.s.options, {\n          host: _server.split(':')[0],\n          port: parseInt(_server.split(':')[1], 10),\n          reconnect: false,\n          monitoring: false,\n          parent: self\n        })\n      );\n\n      // Add temp handlers\n      server.once('connect', _handleEvent(self, 'connect'));\n      server.once('close', _handleEvent(self, 'close'));\n      server.once('timeout', _handleEvent(self, 'timeout'));\n      server.once('error', _handleEvent(self, 'error'));\n      server.once('parseError', _handleEvent(self, 'parseError'));\n\n      // SDAM Monitoring events\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e));\n\n      // Command Monitoring events\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n      self.s.connectingServers.push(server);\n      server.connect(self.s.connectOptions);\n    }, i);\n  }\n\n  // Create new instances\n  for (var i = 0; i < servers.length; i++) {\n    execute(servers[i], i);\n  }\n}\n\n// Ping the server\nvar pingServer = function(self, server, cb) {\n  // Measure running time\n  var start = new Date().getTime();\n\n  // Emit the server heartbeat start\n  emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: server.name });\n\n  // Execute ismaster\n  // Set the socketTimeout for a monitoring message to a low number\n  // Ensuring ismaster calls are timed out quickly\n  server.command(\n    'admin.$cmd',\n    {\n      ismaster: true\n    },\n    {\n      monitoring: true,\n      socketTimeout: self.s.options.connectionTimeout || 2000\n    },\n    function(err, r) {\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        server.destroy({ force: true });\n        return cb(err, r);\n      }\n\n      // Calculate latency\n      var latencyMS = new Date().getTime() - start;\n\n      // Set the last updatedTime\n      server.lastUpdateTime = now();\n\n      // We had an error, remove it from the state\n      if (err) {\n        // Emit the server heartbeat failure\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: server.name\n        });\n\n        // Remove server from the state\n        self.s.replicaSetState.remove(server);\n      } else {\n        // Update the server ismaster\n        server.ismaster = r.result;\n\n        // Check if we have a lastWriteDate convert it to MS\n        // and store on the server instance for later use\n        if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {\n          server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();\n        }\n\n        // Do we have a brand new server\n        if (server.lastIsMasterMS === -1) {\n          server.lastIsMasterMS = latencyMS;\n        } else if (server.lastIsMasterMS) {\n          // After the first measurement, average RTT MUST be computed using an\n          // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.\n          // If the prior average is denoted old_rtt, then the new average (new_rtt) is\n          // computed from a new RTT measurement (x) using the following formula:\n          // alpha = 0.2\n          // new_rtt = alpha * x + (1 - alpha) * old_rtt\n          server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;\n        }\n\n        if (self.s.replicaSetState.update(server)) {\n          // Primary lastIsMaster store it\n          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n            self.ismaster = server.lastIsMaster();\n          }\n        }\n\n        // Server heart beat event\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: server.name\n        });\n      }\n\n      // Calculate the staleness for this server\n      self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval);\n\n      // Callback\n      cb(err, r);\n    }\n  );\n};\n\n// Each server is monitored in parallel in their own timeout loop\nvar monitorServer = function(host, self, options) {\n  // If this is not the initial scan\n  // Is this server already being monitoried, then skip monitoring\n  if (!options.haInterval) {\n    for (var i = 0; i < self.intervalIds.length; i++) {\n      if (self.intervalIds[i].__host === host) {\n        return;\n      }\n    }\n  }\n\n  // Get the haInterval\n  var _process = options.haInterval ? Timeout : Interval;\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  // Create the interval\n  var intervalId = new _process(function() {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      // clearInterval(intervalId);\n      intervalId.stop();\n      return;\n    }\n\n    // Do we already have server connection available for this host\n    var _server = self.s.replicaSetState.get(host);\n\n    // Check if we have a known server connection and reuse\n    if (_server) {\n      // Ping the server\n      return pingServer(self, _server, function(err) {\n        if (err) {\n          // NOTE: should something happen here?\n          return;\n        }\n\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\n          intervalId.stop();\n          return;\n        }\n\n        // Filter out all called intervaliIds\n        self.intervalIds = self.intervalIds.filter(function(intervalId) {\n          return intervalId.isRunning();\n        });\n\n        // Initial sweep\n        if (_process === Timeout) {\n          if (\n            self.state === CONNECTING &&\n            ((self.s.replicaSetState.hasSecondary() &&\n              self.s.options.secondaryOnlyConnectionAllowed) ||\n              self.s.replicaSetState.hasPrimary())\n          ) {\n            stateTransition(self, CONNECTED);\n\n            // Emit connected sign\n            process.nextTick(function() {\n              self.emit('connect', self);\n            });\n\n            // Start topology interval check\n            topologyMonitor(self, {});\n          }\n        } else {\n          if (\n            self.state === DISCONNECTED &&\n            ((self.s.replicaSetState.hasSecondary() &&\n              self.s.options.secondaryOnlyConnectionAllowed) ||\n              self.s.replicaSetState.hasPrimary())\n          ) {\n            stateTransition(self, CONNECTING);\n\n            // Rexecute any stalled operation\n            rexecuteOperations(self);\n\n            // Emit connected sign\n            process.nextTick(function() {\n              self.emit('reconnect', self);\n            });\n          }\n        }\n\n        if (\n          self.initialConnectState.connect &&\n          !self.initialConnectState.fullsetup &&\n          self.s.replicaSetState.hasPrimaryAndSecondary()\n        ) {\n          // Set initial connect state\n          self.initialConnectState.fullsetup = true;\n          self.initialConnectState.all = true;\n\n          process.nextTick(function() {\n            self.emit('fullsetup', self);\n            self.emit('all', self);\n          });\n        }\n      });\n    }\n  }, _haInterval);\n\n  // Start the interval\n  intervalId.start();\n  // Add the intervalId host name\n  intervalId.__host = host;\n  // Add the intervalId to our list of intervalIds\n  self.intervalIds.push(intervalId);\n};\n\nfunction topologyMonitor(self, options) {\n  if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n  options = options || {};\n\n  // Get the servers\n  var servers = Object.keys(self.s.replicaSetState.set);\n\n  // Get the haInterval\n  var _process = options.haInterval ? Timeout : Interval;\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  if (_process === Timeout) {\n    return connectNewServers(self, self.s.replicaSetState.unknownServers, function(err) {\n      // Don't emit errors if the connection was already\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit(\n          'error',\n          new MongoError('no primary found in replicaset or invalid replica set name')\n        );\n        return self.destroy({ force: true });\n      } else if (\n        !self.s.replicaSetState.hasSecondary() &&\n        self.s.options.secondaryOnlyConnectionAllowed\n      ) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit(\n          'error',\n          new MongoError('no secondary found in replicaset or invalid replica set name')\n        );\n        return self.destroy({ force: true });\n      }\n\n      for (var i = 0; i < servers.length; i++) {\n        monitorServer(servers[i], self, options);\n      }\n    });\n  } else {\n    for (var i = 0; i < servers.length; i++) {\n      monitorServer(servers[i], self, options);\n    }\n  }\n\n  // Run the reconnect process\n  function executeReconnect(self) {\n    return function() {\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      connectNewServers(self, self.s.replicaSetState.unknownServers, function() {\n        var monitoringFrequencey = self.s.replicaSetState.hasPrimary()\n          ? _haInterval\n          : self.s.minHeartbeatFrequencyMS;\n\n        // Create a timeout\n        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());\n      });\n    };\n  }\n\n  // Decide what kind of interval to use\n  var intervalTime = !self.s.replicaSetState.hasPrimary()\n    ? self.s.minHeartbeatFrequencyMS\n    : _haInterval;\n\n  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());\n}\n\nfunction addServerToList(list, server) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n\n  list.push(server);\n}\n\nfunction handleEvent(self, event) {\n  return function() {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n    // Debug log\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(\n        f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id)\n      );\n    }\n\n    // Remove from the replicaset state\n    self.s.replicaSetState.remove(this);\n\n    // Are we in a destroyed state return\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n\n    // If no primary and secondary available\n    if (\n      !self.s.replicaSetState.hasPrimary() &&\n      !self.s.replicaSetState.hasSecondary() &&\n      self.s.options.secondaryOnlyConnectionAllowed\n    ) {\n      stateTransition(self, DISCONNECTED);\n    } else if (!self.s.replicaSetState.hasPrimary()) {\n      stateTransition(self, DISCONNECTED);\n    }\n\n    addServerToList(self.s.connectingServers, this);\n  };\n}\n\nfunction shouldTriggerConnect(self) {\n  const isConnecting = self.state === CONNECTING;\n  const hasPrimary = self.s.replicaSetState.hasPrimary();\n  const hasSecondary = self.s.replicaSetState.hasSecondary();\n  const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;\n  const readPreferenceSecondary =\n    self.s.connectOptions.readPreference &&\n    self.s.connectOptions.readPreference.equals(ReadPreference.secondary);\n\n  return (\n    (isConnecting &&\n      ((readPreferenceSecondary && hasSecondary) || (!readPreferenceSecondary && hasPrimary))) ||\n    (hasSecondary && secondaryOnlyConnectionAllowed)\n  );\n}\n\nfunction handleInitialConnectEvent(self, event) {\n  return function() {\n    var _this = this;\n    // Debug log\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(\n        f(\n          'handleInitialConnectEvent %s from server %s in replset with id %s',\n          event,\n          this.name,\n          self.id\n        )\n      );\n    }\n\n    // Destroy the instance\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      return this.destroy({ force: true });\n    }\n\n    // Check the type of server\n    if (event === 'connect') {\n      // Update the state\n      var result = self.s.replicaSetState.update(_this);\n      if (result === true) {\n        // Primary lastIsMaster store it\n        if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {\n          self.ismaster = _this.lastIsMaster();\n        }\n\n        // Debug log\n        if (self.s.logger.isDebug()) {\n          self.s.logger.debug(\n            f(\n              'handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]',\n              event,\n              _this.name,\n              self.id,\n              JSON.stringify(self.s.replicaSetState.set)\n            )\n          );\n        }\n\n        // Remove the handlers\n        for (let i = 0; i < handlers.length; i++) {\n          _this.removeAllListeners(handlers[i]);\n        }\n\n        // Add stable state handlers\n        _this.on('error', handleEvent(self, 'error'));\n        _this.on('close', handleEvent(self, 'close'));\n        _this.on('timeout', handleEvent(self, 'timeout'));\n        _this.on('parseError', handleEvent(self, 'parseError'));\n\n        // Do we have a primary or primaryAndSecondary\n        if (shouldTriggerConnect(self)) {\n          // We are connected\n          stateTransition(self, CONNECTED);\n\n          // Set initial connect state\n          self.initialConnectState.connect = true;\n          // Emit connect event\n          process.nextTick(function() {\n            self.emit('connect', self);\n          });\n\n          topologyMonitor(self, {});\n        }\n      } else if (result instanceof MongoError) {\n        _this.destroy({ force: true });\n        self.destroy({ force: true });\n        return self.emit('error', result);\n      } else {\n        _this.destroy({ force: true });\n      }\n    } else {\n      // Emit failure to connect\n      self.emit('failed', this);\n\n      addServerToList(self.s.connectingServers, this);\n      // Remove from the state\n      self.s.replicaSetState.remove(this);\n    }\n\n    if (\n      self.initialConnectState.connect &&\n      !self.initialConnectState.fullsetup &&\n      self.s.replicaSetState.hasPrimaryAndSecondary()\n    ) {\n      // Set initial connect state\n      self.initialConnectState.fullsetup = true;\n      self.initialConnectState.all = true;\n\n      process.nextTick(function() {\n        self.emit('fullsetup', self);\n        self.emit('all', self);\n      });\n    }\n\n    // Remove from the list from connectingServers\n    for (var i = 0; i < self.s.connectingServers.length; i++) {\n      if (self.s.connectingServers[i].equals(this)) {\n        self.s.connectingServers.splice(i, 1);\n      }\n    }\n\n    // Trigger topologyMonitor\n    if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {\n      topologyMonitor(self, { haInterval: 1 });\n    }\n  };\n}\n\nfunction connectServers(self, servers) {\n  // Update connectingServers\n  self.s.connectingServers = self.s.connectingServers.concat(servers);\n\n  // Index used to interleaf the server connects, avoiding\n  // runtime issues on io constrained vm's\n  var timeoutInterval = 0;\n\n  function connect(server, timeoutInterval) {\n    setTimeout(function() {\n      // Add the server to the state\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      }\n\n      // Add event handlers\n      server.once('close', handleInitialConnectEvent(self, 'close'));\n      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));\n      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));\n      server.once('error', handleInitialConnectEvent(self, 'error'));\n      server.once('connect', handleInitialConnectEvent(self, 'connect'));\n\n      // SDAM Monitoring events\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e));\n\n      // Command Monitoring events\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n      // Start connection\n      server.connect(self.s.connectOptions);\n    }, timeoutInterval);\n  }\n\n  // Start all the servers\n  while (servers.length > 0) {\n    connect(servers.shift(), timeoutInterval++);\n  }\n}\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\n/**\n * Initiate server connect\n */\nReplSet.prototype.connect = function(options) {\n  var self = this;\n  // Add any connect level options to the internal state\n  this.s.connectOptions = options || {};\n\n  // Set connecting state\n  stateTransition(this, CONNECTING);\n\n  // Create server instances\n  var servers = this.s.seedlist.map(function(x) {\n    return new Server(\n      Object.assign({}, self.s.options, x, options, {\n        reconnect: false,\n        monitoring: false,\n        parent: self\n      })\n    );\n  });\n\n  // Error out as high availability interval must be < than socketTimeout\n  if (\n    this.s.options.socketTimeout > 0 &&\n    this.s.options.socketTimeout <= this.s.options.haInterval\n  ) {\n    return self.emit(\n      'error',\n      new MongoError(\n        f(\n          'haInterval [%s] MS must be set to less than socketTimeout [%s] MS',\n          this.s.options.haInterval,\n          this.s.options.socketTimeout\n        )\n      )\n    );\n  }\n\n  // Emit the topology opening event\n  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });\n  // Start all server connections\n  connectServers(self, servers);\n};\n\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\nReplSet.prototype.auth = function(credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Destroy the server connection\n * @param {boolean} [options.force=false] Force destroy the pool\n * @method\n */\nReplSet.prototype.destroy = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  let destroyCount = this.s.connectingServers.length + 1; // +1 for the callback from `replicaSetState.destroy`\n  const serverDestroyed = () => {\n    destroyCount--;\n    if (destroyCount > 0) {\n      return;\n    }\n\n    // Emit toplogy closing event\n    emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n\n  if (this.state === DESTROYED) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  // Transition state\n  stateTransition(this, DESTROYED);\n\n  // Clear out any monitoring process\n  if (this.haTimeoutId) clearTimeout(this.haTimeoutId);\n\n  // Clear out all monitoring\n  for (var i = 0; i < this.intervalIds.length; i++) {\n    this.intervalIds[i].stop();\n  }\n\n  // Reset list of intervalIds\n  this.intervalIds = [];\n\n  if (destroyCount === 0) {\n    serverDestroyed();\n    return;\n  }\n\n  // Destroy the replicaset\n  this.s.replicaSetState.destroy(options, serverDestroyed);\n\n  // Destroy all connecting servers\n  this.s.connectingServers.forEach(function(x) {\n    x.destroy(options, serverDestroyed);\n  });\n};\n\n/**\n * Unref all connections belong to this server\n * @method\n */\nReplSet.prototype.unref = function() {\n  // Transition state\n  stateTransition(this, UNREFERENCED);\n\n  this.s.replicaSetState.allServers().forEach(function(x) {\n    x.unref();\n  });\n\n  clearTimeout(this.haTimeoutId);\n};\n\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\nReplSet.prototype.lastIsMaster = function() {\n  // If secondaryOnlyConnectionAllowed and no primary but secondary\n  // return the secondaries ismaster result.\n  if (\n    this.s.options.secondaryOnlyConnectionAllowed &&\n    !this.s.replicaSetState.hasPrimary() &&\n    this.s.replicaSetState.hasSecondary()\n  ) {\n    return this.s.replicaSetState.secondaries[0].lastIsMaster();\n  }\n\n  return this.s.replicaSetState.primary\n    ? this.s.replicaSetState.primary.lastIsMaster()\n    : this.ismaster;\n};\n\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\nReplSet.prototype.connections = function() {\n  var servers = this.s.replicaSetState.allServers();\n  var connections = [];\n  for (var i = 0; i < servers.length; i++) {\n    connections = connections.concat(servers[i].connections());\n  }\n\n  return connections;\n};\n\n/**\n * Figure out if the server is connected\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {boolean}\n */\nReplSet.prototype.isConnected = function(options) {\n  options = options || {};\n\n  // If we specified a read preference check if we are connected to something\n  // than can satisfy this\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\n    return this.s.replicaSetState.hasSecondary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\n    return this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {\n    return true;\n  }\n\n  return this.s.replicaSetState.hasPrimary();\n};\n\n/**\n * Figure out if the replicaset instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\nReplSet.prototype.isDestroyed = function() {\n  return this.state === DESTROYED;\n};\n\nconst SERVER_SELECTION_TIMEOUT_MS = 10000; // hardcoded `serverSelectionTimeoutMS` for legacy topology\nconst SERVER_SELECTION_INTERVAL_MS = 1000; // time to wait between selection attempts\n/**\n * Selects a server\n *\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {ClientSession} [options.session] Unused\n * @param {function} callback\n */\nReplSet.prototype.selectServer = function(selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined')\n    (callback = selector), (selector = undefined), (options = {});\n  if (typeof options === 'function') (callback = options), (options = selector);\n  options = options || {};\n\n  let readPreference;\n  if (selector instanceof ReadPreference) {\n    readPreference = selector;\n  } else {\n    readPreference = options.readPreference || ReadPreference.primary;\n  }\n\n  let lastError;\n  const start = now();\n  const _selectServer = () => {\n    if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {\n      if (lastError != null) {\n        callback(lastError, null);\n      } else {\n        callback(new MongoError('Server selection timed out'));\n      }\n\n      return;\n    }\n\n    const server = this.s.replicaSetState.pickServer(readPreference);\n    if (server == null) {\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (!(server instanceof Server)) {\n      lastError = server;\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (this.s.debug) this.emit('pickedServer', options.readPreference, server);\n    callback(null, server);\n  };\n\n  _selectServer();\n};\n\n/**\n * Get all connected servers\n * @method\n * @return {Server[]}\n */\nReplSet.prototype.getServers = function() {\n  return this.s.replicaSetState.allServers();\n};\n\n//\n// Execute write operation\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const self = args.self;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n\n  if (self.state === DESTROYED) {\n    return callback(new MongoError(f('topology was destroyed')));\n  }\n\n  const willRetryWrite =\n    !args.retrying &&\n    !!options.retryWrites &&\n    options.session &&\n    isRetryableWritesSupported(self) &&\n    !options.session.inTransaction() &&\n    options.explain === undefined;\n\n  if (!self.s.replicaSetState.hasPrimary()) {\n    if (self.s.disconnectHandler) {\n      // Not connected but we have a disconnecthandler\n      return self.s.disconnectHandler.add(op, ns, ops, options, callback);\n    } else if (!willRetryWrite) {\n      // No server returned we had an error\n      return callback(new MongoError('no primary server found'));\n    }\n  }\n\n  const handler = (err, result) => {\n    if (!err) return callback(null, result);\n    if (!legacyIsRetryableWriteError(err, self)) {\n      err = getMMAPError(err);\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newArgs = Object.assign({}, args, { retrying: true });\n      return executeWriteOperation(newArgs, options, callback);\n    }\n\n    // Per SDAM, remove primary from replicaset\n    if (self.s.replicaSetState.primary) {\n      self.s.replicaSetState.primary.destroy();\n      self.s.replicaSetState.remove(self.s.replicaSetState.primary, { force: true });\n    }\n\n    return callback(err);\n  };\n\n  if (callback.operationId) {\n    handler.operationId = callback.operationId;\n  }\n\n  // increment and assign txnNumber\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n\n  self.s.replicaSetState.primary[op](ns, ops, options, handler);\n}\n\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.insert = function(ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({ self: this, op: 'insert', ns, ops }, options, callback);\n};\n\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.update = function(ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({ self: this, op: 'update', ns, ops }, options, callback);\n};\n\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.remove = function(ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({ self: this, op: 'remove', ns, ops }, options, callback);\n};\n\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\n\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\n\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Connection} [options.connection] Specify connection object to execute command against\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.command = function(ns, cmd, options, callback) {\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var self = this;\n\n  // Establish readPreference\n  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;\n\n  // If the readPreference is primary and we have no primary, store it\n  if (\n    readPreference.preference === 'primary' &&\n    !this.s.replicaSetState.hasPrimary() &&\n    this.s.disconnectHandler != null\n  ) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (\n    readPreference.preference === 'secondary' &&\n    !this.s.replicaSetState.hasSecondary() &&\n    this.s.disconnectHandler != null\n  ) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (\n    readPreference.preference !== 'primary' &&\n    !this.s.replicaSetState.hasSecondary() &&\n    !this.s.replicaSetState.hasPrimary() &&\n    this.s.disconnectHandler != null\n  ) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  }\n\n  // Pick a server\n  var server = this.s.replicaSetState.pickServer(readPreference);\n  // We received an error, return it\n  if (!(server instanceof Server)) return callback(server);\n  // Emit debug event\n  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);\n\n  // No server returned we had an error\n  if (server == null) {\n    return callback(\n      new MongoError(\n        f('no server found that matches the provided readPreference %s', readPreference)\n      )\n    );\n  }\n\n  const willRetryWrite =\n    !options.retrying &&\n    !!options.retryWrites &&\n    options.session &&\n    isRetryableWritesSupported(self) &&\n    !options.session.inTransaction() &&\n    isWriteCommand(cmd);\n\n  const cb = (err, result) => {\n    if (!err) return callback(null, result);\n    if (!legacyIsRetryableWriteError(err, self)) {\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newOptions = Object.assign({}, options, { retrying: true });\n      return this.command(ns, cmd, newOptions, callback);\n    }\n\n    // Per SDAM, remove primary from replicaset\n    if (this.s.replicaSetState.primary) {\n      this.s.replicaSetState.primary.destroy();\n      this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });\n    }\n\n    return callback(err);\n  };\n\n  // increment and assign txnNumber\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n\n  // Execute the command\n  server.command(ns, cmd, options, cb);\n};\n\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\nReplSet.prototype.cursor = function(ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this;\n\n  // Set up final cursor type\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\n\n  // Return the cursor\n  return new FinalCursor(topology, ns, cmd, options);\n};\n\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * A replset reconnect event, used to verify that the topology reconnected\n *\n * @event ReplSet#reconnect\n * @type {ReplSet}\n */\n\n/**\n * A replset fullsetup event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#fullsetup\n * @type {ReplSet}\n */\n\n/**\n * A replset all event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#all\n * @type {ReplSet}\n */\n\n/**\n * A replset failed event, used to signal that initial replset connection failed.\n *\n * @event ReplSet#failed\n * @type {ReplSet}\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event ReplSet#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event ReplSet#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event ReplSet#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event ReplSet#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event ReplSet#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event ReplSet#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatStarted SDAM event\n *\n * @event ReplSet#serverHeartbeatStarted\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatFailed SDAM event\n *\n * @event ReplSet#serverHeartbeatFailed\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatSucceeded SDAM change event\n *\n * @event ReplSet#serverHeartbeatSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event ReplSet#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event ReplSet#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event ReplSet#commandFailed\n * @type {object}\n */\n\nmodule.exports = ReplSet;\n"],"mappings":"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,aAAa,IAAI,IAAI,CAACrC,CAAC,CAACoC,MAAM;;EAExD;EACA,OAAO,IAAIsL,WAAW,CAACD,QAAQ,EAAErB,EAAE,EAAEiB,GAAG,EAAE9M,OAAO,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEAoN,MAAM,CAACC,OAAO,GAAGvN,OAAO"},"metadata":{},"sourceType":"script"}