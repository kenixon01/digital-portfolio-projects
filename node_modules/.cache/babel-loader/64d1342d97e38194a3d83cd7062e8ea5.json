{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\nconst Buffer = require('safe-buffer').Buffer;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst MongoError = require('../error').MongoError;\nconst AuthProvider = require('./auth_provider').AuthProvider;\nconst emitWarningOnce = require('../../utils').emitWarning;\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nlet saslprep;\ntry {\n  // Ensure you always wrap an optional require in the try block NODE-3199\n  saslprep = require('saslprep');\n} catch (e) {\n  // don't do anything;\n}\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      emitWarningOnce('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      }\n\n      // store the nonce for later use\n      Object.assign(authContext, {\n        nonce\n      });\n      const credentials = authContext.credentials;\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n  auth(authContext, callback) {\n    const response = authContext.response;\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n}\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256';\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n  const payload = Buffer.isBuffer(response.payload) ? new Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value().toString('base64'), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n    const r = result.result;\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\n  });\n}\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n  return dict;\n}\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n  const length = Math.max(a.length, b.length);\n  const res = [];\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n  return result === 0;\n}\nfunction resolveError(err, result) {\n  if (err) return err;\n  const r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n}\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n}\nmodule.exports = {\n  ScramSHA1,\n  ScramSHA256\n};","map":{"version":3,"names":["crypto","require","Buffer","retrieveBSON","MongoError","AuthProvider","emitWarningOnce","emitWarning","BSON","Binary","saslprep","e","ScramSHA","constructor","bson","cryptoMethod","prepare","handshakeDoc","authContext","callback","randomBytes","err","nonce","Object","assign","credentials","request","speculativeAuthenticate","makeFirstMessage","db","source","undefined","auth","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","concat","from","toString","mechanism","saslStart","payload","autoAuthorize","options","skipEmptyExchange","connection","saslStartCmd","command","_err","result","resolveError","password","processedPassword","passwordDigest","isBuffer","dict","parsePayload","value","iterations","parseInt","i","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","$err","errmsg","ScramSHA1","ScramSHA256","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/auth/scram.js"],"sourcesContent":["'use strict';\nconst crypto = require('crypto');\nconst Buffer = require('safe-buffer').Buffer;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst MongoError = require('../error').MongoError;\nconst AuthProvider = require('./auth_provider').AuthProvider;\nconst emitWarningOnce = require('../../utils').emitWarning;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\n\nlet saslprep;\ntry {\n  // Ensure you always wrap an optional require in the try block NODE-3199\n  saslprep = require('saslprep');\n} catch (e) {\n  // don't do anything;\n}\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      emitWarningOnce('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      }\n\n      // store the nonce for later use\n      Object.assign(authContext, { nonce });\n\n      const credentials = authContext.credentials;\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(\n        this.cryptoMethod,\n        response.speculativeAuthenticate,\n        authContext,\n        callback\n      );\n\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([\n    Buffer.from('n=', 'utf8'),\n    Buffer.from(username, 'utf8'),\n    Buffer.from(',r=', 'utf8'),\n    Buffer.from(nonce.toString('base64'), 'utf8')\n  ]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256';\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\n    ),\n    autoAuthorize: 1,\n    options: { skipEmptyExchange: true }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload)\n    ? new Binary(response.payload)\n    : response.payload;\n  const dict = parsePayload(payload.value());\n\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(\n    processedPassword,\n    Buffer.from(salt, 'base64'),\n    iterations,\n    cryptoMethod\n  );\n\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [\n    clientFirstMessageBare(username, nonce),\n    payload.value().toString('base64'),\n    withoutProof\n  ].join(',');\n\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    const r = result.result;\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto\n    .createHash(method)\n    .update(text)\n    .digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto\n    .createHmac(method, key)\n    .update(text)\n    .digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n\n  const r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n}\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n}\n\nmodule.exports = { ScramSHA1, ScramSHA256 };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}