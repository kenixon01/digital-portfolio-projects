{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst ServerDescription = require('./server_description').ServerDescription;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst TopologyType = require('./common').TopologyType;\n\n// contstants related to compatability checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\n// Representation of a deployment of servers\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    options = options || {};\n\n    // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null;\n\n    // save this locally, but don't display when printing the instance out\n    Object.defineProperty(this, 'options', {\n      value: options,\n      enumberable: false\n    });\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = null;\n    for (const addressServerTuple of this.servers) {\n      const server = addressServerTuple[1];\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   *\n   * @param {ServerDescription} serverDescription\n   */\n  update(serverDescription) {\n    const address = serverDescription.address;\n    // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n\n    // potentially mutated values\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new ServerDescription(address, null);\n    }\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n    }\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        topologyType = result[0], setName = result[1];\n      }\n    }\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n  }\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n    return undefined;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerType.Unknown);\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   *\n   * @param {String} address\n   * @return {Boolean} Whether the topology knows about this server\n   */\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n}\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Standalone) {\n    return TopologyType.Single;\n  }\n  if (serverType === ServerType.Mongos) {\n    return TopologyType.Sharded;\n  }\n  if (serverType === ServerType.RSPrimary) {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n  if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {\n    return TopologyType.Unknown;\n  }\n  return TopologyType.ReplicaSetNoPrimary;\n}\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n  if (oid2 == null) {\n    return 1;\n  }\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\nfunction updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n    maxElectionId = serverDescription.electionId;\n  }\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n  return checkHasPrimary(serverDescriptions);\n}\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n  return [topologyType, setName];\n}\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n  return TopologyType.ReplicaSetNoPrimary;\n}\nmodule.exports = {\n  TopologyDescription\n};","map":{"version":3,"names":["ServerType","require","ServerDescription","WIRE_CONSTANTS","TopologyType","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","TopologyDescription","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","type","Unknown","servers","Map","stale","compatible","compatibilityError","logicalSessionTimeoutMinutes","heartbeatFrequencyMS","localThresholdMS","Object","defineProperty","value","enumberable","serverDescription","values","minWireVersion","address","maxWireVersion","addressServerTuple","server","isReadable","Math","min","updateFromSrvPollingEvent","ev","newAddresses","addresses","has","delete","size","set","update","serverType","Single","Standalone","topologyTypeForServerType","Sharded","Mongos","indexOf","ReplicaSetNoPrimary","RSPrimary","result","updateRsFromPrimary","RSSecondary","RSArbiter","RSOther","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","error","descriptionsWithError","Array","from","filter","sd","length","undefined","hasKnownServers","some","hasDataBearingServers","isDataBearing","hasServer","RSGhost","compareObjectId","oid1","oid2","id","Buffer","oid1Buffer","oid2Buffer","compare","oid1String","toString","oid2String","localeCompare","electionId","setVersion","keys","get","allHosts","forEach","currentAddresses","responseAddresses","addr","TypeError","me","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/sdam/topology_description.js"],"sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst ServerDescription = require('./server_description').ServerDescription;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst TopologyType = require('./common').TopologyType;\n\n// contstants related to compatability checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\n// Representation of a deployment of servers\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  constructor(\n    topologyType,\n    serverDescriptions,\n    setName,\n    maxSetVersion,\n    maxElectionId,\n    commonWireVersion,\n    options\n  ) {\n    options = options || {};\n\n    // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null;\n\n    // save this locally, but don't display when printing the instance out\n    Object.defineProperty(this, 'options', { value: options, enumberable: false });\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = null;\n    for (const addressServerTuple of this.servers) {\n      const server = addressServerTuple[1];\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(\n          this.logicalSessionTimeoutMinutes,\n          server.logicalSessionTimeoutMinutes\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      this.options,\n      null\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   *\n   * @param {ServerDescription} serverDescription\n   */\n  update(serverDescription) {\n    const address = serverDescription.address;\n    // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n\n    // potentially mutated values\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new ServerDescription(address, null);\n    }\n\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        this.options\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        (topologyType = result[0]), (setName = result[1]);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          setName,\n          serverDescription\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      this.options\n    );\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n    return undefined;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerType.Unknown);\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   *\n   * @param {String} address\n   * @return {Boolean} Whether the topology knows about this server\n   */\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n}\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Standalone) {\n    return TopologyType.Single;\n  }\n\n  if (serverType === ServerType.Mongos) {\n    return TopologyType.Sharded;\n  }\n\n  if (serverType === ServerType.RSPrimary) {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {\n    return TopologyType.Unknown;\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions,\n  setName,\n  serverDescription,\n  maxSetVersion,\n  maxElectionId\n) {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (\n        maxSetVersion > serverDescription.setVersion ||\n        compareObjectId(maxElectionId, electionId) > 0\n      ) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(\n          serverDescription.address,\n          new ServerDescription(serverDescription.address)\n        );\n\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (\n    serverDescription.setVersion != null &&\n    (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n  ) {\n    maxSetVersion = serverDescription.setVersion;\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter(addr => responseAddresses.indexOf(addr) === -1)\n    .forEach(address => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}