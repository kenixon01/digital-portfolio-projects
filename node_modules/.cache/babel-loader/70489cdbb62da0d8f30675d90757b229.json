{"ast":null,"code":"'use strict';\n\nconst Logger = require('./connection/logger');\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\nconst MongoError = require('./error').MongoError;\nconst MongoNetworkError = require('./error').MongoNetworkError;\nconst collationNotSupported = require('./utils').collationNotSupported;\nconst ReadPreference = require('./topologies/read_preference');\nconst isUnifiedTopology = require('./utils').isUnifiedTopology;\nconst executeOperation = require('../operations/execute_operation');\nconst Readable = require('stream').Readable;\nconst SUPPORTS = require('../utils').SUPPORTS;\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\nconst mergeOptions = require('../utils').mergeOptions;\nconst OperationBase = require('../operations/operation').OperationBase;\nconst BSON = retrieveBSON();\nconst Long = BSON.Long;\n\n// Possible states for a cursor\nconst CursorState = {\n  INIT: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  GET_MORE: 3\n};\n\n//\n// Handle callback (including any exceptions thrown)\nfunction handleCallback(callback, err, result) {\n  try {\n    callback(err, result);\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n  }\n}\n\n/**\n * This is a cursor results callback\n *\n * @callback resultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {object} document\n */\n\n/**\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query.\n *\n * **CURSORS Cannot directly be instantiated**\n */\n\n/**\n * The core cursor class. All cursors in the driver build off of this one.\n *\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\n * @property {number} cursorLimit The current cursorLimit for the cursor\n * @property {number} cursorSkip The current cursorSkip for the cursor\n */\nclass CoreCursor extends Readable {\n  /**\n   * Create a new core `Cursor` instance.\n   * **NOTE** Not to be instantiated directly\n   *\n   * @param {object} topology The server topology instance.\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\n   * @param {object} [options=null] Optional settings.\n   * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n   * @param {array} [options.documents=[]] Initial documents list for cursor\n   * @param {object} [options.transforms=null] Transform methods for the cursor results\n   * @param {function} [options.transforms.query] Transform the value returned from the initial query\n   * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next\n   */\n  constructor(topology, ns, cmd, options) {\n    super({\n      objectMode: true\n    });\n    options = options || {};\n    if (ns instanceof OperationBase) {\n      this.operation = ns;\n      ns = this.operation.ns.toString();\n      options = this.operation.options;\n      cmd = this.operation.cmd ? this.operation.cmd : {};\n    }\n\n    // Cursor pool\n    this.pool = null;\n    // Cursor server\n    this.server = null;\n\n    // Do we have a not connected handler\n    this.disconnectHandler = options.disconnectHandler;\n\n    // Set local values\n    this.bson = topology.s.bson;\n    this.ns = ns;\n    this.namespace = MongoDBNamespace.fromString(ns);\n    this.cmd = cmd;\n    this.options = options;\n    this.topology = topology;\n\n    // All internal state\n    this.cursorState = {\n      cursorId: null,\n      cmd,\n      documents: options.documents || [],\n      cursorIndex: 0,\n      dead: false,\n      killed: false,\n      init: false,\n      notified: false,\n      limit: options.limit || cmd.limit || 0,\n      skip: options.skip || cmd.skip || 0,\n      batchSize: options.batchSize || cmd.batchSize || 1000,\n      currentLimit: 0,\n      // Result field name if not a cursor (contains the array of results)\n      transforms: options.transforms,\n      raw: options.raw || cmd && cmd.raw\n    };\n    if (typeof options.session === 'object') {\n      this.cursorState.session = options.session;\n    }\n\n    // Add promoteLong to cursor state\n    const topologyOptions = topology.s.options;\n    if (typeof topologyOptions.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = topologyOptions.promoteLongs;\n    } else if (typeof options.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = options.promoteLongs;\n    }\n\n    // Add promoteValues to cursor state\n    if (typeof topologyOptions.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = topologyOptions.promoteValues;\n    } else if (typeof options.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = options.promoteValues;\n    }\n\n    // Add promoteBuffers to cursor state\n    if (typeof topologyOptions.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;\n    } else if (typeof options.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = options.promoteBuffers;\n    }\n\n    // Add bsonRegExp to cursor state\n    if (typeof topologyOptions.bsonRegExp === 'boolean') {\n      this.cursorState.bsonRegExp = topologyOptions.bsonRegExp;\n    } else if (typeof options.bsonRegExp === 'boolean') {\n      this.cursorState.bsonRegExp = options.bsonRegExp;\n    }\n    if (topologyOptions.reconnect) {\n      this.cursorState.reconnect = topologyOptions.reconnect;\n    }\n\n    // Logger\n    this.logger = Logger('Cursor', topologyOptions);\n\n    //\n    // Did we pass in a cursor id\n    if (typeof cmd === 'number') {\n      this.cursorState.cursorId = Long.fromNumber(cmd);\n      this.cursorState.lastCursorId = this.cursorState.cursorId;\n    } else if (cmd instanceof Long) {\n      this.cursorState.cursorId = cmd;\n      this.cursorState.lastCursorId = cmd;\n    }\n\n    // TODO: remove as part of NODE-2104\n    if (this.operation) {\n      this.operation.cursorState = this.cursorState;\n    }\n  }\n  setCursorBatchSize(value) {\n    this.cursorState.batchSize = value;\n  }\n  cursorBatchSize() {\n    return this.cursorState.batchSize;\n  }\n  setCursorLimit(value) {\n    this.cursorState.limit = value;\n  }\n  cursorLimit() {\n    return this.cursorState.limit;\n  }\n  setCursorSkip(value) {\n    this.cursorState.skip = value;\n  }\n  cursorSkip() {\n    return this.cursorState.skip;\n  }\n\n  /**\n   * Retrieve the next document from the cursor\n   * @method\n   * @param {resultCallback} callback A callback function\n   */\n  _next(callback) {\n    nextFunction(this, callback);\n  }\n\n  /**\n   * Clone the cursor\n   * @method\n   * @return {Cursor}\n   */\n  clone() {\n    const clonedOptions = mergeOptions({}, this.options);\n    delete clonedOptions.session;\n    return this.topology.cursor(this.ns, this.cmd, clonedOptions);\n  }\n\n  /**\n   * Checks if the cursor is dead\n   * @method\n   * @return {boolean} A boolean signifying if the cursor is dead or not\n   */\n  isDead() {\n    return this.cursorState.dead === true;\n  }\n\n  /**\n   * Checks if the cursor was killed by the application\n   * @method\n   * @return {boolean} A boolean signifying if the cursor was killed by the application\n   */\n  isKilled() {\n    return this.cursorState.killed === true;\n  }\n\n  /**\n   * Checks if the cursor notified it's caller about it's death\n   * @method\n   * @return {boolean} A boolean signifying if the cursor notified the callback\n   */\n  isNotified() {\n    return this.cursorState.notified === true;\n  }\n\n  /**\n   * Returns current buffered documents length\n   * @method\n   * @return {number} The number of items in the buffered documents\n   */\n  bufferedCount() {\n    return this.cursorState.documents.length - this.cursorState.cursorIndex;\n  }\n\n  /**\n   * Returns current buffered documents\n   * @method\n   * @return {Array} An array of buffered documents\n   */\n  readBufferedDocuments(number) {\n    const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\n    const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\n    let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);\n\n    // Transform the doc with passed in transformation method if provided\n    if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {\n      // Transform all the elements\n      for (let i = 0; i < elements.length; i++) {\n        elements[i] = this.cursorState.transforms.doc(elements[i]);\n      }\n    }\n\n    // Ensure we do not return any more documents than the limit imposed\n    // Just return the number of elements up to the limit\n    if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {\n      elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\n      this.kill();\n    }\n\n    // Adjust current limit\n    this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\n    this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;\n\n    // Return elements\n    return elements;\n  }\n\n  /**\n   * Resets local state for this cursor instance, and issues a `killCursors` command to the server\n   *\n   * @param {resultCallback} callback A callback function\n   */\n  kill(callback) {\n    // Set cursor to dead\n    this.cursorState.dead = true;\n    this.cursorState.killed = true;\n    // Remove documents\n    this.cursorState.documents = [];\n\n    // If no cursor id just return\n    if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {\n      if (callback) callback(null, null);\n      return;\n    }\n    this.server.killCursors(this.ns, this.cursorState, callback);\n  }\n\n  /**\n   * Resets the cursor\n   */\n  rewind() {\n    if (this.cursorState.init) {\n      if (!this.cursorState.dead) {\n        this.kill();\n      }\n      this.cursorState.currentLimit = 0;\n      this.cursorState.init = false;\n      this.cursorState.dead = false;\n      this.cursorState.killed = false;\n      this.cursorState.notified = false;\n      this.cursorState.documents = [];\n      this.cursorState.cursorId = null;\n      this.cursorState.cursorIndex = 0;\n    }\n  }\n\n  // Internal methods\n  _read() {\n    if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {\n      return this.push(null);\n    }\n\n    // Get the next item\n    this._next((err, result) => {\n      if (err) {\n        if (this.listeners('error') && this.listeners('error').length > 0) {\n          this.emit('error', err);\n        }\n        if (!this.isDead()) this.close();\n\n        // Emit end event\n        this.emit('end');\n        return this.emit('finish');\n      }\n\n      // If we provided a transformation method\n      if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === 'function' && result != null) {\n        return this.push(this.cursorState.streamOptions.transform(result));\n      }\n\n      // Return the result\n      this.push(result);\n      if (result === null && this.isDead()) {\n        this.once('end', () => {\n          this.close();\n          this.emit('finish');\n        });\n      }\n    });\n  }\n  _endSession(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n    const session = this.cursorState.session;\n    if (session && (options.force || session.owner === this)) {\n      this.cursorState.session = undefined;\n      if (this.operation) {\n        this.operation.clearSession();\n      }\n      session.endSession(callback);\n      return true;\n    }\n    if (callback) {\n      callback();\n    }\n    return false;\n  }\n  _getMore(callback) {\n    if (this.logger.isDebug()) {\n      this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);\n    }\n\n    // Set the current batchSize\n    let batchSize = this.cursorState.batchSize;\n    if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {\n      batchSize = this.cursorState.limit - this.cursorState.currentLimit;\n    }\n    const cursorState = this.cursorState;\n    this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {\n      // NOTE: `getMore` modifies `cursorState`, would be very ideal not to do so in the future\n      if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {\n        this._endSession();\n      }\n      callback(err, result, conn);\n    });\n  }\n  _initializeCursor(callback) {\n    const cursor = this;\n\n    // NOTE: this goes away once cursors use `executeOperation`\n    if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {\n      cursor.topology.selectServer(ReadPreference.primaryPreferred, err => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        this._initializeCursor(callback);\n      });\n      return;\n    }\n    function done(err, result) {\n      const cursorState = cursor.cursorState;\n      if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {\n        cursor._endSession();\n      }\n      if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {\n        return setCursorNotified(cursor, callback);\n      }\n      callback(err, result);\n    }\n    const queryCallback = (err, r) => {\n      if (err) {\n        return done(err);\n      }\n      const result = r.message;\n      if (Array.isArray(result.documents) && result.documents.length === 1) {\n        const document = result.documents[0];\n        if (result.queryFailure) {\n          return done(new MongoError(document), null);\n        }\n\n        // Check if we have a command cursor\n        if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {\n          // We have an error document, return the error\n          if (document.$err || document.errmsg) {\n            return done(new MongoError(document), null);\n          }\n\n          // We have a cursor document\n          if (document.cursor != null && typeof document.cursor !== 'string') {\n            const id = document.cursor.id;\n            // If we have a namespace change set the new namespace for getmores\n            if (document.cursor.ns) {\n              cursor.ns = document.cursor.ns;\n            }\n            // Promote id to long if needed\n            cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;\n            cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;\n            cursor.cursorState.operationTime = document.operationTime;\n\n            // If we have a firstBatch set it\n            if (Array.isArray(document.cursor.firstBatch)) {\n              cursor.cursorState.documents = document.cursor.firstBatch; //.reverse();\n            }\n\n            // Return after processing command cursor\n            return done(null, result);\n          }\n        }\n      }\n\n      // Otherwise fall back to regular find path\n      const cursorId = result.cursorId || 0;\n      cursor.cursorState.cursorId = cursorId instanceof Long ? cursorId : Long.fromNumber(cursorId);\n      cursor.cursorState.documents = result.documents;\n      cursor.cursorState.lastCursorId = result.cursorId;\n\n      // Transform the results with passed in transformation method if provided\n      if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === 'function') {\n        cursor.cursorState.documents = cursor.cursorState.transforms.query(result);\n      }\n      done(null, result);\n    };\n    if (cursor.operation) {\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);\n      }\n      executeOperation(cursor.topology, cursor.operation, (err, result) => {\n        if (err) {\n          done(err);\n          return;\n        }\n        cursor.server = cursor.operation.server;\n        cursor.cursorState.init = true;\n\n        // NOTE: this is a special internal method for cloning a cursor, consider removing\n        if (cursor.cursorState.cursorId != null) {\n          return done();\n        }\n        queryCallback(err, result);\n      });\n      return;\n    }\n\n    // Very explicitly choose what is passed to selectServer\n    const serverSelectOptions = {};\n    if (cursor.cursorState.session) {\n      serverSelectOptions.session = cursor.cursorState.session;\n    }\n    if (cursor.operation) {\n      serverSelectOptions.readPreference = cursor.operation.readPreference;\n    } else if (cursor.options.readPreference) {\n      serverSelectOptions.readPreference = cursor.options.readPreference;\n    }\n    return cursor.topology.selectServer(serverSelectOptions, (err, server) => {\n      if (err) {\n        const disconnectHandler = cursor.disconnectHandler;\n        if (disconnectHandler != null) {\n          return disconnectHandler.addObjectAndMethod('cursor', cursor, 'next', [callback], callback);\n        }\n        return callback(err);\n      }\n      cursor.server = server;\n      cursor.cursorState.init = true;\n      if (collationNotSupported(cursor.server, cursor.cmd)) {\n        return callback(new MongoError(`server ${cursor.server.name} does not support collation`));\n      }\n\n      // NOTE: this is a special internal method for cloning a cursor, consider removing\n      if (cursor.cursorState.cursorId != null) {\n        return done();\n      }\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);\n      }\n      if (cursor.cmd.find != null) {\n        server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);\n        return;\n      }\n      const commandOptions = Object.assign({\n        session: cursor.cursorState.session\n      }, cursor.options);\n      server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);\n    });\n  }\n}\nif (SUPPORTS.ASYNC_ITERATOR) {\n  CoreCursor.prototype[Symbol.asyncIterator] = require('../async/async_iterator').asyncIterator;\n}\n\n/**\n * Validate if the pool is dead and return error\n */\nfunction isConnectionDead(self, callback) {\n  if (self.pool && self.pool.isDestroyed()) {\n    self.cursorState.killed = true;\n    const err = new MongoNetworkError(`connection to host ${self.pool.host}:${self.pool.port} was destroyed`);\n    _setCursorNotifiedImpl(self, () => callback(err));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Validate if the cursor is dead but was not explicitly killed by user\n */\nfunction isCursorDeadButNotkilled(self, callback) {\n  // Cursor is dead but not marked killed, return null\n  if (self.cursorState.dead && !self.cursorState.killed) {\n    self.cursorState.killed = true;\n    setCursorNotified(self, callback);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Validate if the cursor is dead and was killed by user\n */\nfunction isCursorDeadAndKilled(self, callback) {\n  if (self.cursorState.dead && self.cursorState.killed) {\n    handleCallback(callback, new MongoError('cursor is dead'));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Validate if the cursor was killed by the user\n */\nfunction isCursorKilled(self, callback) {\n  if (self.cursorState.killed) {\n    setCursorNotified(self, callback);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Mark cursor as being dead and notified\n */\nfunction setCursorDeadAndNotified(self, callback) {\n  self.cursorState.dead = true;\n  setCursorNotified(self, callback);\n}\n\n/**\n * Mark cursor as being notified\n */\nfunction setCursorNotified(self, callback) {\n  _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));\n}\nfunction _setCursorNotifiedImpl(self, callback) {\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n  if (self.cursorState.session) {\n    self._endSession(callback);\n    return;\n  }\n  return callback();\n}\nfunction nextFunction(self, callback) {\n  // We have notified about it\n  if (self.cursorState.notified) {\n    return callback(new Error('cursor is exhausted'));\n  }\n\n  // Cursor is killed return null\n  if (isCursorKilled(self, callback)) return;\n\n  // Cursor is dead but not marked killed, return null\n  if (isCursorDeadButNotkilled(self, callback)) return;\n\n  // We have a dead and killed cursor, attempting to call next should error\n  if (isCursorDeadAndKilled(self, callback)) return;\n\n  // We have just started the cursor\n  if (!self.cursorState.init) {\n    // Topology is not connected, save the call in the provided store to be\n    // Executed at some point when the handler deems it's reconnected\n    if (!self.topology.isConnected(self.options)) {\n      // Only need this for single server, because repl sets and mongos\n      // will always continue trying to reconnect\n      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) {\n        // Reconnect is disabled, so we'll never reconnect\n        return callback(new MongoError('no connection available'));\n      }\n      if (self.disconnectHandler != null) {\n        if (self.topology.isDestroyed()) {\n          // Topology was destroyed, so don't try to wait for it to reconnect\n          return callback(new MongoError('Topology was destroyed'));\n        }\n        self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n        return;\n      }\n    }\n    self._initializeCursor((err, result) => {\n      if (err || result === null) {\n        callback(err, result);\n        return;\n      }\n      nextFunction(self, callback);\n    });\n    return;\n  }\n  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n    // Ensure we kill the cursor on the server\n    self.kill(() =>\n    // Set cursor in dead and notified state\n    setCursorDeadAndNotified(self, callback));\n  } else if (self.cursorState.cursorIndex === self.cursorState.documents.length && !Long.ZERO.equals(self.cursorState.cursorId)) {\n    // Ensure an empty cursor state\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0;\n\n    // Check if topology is destroyed\n    if (self.topology.isDestroyed()) return callback(new MongoNetworkError('connection destroyed, not possible to instantiate cursor'));\n\n    // Check if connection is dead and return if not possible to\n    // execute a getMore on this connection\n    if (isConnectionDead(self, callback)) return;\n\n    // Execute the next get more\n    self._getMore(function (err, doc, connection) {\n      if (err) {\n        return handleCallback(callback, err);\n      }\n\n      // Save the returned connection to ensure all getMore's fire over the same connection\n      self.connection = connection;\n\n      // Tailable cursor getMore result, notify owner about it\n      // No attempt is made here to retry, this is left to the user of the\n      // core module to handle to keep core simple\n      if (self.cursorState.documents.length === 0 && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n        // No more documents in the tailed cursor\n        return handleCallback(callback, new MongoError({\n          message: 'No more documents in tailed cursor',\n          tailable: self.cmd.tailable,\n          awaitData: self.cmd.awaitData\n        }));\n      } else if (self.cursorState.documents.length === 0 && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {\n        return nextFunction(self, callback);\n      }\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n        return setCursorDeadAndNotified(self, callback);\n      }\n      nextFunction(self, callback);\n    });\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n    return handleCallback(callback, new MongoError({\n      message: 'No more documents in tailed cursor',\n      tailable: self.cmd.tailable,\n      awaitData: self.cmd.awaitData\n    }));\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && Long.ZERO.equals(self.cursorState.cursorId)) {\n    setCursorDeadAndNotified(self, callback);\n  } else {\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n      // Ensure we kill the cursor on the server\n      self.kill(() =>\n      // Set cursor in dead and notified state\n      setCursorDeadAndNotified(self, callback));\n      return;\n    }\n\n    // Increment the current cursor limit\n    self.cursorState.currentLimit += 1;\n\n    // Get the document\n    let doc = self.cursorState.documents[self.cursorState.cursorIndex++];\n\n    // Doc overflow\n    if (!doc || doc.$err) {\n      // Ensure we kill the cursor on the server\n      self.kill(() =>\n      // Set cursor in dead and notified state\n      setCursorDeadAndNotified(self, function () {\n        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));\n      }));\n      return;\n    }\n\n    // Transform the doc with passed in transformation method if provided\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {\n      doc = self.cursorState.transforms.doc(doc);\n    }\n\n    // Return the document\n    handleCallback(callback, null, doc);\n  }\n}\nmodule.exports = {\n  CursorState,\n  CoreCursor\n};","map":{"version":3,"names":["Logger","require","retrieveBSON","MongoError","MongoNetworkError","collationNotSupported","ReadPreference","isUnifiedTopology","executeOperation","Readable","SUPPORTS","MongoDBNamespace","mergeOptions","OperationBase","BSON","Long","CursorState","INIT","OPEN","CLOSED","GET_MORE","handleCallback","callback","err","result","process","nextTick","CoreCursor","constructor","topology","ns","cmd","options","objectMode","operation","toString","pool","server","disconnectHandler","bson","s","namespace","fromString","cursorState","cursorId","documents","cursorIndex","dead","killed","init","notified","limit","skip","batchSize","currentLimit","transforms","raw","session","topologyOptions","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","reconnect","logger","fromNumber","lastCursorId","setCursorBatchSize","value","cursorBatchSize","setCursorLimit","cursorLimit","setCursorSkip","cursorSkip","_next","nextFunction","clone","clonedOptions","cursor","isDead","isKilled","isNotified","bufferedCount","length","readBufferedDocuments","number","unreadDocumentsLength","elements","slice","doc","i","kill","isZero","killCursors","rewind","_read","state","push","listeners","emit","close","streamOptions","transform","once","_endSession","force","owner","undefined","clearSession","endSession","_getMore","isDebug","debug","JSON","stringify","query","getMore","conn","_initializeCursor","shouldCheckForSessionSupport","selectServer","primaryPreferred","done","tailable","awaitData","setCursorNotified","queryCallback","r","message","Array","isArray","document","queryFailure","find","virtual","$err","errmsg","id","operationTime","firstBatch","serverSelectOptions","readPreference","addObjectAndMethod","name","commandOptions","Object","assign","command","ASYNC_ITERATOR","prototype","Symbol","asyncIterator","isConnectionDead","self","isDestroyed","host","port","_setCursorNotifiedImpl","isCursorDeadButNotkilled","isCursorDeadAndKilled","isCursorKilled","setCursorDeadAndNotified","Error","isConnected","_type","ZERO","equals","connection","module","exports"],"sources":["C:/Users/minix/Documents/GitHub/digital-portfolio-projects/digital-portfolio-projects/node_modules/mongodb/lib/core/cursor.js"],"sourcesContent":["'use strict';\n\nconst Logger = require('./connection/logger');\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\nconst MongoError = require('./error').MongoError;\nconst MongoNetworkError = require('./error').MongoNetworkError;\nconst collationNotSupported = require('./utils').collationNotSupported;\nconst ReadPreference = require('./topologies/read_preference');\nconst isUnifiedTopology = require('./utils').isUnifiedTopology;\nconst executeOperation = require('../operations/execute_operation');\nconst Readable = require('stream').Readable;\nconst SUPPORTS = require('../utils').SUPPORTS;\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\nconst mergeOptions = require('../utils').mergeOptions;\nconst OperationBase = require('../operations/operation').OperationBase;\n\nconst BSON = retrieveBSON();\nconst Long = BSON.Long;\n\n// Possible states for a cursor\nconst CursorState = {\n  INIT: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  GET_MORE: 3\n};\n\n//\n// Handle callback (including any exceptions thrown)\nfunction handleCallback(callback, err, result) {\n  try {\n    callback(err, result);\n  } catch (err) {\n    process.nextTick(function() {\n      throw err;\n    });\n  }\n}\n\n/**\n * This is a cursor results callback\n *\n * @callback resultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {object} document\n */\n\n/**\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query.\n *\n * **CURSORS Cannot directly be instantiated**\n */\n\n/**\n * The core cursor class. All cursors in the driver build off of this one.\n *\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\n * @property {number} cursorLimit The current cursorLimit for the cursor\n * @property {number} cursorSkip The current cursorSkip for the cursor\n */\nclass CoreCursor extends Readable {\n  /**\n   * Create a new core `Cursor` instance.\n   * **NOTE** Not to be instantiated directly\n   *\n   * @param {object} topology The server topology instance.\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\n   * @param {object} [options=null] Optional settings.\n   * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n   * @param {array} [options.documents=[]] Initial documents list for cursor\n   * @param {object} [options.transforms=null] Transform methods for the cursor results\n   * @param {function} [options.transforms.query] Transform the value returned from the initial query\n   * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next\n   */\n  constructor(topology, ns, cmd, options) {\n    super({ objectMode: true });\n    options = options || {};\n\n    if (ns instanceof OperationBase) {\n      this.operation = ns;\n      ns = this.operation.ns.toString();\n      options = this.operation.options;\n      cmd = this.operation.cmd ? this.operation.cmd : {};\n    }\n\n    // Cursor pool\n    this.pool = null;\n    // Cursor server\n    this.server = null;\n\n    // Do we have a not connected handler\n    this.disconnectHandler = options.disconnectHandler;\n\n    // Set local values\n    this.bson = topology.s.bson;\n    this.ns = ns;\n    this.namespace = MongoDBNamespace.fromString(ns);\n    this.cmd = cmd;\n    this.options = options;\n    this.topology = topology;\n\n    // All internal state\n    this.cursorState = {\n      cursorId: null,\n      cmd,\n      documents: options.documents || [],\n      cursorIndex: 0,\n      dead: false,\n      killed: false,\n      init: false,\n      notified: false,\n      limit: options.limit || cmd.limit || 0,\n      skip: options.skip || cmd.skip || 0,\n      batchSize: options.batchSize || cmd.batchSize || 1000,\n      currentLimit: 0,\n      // Result field name if not a cursor (contains the array of results)\n      transforms: options.transforms,\n      raw: options.raw || (cmd && cmd.raw)\n    };\n\n    if (typeof options.session === 'object') {\n      this.cursorState.session = options.session;\n    }\n\n    // Add promoteLong to cursor state\n    const topologyOptions = topology.s.options;\n    if (typeof topologyOptions.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = topologyOptions.promoteLongs;\n    } else if (typeof options.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = options.promoteLongs;\n    }\n\n    // Add promoteValues to cursor state\n    if (typeof topologyOptions.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = topologyOptions.promoteValues;\n    } else if (typeof options.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = options.promoteValues;\n    }\n\n    // Add promoteBuffers to cursor state\n    if (typeof topologyOptions.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;\n    } else if (typeof options.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = options.promoteBuffers;\n    }\n\n    // Add bsonRegExp to cursor state\n    if (typeof topologyOptions.bsonRegExp === 'boolean') {\n      this.cursorState.bsonRegExp = topologyOptions.bsonRegExp;\n    } else if (typeof options.bsonRegExp === 'boolean') {\n      this.cursorState.bsonRegExp = options.bsonRegExp;\n    }\n\n    if (topologyOptions.reconnect) {\n      this.cursorState.reconnect = topologyOptions.reconnect;\n    }\n\n    // Logger\n    this.logger = Logger('Cursor', topologyOptions);\n\n    //\n    // Did we pass in a cursor id\n    if (typeof cmd === 'number') {\n      this.cursorState.cursorId = Long.fromNumber(cmd);\n      this.cursorState.lastCursorId = this.cursorState.cursorId;\n    } else if (cmd instanceof Long) {\n      this.cursorState.cursorId = cmd;\n      this.cursorState.lastCursorId = cmd;\n    }\n\n    // TODO: remove as part of NODE-2104\n    if (this.operation) {\n      this.operation.cursorState = this.cursorState;\n    }\n  }\n\n  setCursorBatchSize(value) {\n    this.cursorState.batchSize = value;\n  }\n\n  cursorBatchSize() {\n    return this.cursorState.batchSize;\n  }\n\n  setCursorLimit(value) {\n    this.cursorState.limit = value;\n  }\n\n  cursorLimit() {\n    return this.cursorState.limit;\n  }\n\n  setCursorSkip(value) {\n    this.cursorState.skip = value;\n  }\n\n  cursorSkip() {\n    return this.cursorState.skip;\n  }\n\n  /**\n   * Retrieve the next document from the cursor\n   * @method\n   * @param {resultCallback} callback A callback function\n   */\n  _next(callback) {\n    nextFunction(this, callback);\n  }\n\n  /**\n   * Clone the cursor\n   * @method\n   * @return {Cursor}\n   */\n  clone() {\n    const clonedOptions = mergeOptions({}, this.options);\n    delete clonedOptions.session;\n    return this.topology.cursor(this.ns, this.cmd, clonedOptions);\n  }\n\n  /**\n   * Checks if the cursor is dead\n   * @method\n   * @return {boolean} A boolean signifying if the cursor is dead or not\n   */\n  isDead() {\n    return this.cursorState.dead === true;\n  }\n\n  /**\n   * Checks if the cursor was killed by the application\n   * @method\n   * @return {boolean} A boolean signifying if the cursor was killed by the application\n   */\n  isKilled() {\n    return this.cursorState.killed === true;\n  }\n\n  /**\n   * Checks if the cursor notified it's caller about it's death\n   * @method\n   * @return {boolean} A boolean signifying if the cursor notified the callback\n   */\n  isNotified() {\n    return this.cursorState.notified === true;\n  }\n\n  /**\n   * Returns current buffered documents length\n   * @method\n   * @return {number} The number of items in the buffered documents\n   */\n  bufferedCount() {\n    return this.cursorState.documents.length - this.cursorState.cursorIndex;\n  }\n\n  /**\n   * Returns current buffered documents\n   * @method\n   * @return {Array} An array of buffered documents\n   */\n  readBufferedDocuments(number) {\n    const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\n    const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\n    let elements = this.cursorState.documents.slice(\n      this.cursorState.cursorIndex,\n      this.cursorState.cursorIndex + length\n    );\n\n    // Transform the doc with passed in transformation method if provided\n    if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {\n      // Transform all the elements\n      for (let i = 0; i < elements.length; i++) {\n        elements[i] = this.cursorState.transforms.doc(elements[i]);\n      }\n    }\n\n    // Ensure we do not return any more documents than the limit imposed\n    // Just return the number of elements up to the limit\n    if (\n      this.cursorState.limit > 0 &&\n      this.cursorState.currentLimit + elements.length > this.cursorState.limit\n    ) {\n      elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\n      this.kill();\n    }\n\n    // Adjust current limit\n    this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\n    this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;\n\n    // Return elements\n    return elements;\n  }\n\n  /**\n   * Resets local state for this cursor instance, and issues a `killCursors` command to the server\n   *\n   * @param {resultCallback} callback A callback function\n   */\n  kill(callback) {\n    // Set cursor to dead\n    this.cursorState.dead = true;\n    this.cursorState.killed = true;\n    // Remove documents\n    this.cursorState.documents = [];\n\n    // If no cursor id just return\n    if (\n      this.cursorState.cursorId == null ||\n      this.cursorState.cursorId.isZero() ||\n      this.cursorState.init === false\n    ) {\n      if (callback) callback(null, null);\n      return;\n    }\n\n    this.server.killCursors(this.ns, this.cursorState, callback);\n  }\n\n  /**\n   * Resets the cursor\n   */\n  rewind() {\n    if (this.cursorState.init) {\n      if (!this.cursorState.dead) {\n        this.kill();\n      }\n\n      this.cursorState.currentLimit = 0;\n      this.cursorState.init = false;\n      this.cursorState.dead = false;\n      this.cursorState.killed = false;\n      this.cursorState.notified = false;\n      this.cursorState.documents = [];\n      this.cursorState.cursorId = null;\n      this.cursorState.cursorIndex = 0;\n    }\n  }\n\n  // Internal methods\n  _read() {\n    if ((this.s && this.s.state === CursorState.CLOSED) || this.isDead()) {\n      return this.push(null);\n    }\n\n    // Get the next item\n    this._next((err, result) => {\n      if (err) {\n        if (this.listeners('error') && this.listeners('error').length > 0) {\n          this.emit('error', err);\n        }\n        if (!this.isDead()) this.close();\n\n        // Emit end event\n        this.emit('end');\n        return this.emit('finish');\n      }\n\n      // If we provided a transformation method\n      if (\n        this.cursorState.streamOptions &&\n        typeof this.cursorState.streamOptions.transform === 'function' &&\n        result != null\n      ) {\n        return this.push(this.cursorState.streamOptions.transform(result));\n      }\n\n      // Return the result\n      this.push(result);\n\n      if (result === null && this.isDead()) {\n        this.once('end', () => {\n          this.close();\n          this.emit('finish');\n        });\n      }\n    });\n  }\n\n  _endSession(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    const session = this.cursorState.session;\n\n    if (session && (options.force || session.owner === this)) {\n      this.cursorState.session = undefined;\n\n      if (this.operation) {\n        this.operation.clearSession();\n      }\n\n      session.endSession(callback);\n      return true;\n    }\n\n    if (callback) {\n      callback();\n    }\n\n    return false;\n  }\n\n  _getMore(callback) {\n    if (this.logger.isDebug()) {\n      this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);\n    }\n\n    // Set the current batchSize\n    let batchSize = this.cursorState.batchSize;\n    if (\n      this.cursorState.limit > 0 &&\n      this.cursorState.currentLimit + batchSize > this.cursorState.limit\n    ) {\n      batchSize = this.cursorState.limit - this.cursorState.currentLimit;\n    }\n\n    const cursorState = this.cursorState;\n    this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {\n      // NOTE: `getMore` modifies `cursorState`, would be very ideal not to do so in the future\n      if (err || (cursorState.cursorId && cursorState.cursorId.isZero())) {\n        this._endSession();\n      }\n\n      callback(err, result, conn);\n    });\n  }\n\n  _initializeCursor(callback) {\n    const cursor = this;\n\n    // NOTE: this goes away once cursors use `executeOperation`\n    if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {\n      cursor.topology.selectServer(ReadPreference.primaryPreferred, err => {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        this._initializeCursor(callback);\n      });\n\n      return;\n    }\n\n    function done(err, result) {\n      const cursorState = cursor.cursorState;\n      if (err || (cursorState.cursorId && cursorState.cursorId.isZero())) {\n        cursor._endSession();\n      }\n\n      if (\n        cursorState.documents.length === 0 &&\n        cursorState.cursorId &&\n        cursorState.cursorId.isZero() &&\n        !cursor.cmd.tailable &&\n        !cursor.cmd.awaitData\n      ) {\n        return setCursorNotified(cursor, callback);\n      }\n\n      callback(err, result);\n    }\n\n    const queryCallback = (err, r) => {\n      if (err) {\n        return done(err);\n      }\n\n      const result = r.message;\n\n      if (Array.isArray(result.documents) && result.documents.length === 1) {\n        const document = result.documents[0];\n\n        if (result.queryFailure) {\n          return done(new MongoError(document), null);\n        }\n\n        // Check if we have a command cursor\n        if (!cursor.cmd.find || (cursor.cmd.find && cursor.cmd.virtual === false)) {\n          // We have an error document, return the error\n          if (document.$err || document.errmsg) {\n            return done(new MongoError(document), null);\n          }\n\n          // We have a cursor document\n          if (document.cursor != null && typeof document.cursor !== 'string') {\n            const id = document.cursor.id;\n            // If we have a namespace change set the new namespace for getmores\n            if (document.cursor.ns) {\n              cursor.ns = document.cursor.ns;\n            }\n            // Promote id to long if needed\n            cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;\n            cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;\n            cursor.cursorState.operationTime = document.operationTime;\n\n            // If we have a firstBatch set it\n            if (Array.isArray(document.cursor.firstBatch)) {\n              cursor.cursorState.documents = document.cursor.firstBatch; //.reverse();\n            }\n\n            // Return after processing command cursor\n            return done(null, result);\n          }\n        }\n      }\n\n      // Otherwise fall back to regular find path\n      const cursorId = result.cursorId || 0;\n      cursor.cursorState.cursorId = cursorId instanceof Long ? cursorId : Long.fromNumber(cursorId);\n      cursor.cursorState.documents = result.documents;\n      cursor.cursorState.lastCursorId = result.cursorId;\n\n      // Transform the results with passed in transformation method if provided\n      if (\n        cursor.cursorState.transforms &&\n        typeof cursor.cursorState.transforms.query === 'function'\n      ) {\n        cursor.cursorState.documents = cursor.cursorState.transforms.query(result);\n      }\n\n      done(null, result);\n    };\n\n    if (cursor.operation) {\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(\n          `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(\n            cursor.query\n          )}]`\n        );\n      }\n\n      executeOperation(cursor.topology, cursor.operation, (err, result) => {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        cursor.server = cursor.operation.server;\n        cursor.cursorState.init = true;\n\n        // NOTE: this is a special internal method for cloning a cursor, consider removing\n        if (cursor.cursorState.cursorId != null) {\n          return done();\n        }\n\n        queryCallback(err, result);\n      });\n\n      return;\n    }\n\n    // Very explicitly choose what is passed to selectServer\n    const serverSelectOptions = {};\n    if (cursor.cursorState.session) {\n      serverSelectOptions.session = cursor.cursorState.session;\n    }\n\n    if (cursor.operation) {\n      serverSelectOptions.readPreference = cursor.operation.readPreference;\n    } else if (cursor.options.readPreference) {\n      serverSelectOptions.readPreference = cursor.options.readPreference;\n    }\n\n    return cursor.topology.selectServer(serverSelectOptions, (err, server) => {\n      if (err) {\n        const disconnectHandler = cursor.disconnectHandler;\n        if (disconnectHandler != null) {\n          return disconnectHandler.addObjectAndMethod(\n            'cursor',\n            cursor,\n            'next',\n            [callback],\n            callback\n          );\n        }\n\n        return callback(err);\n      }\n\n      cursor.server = server;\n      cursor.cursorState.init = true;\n      if (collationNotSupported(cursor.server, cursor.cmd)) {\n        return callback(new MongoError(`server ${cursor.server.name} does not support collation`));\n      }\n\n      // NOTE: this is a special internal method for cloning a cursor, consider removing\n      if (cursor.cursorState.cursorId != null) {\n        return done();\n      }\n\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(\n          `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(\n            cursor.query\n          )}]`\n        );\n      }\n\n      if (cursor.cmd.find != null) {\n        server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);\n        return;\n      }\n\n      const commandOptions = Object.assign({ session: cursor.cursorState.session }, cursor.options);\n      server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);\n    });\n  }\n}\n\nif (SUPPORTS.ASYNC_ITERATOR) {\n  CoreCursor.prototype[Symbol.asyncIterator] = require('../async/async_iterator').asyncIterator;\n}\n\n/**\n * Validate if the pool is dead and return error\n */\nfunction isConnectionDead(self, callback) {\n  if (self.pool && self.pool.isDestroyed()) {\n    self.cursorState.killed = true;\n    const err = new MongoNetworkError(\n      `connection to host ${self.pool.host}:${self.pool.port} was destroyed`\n    );\n\n    _setCursorNotifiedImpl(self, () => callback(err));\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate if the cursor is dead but was not explicitly killed by user\n */\nfunction isCursorDeadButNotkilled(self, callback) {\n  // Cursor is dead but not marked killed, return null\n  if (self.cursorState.dead && !self.cursorState.killed) {\n    self.cursorState.killed = true;\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate if the cursor is dead and was killed by user\n */\nfunction isCursorDeadAndKilled(self, callback) {\n  if (self.cursorState.dead && self.cursorState.killed) {\n    handleCallback(callback, new MongoError('cursor is dead'));\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate if the cursor was killed by the user\n */\nfunction isCursorKilled(self, callback) {\n  if (self.cursorState.killed) {\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Mark cursor as being dead and notified\n */\nfunction setCursorDeadAndNotified(self, callback) {\n  self.cursorState.dead = true;\n  setCursorNotified(self, callback);\n}\n\n/**\n * Mark cursor as being notified\n */\nfunction setCursorNotified(self, callback) {\n  _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));\n}\n\nfunction _setCursorNotifiedImpl(self, callback) {\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n\n  if (self.cursorState.session) {\n    self._endSession(callback);\n    return;\n  }\n\n  return callback();\n}\n\nfunction nextFunction(self, callback) {\n  // We have notified about it\n  if (self.cursorState.notified) {\n    return callback(new Error('cursor is exhausted'));\n  }\n\n  // Cursor is killed return null\n  if (isCursorKilled(self, callback)) return;\n\n  // Cursor is dead but not marked killed, return null\n  if (isCursorDeadButNotkilled(self, callback)) return;\n\n  // We have a dead and killed cursor, attempting to call next should error\n  if (isCursorDeadAndKilled(self, callback)) return;\n\n  // We have just started the cursor\n  if (!self.cursorState.init) {\n    // Topology is not connected, save the call in the provided store to be\n    // Executed at some point when the handler deems it's reconnected\n    if (!self.topology.isConnected(self.options)) {\n      // Only need this for single server, because repl sets and mongos\n      // will always continue trying to reconnect\n      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) {\n        // Reconnect is disabled, so we'll never reconnect\n        return callback(new MongoError('no connection available'));\n      }\n\n      if (self.disconnectHandler != null) {\n        if (self.topology.isDestroyed()) {\n          // Topology was destroyed, so don't try to wait for it to reconnect\n          return callback(new MongoError('Topology was destroyed'));\n        }\n\n        self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n        return;\n      }\n    }\n\n    self._initializeCursor((err, result) => {\n      if (err || result === null) {\n        callback(err, result);\n        return;\n      }\n\n      nextFunction(self, callback);\n    });\n\n    return;\n  }\n\n  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n    // Ensure we kill the cursor on the server\n    self.kill(() =>\n      // Set cursor in dead and notified state\n      setCursorDeadAndNotified(self, callback)\n    );\n  } else if (\n    self.cursorState.cursorIndex === self.cursorState.documents.length &&\n    !Long.ZERO.equals(self.cursorState.cursorId)\n  ) {\n    // Ensure an empty cursor state\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0;\n\n    // Check if topology is destroyed\n    if (self.topology.isDestroyed())\n      return callback(\n        new MongoNetworkError('connection destroyed, not possible to instantiate cursor')\n      );\n\n    // Check if connection is dead and return if not possible to\n    // execute a getMore on this connection\n    if (isConnectionDead(self, callback)) return;\n\n    // Execute the next get more\n    self._getMore(function(err, doc, connection) {\n      if (err) {\n        return handleCallback(callback, err);\n      }\n\n      // Save the returned connection to ensure all getMore's fire over the same connection\n      self.connection = connection;\n\n      // Tailable cursor getMore result, notify owner about it\n      // No attempt is made here to retry, this is left to the user of the\n      // core module to handle to keep core simple\n      if (\n        self.cursorState.documents.length === 0 &&\n        self.cmd.tailable &&\n        Long.ZERO.equals(self.cursorState.cursorId)\n      ) {\n        // No more documents in the tailed cursor\n        return handleCallback(\n          callback,\n          new MongoError({\n            message: 'No more documents in tailed cursor',\n            tailable: self.cmd.tailable,\n            awaitData: self.cmd.awaitData\n          })\n        );\n      } else if (\n        self.cursorState.documents.length === 0 &&\n        self.cmd.tailable &&\n        !Long.ZERO.equals(self.cursorState.cursorId)\n      ) {\n        return nextFunction(self, callback);\n      }\n\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n        return setCursorDeadAndNotified(self, callback);\n      }\n\n      nextFunction(self, callback);\n    });\n  } else if (\n    self.cursorState.documents.length === self.cursorState.cursorIndex &&\n    self.cmd.tailable &&\n    Long.ZERO.equals(self.cursorState.cursorId)\n  ) {\n    return handleCallback(\n      callback,\n      new MongoError({\n        message: 'No more documents in tailed cursor',\n        tailable: self.cmd.tailable,\n        awaitData: self.cmd.awaitData\n      })\n    );\n  } else if (\n    self.cursorState.documents.length === self.cursorState.cursorIndex &&\n    Long.ZERO.equals(self.cursorState.cursorId)\n  ) {\n    setCursorDeadAndNotified(self, callback);\n  } else {\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n      // Ensure we kill the cursor on the server\n      self.kill(() =>\n        // Set cursor in dead and notified state\n        setCursorDeadAndNotified(self, callback)\n      );\n\n      return;\n    }\n\n    // Increment the current cursor limit\n    self.cursorState.currentLimit += 1;\n\n    // Get the document\n    let doc = self.cursorState.documents[self.cursorState.cursorIndex++];\n\n    // Doc overflow\n    if (!doc || doc.$err) {\n      // Ensure we kill the cursor on the server\n      self.kill(() =>\n        // Set cursor in dead and notified state\n        setCursorDeadAndNotified(self, function() {\n          handleCallback(callback, new MongoError(doc ? doc.$err : undefined));\n        })\n      );\n\n      return;\n    }\n\n    // Transform the doc with passed in transformation method if provided\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {\n      doc = self.cursorState.transforms.doc(doc);\n    }\n\n    // Return the document\n    handleCallback(callback, null, doc);\n  }\n}\n\nmodule.exports = {\n  CursorState,\n  CoreCursor\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}